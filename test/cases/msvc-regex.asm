; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23918.0

        TITLE   C:\Users\ADMINI~1\AppData\Local\Temp\2\gcc-explorer-compiler11653-3488-1xp4orl.hsemi\example.cpp
        .686P
        .XMM
        include listing.inc
        .model  flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST   SEGMENT
?_Meta_map@std@@3QBDB DB 028H                     ; std::_Meta_map
        DB      029H
        DB      024H
        DB      05eH
        DB      02eH
        DB      02aH
        DB      02bH
        DB      03fH
        DB      05bH
        DB      05dH
        DB      07cH
        DB      05cH
        DB      02dH
        DB      07bH
        DB      07dH
        DB      02cH
        DB      03aH
        DB      03dH
        DB      021H
        DB      0aH
        DB      0dH
        DB      08H
        DB      00H
        ORG $+1
$SG45541 DB     'Some people, when confronted with a problem, think "I kn'
        DB      'ow, I''ll use regular expressions." Now they have two problem'
        DB      's.', 00H
        ORG $+1
$SG45542 DB     'REGULAR EXPRESSIONS', 00H
CONST   ENDS
PUBLIC  ?_Hash_seq@std@@YAIPBEI@Z             ; std::_Hash_seq
PUBLIC  ??0exception@std@@QAE@QBD@Z       ; std::exception::exception
PUBLIC  ??0exception@std@@QAE@QBDH@Z                        ; std::exception::exception
PUBLIC  ??0exception@std@@QAE@ABV01@@Z                  ; std::exception::exception
PUBLIC  ??1exception@std@@UAE@XZ                    ; std::exception::~exception
PUBLIC  ?what@exception@std@@UBEPBDXZ                 ; std::exception::what
PUBLIC  ??_Gexception@std@@UAEPAXI@Z                        ; std::exception::`scalar deleting destructor'
PUBLIC  ?max@?$numeric_limits@D@std@@SADXZ      ; std::numeric_limits<char>::max
PUBLIC  ?max@?$numeric_limits@E@std@@SAEXZ      ; std::numeric_limits<unsigned char>::max
PUBLIC  ??2@YAPAXIPAX@Z                           ; operator new
PUBLIC  ?compare@?$char_traits@D@std@@SAHPBD0I@Z    ; std::char_traits<char>::compare
PUBLIC  ?length@?$char_traits@D@std@@SAIPBD@Z             ; std::char_traits<char>::length
PUBLIC  ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z   ; std::char_traits<char>::copy
PUBLIC  ?move@?$char_traits@D@std@@SAPADPADPBDI@Z   ; std::char_traits<char>::move
PUBLIC  ?assign@?$char_traits@D@std@@SAPADPADID@Z   ; std::char_traits<char>::assign
PUBLIC  ?assign@?$char_traits@D@std@@SAXAADABD@Z    ; std::char_traits<char>::assign
PUBLIC  ?_Orphan_all@_Container_base0@std@@QAEXXZ   ; std::_Container_base0::_Orphan_all
PUBLIC  ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z          ; std::_Iterator_base0::_Adopt
PUBLIC  ?_Getcont@_Iterator_base0@std@@QBEPBU_Container_base0@2@XZ ; std::_Iterator_base0::_Getcont
PUBLIC  ?_Allocate@std@@YAPAXII_N@Z       ; std::_Allocate
PUBLIC  ?_Deallocate@std@@YAXPAXII@Z                        ; std::_Deallocate
PUBLIC  ?_Init_atomic_counter@std@@YAXAAKK@Z                ; std::_Init_atomic_counter
PUBLIC  ??0?$allocator@D@std@@QAE@XZ                        ; std::allocator<char>::allocator<char>
PUBLIC  ??0?$allocator@D@std@@QAE@ABV01@@Z      ; std::allocator<char>::allocator<char>
PUBLIC  ?deallocate@?$allocator@D@std@@QAEXPADI@Z   ; std::allocator<char>::deallocate
PUBLIC  ?allocate@?$allocator@D@std@@QAEPADI@Z          ; std::allocator<char>::allocate
PUBLIC  ?max_size@?$allocator@D@std@@QBEIXZ   ; std::allocator<char>::max_size
PUBLIC  ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC  ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC  ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC  ??4?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEAAU01@$$QAU01@@Z ; std::_Wrap_alloc<std::allocator<char> >::operator=
PUBLIC  ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC  ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC  ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC  ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC  ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC  ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC  ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
PUBLIC  ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
PUBLIC  ??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
PUBLIC  ?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Move_alloc
PUBLIC  ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC  ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC  ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
PUBLIC  ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
PUBLIC  ?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx
PUBLIC  ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
PUBLIC  ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
PUBLIC  ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
PUBLIC  ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC  ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC  ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
PUBLIC  ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
PUBLIC  ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC  ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC  ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC  ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC  ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
PUBLIC  ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC  ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC  ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC  ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC  ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC  ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC  ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC  ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
PUBLIC  ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
PUBLIC  ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
PUBLIC  ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
PUBLIC  ?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end
PUBLIC  ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC  ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC  ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
PUBLIC  ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC  ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC  ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
PUBLIC  ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
PUBLIC  ?_Traits_compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAHQBDI0I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Traits_compare
PUBLIC  ?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Clamp_suffix_size
PUBLIC  ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
PUBLIC  ?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign
PUBLIC  ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC  ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC  ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC  ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC  ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC  ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC  ?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset
PUBLIC  ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC  ??0runtime_error@std@@QAE@PBD@Z           ; std::runtime_error::runtime_error
PUBLIC  ??1runtime_error@std@@UAE@XZ                        ; std::runtime_error::~runtime_error
PUBLIC  ??0runtime_error@std@@QAE@ABV01@@Z      ; std::runtime_error::runtime_error
PUBLIC  ??_Gruntime_error@std@@UAEPAXI@Z            ; std::runtime_error::`scalar deleting destructor'
PUBLIC  ??0bad_cast@std@@QAE@XZ                   ; std::bad_cast::bad_cast
PUBLIC  ??1bad_cast@std@@UAE@XZ                   ; std::bad_cast::~bad_cast
PUBLIC  ??0bad_cast@std@@QAE@ABV01@@Z                 ; std::bad_cast::bad_cast
PUBLIC  ??_Gbad_cast@std@@UAEPAXI@Z       ; std::bad_cast::`scalar deleting destructor'
PUBLIC  ??0_Locinfo@std@@QAE@PBD@Z              ; std::_Locinfo::_Locinfo
PUBLIC  ??1_Locinfo@std@@QAE@XZ                   ; std::_Locinfo::~_Locinfo
PUBLIC  ?_Getcoll@_Locinfo@std@@QBE?AU_Collvec@@XZ  ; std::_Locinfo::_Getcoll
PUBLIC  ?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ        ; std::_Locinfo::_Getctype
PUBLIC  ??0?$_Yarn@D@std@@QAE@XZ                    ; std::_Yarn<char>::_Yarn<char>
PUBLIC  ??1?$_Yarn@D@std@@QAE@XZ                    ; std::_Yarn<char>::~_Yarn<char>
PUBLIC  ?c_str@?$_Yarn@D@std@@QBEPBDXZ                  ; std::_Yarn<char>::c_str
PUBLIC  ?_Tidy@?$_Yarn@D@std@@AAEXXZ                        ; std::_Yarn<char>::_Tidy
PUBLIC  ??0?$_Yarn@_W@std@@QAE@XZ             ; std::_Yarn<wchar_t>::_Yarn<wchar_t>
PUBLIC  ??1?$_Yarn@_W@std@@QAE@XZ             ; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
PUBLIC  ?_Tidy@?$_Yarn@_W@std@@AAEXXZ                 ; std::_Yarn<wchar_t>::_Tidy
PUBLIC  ??$_LStrcoll@D@std@@YAHPBD000PBU_Collvec@@@Z        ; std::_LStrcoll<char>
PUBLIC  ??$_LStrxfrm@D@std@@YAIPAD0PBD1PBU_Collvec@@@Z      ; std::_LStrxfrm<char>
PUBLIC  ??1_Facet_base@std@@UAE@XZ              ; std::_Facet_base::~_Facet_base
PUBLIC  ??0_Facet_base@std@@QAE@XZ              ; std::_Facet_base::_Facet_base
PUBLIC  ??_G_Facet_base@std@@UAEPAXI@Z                  ; std::_Facet_base::`scalar deleting destructor'
PUBLIC  ??0id@locale@std@@QAE@I@Z             ; std::locale::id::id
PUBLIC  ??Bid@locale@std@@QAEIXZ                    ; std::locale::id::operator unsigned int
PUBLIC  ?_Incref@facet@locale@std@@UAEXXZ         ; std::locale::facet::_Incref
PUBLIC  ?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ ; std::locale::facet::_Decref
PUBLIC  ??0facet@locale@std@@IAE@I@Z                        ; std::locale::facet::facet
PUBLIC  ??1facet@locale@std@@MAE@XZ       ; std::locale::facet::~facet
PUBLIC  ??_Gfacet@locale@std@@MAEPAXI@Z           ; std::locale::facet::`scalar deleting destructor'
PUBLIC  ??0locale@std@@QAE@XZ                         ; std::locale::locale
PUBLIC  ??1locale@std@@QAE@XZ                         ; std::locale::~locale
PUBLIC  ?name@locale@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::locale::name
PUBLIC  ?c_str@locale@std@@QBEPBDXZ       ; std::locale::c_str
PUBLIC  ?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z   ; std::locale::_Getfacet
PUBLIC  ??0ctype_base@std@@QAE@I@Z              ; std::ctype_base::ctype_base
PUBLIC  ??1ctype_base@std@@UAE@XZ             ; std::ctype_base::~ctype_base
PUBLIC  ??_Gctype_base@std@@UAEPAXI@Z                 ; std::ctype_base::`scalar deleting destructor'
PUBLIC  ?is@?$ctype@D@std@@QBE_NFD@Z                        ; std::ctype<char>::is
PUBLIC  ?tolower@?$ctype@D@std@@QBEDD@Z           ; std::ctype<char>::tolower
PUBLIC  ?tolower@?$ctype@D@std@@QBEPBDPADPBD@Z          ; std::ctype<char>::tolower
PUBLIC  ??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z       ; std::ctype<char>::ctype<char>
PUBLIC  ?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::ctype<char>::_Getcat
PUBLIC  ??1?$ctype@D@std@@MAE@XZ                    ; std::ctype<char>::~ctype<char>
PUBLIC  ?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z  ; std::ctype<char>::_Init
PUBLIC  ?_Tidy@?$ctype@D@std@@IAEXXZ                        ; std::ctype<char>::_Tidy
PUBLIC  ?do_tolower@?$ctype@D@std@@MBEDD@Z      ; std::ctype<char>::do_tolower
PUBLIC  ?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z   ; std::ctype<char>::do_tolower
PUBLIC  ?do_toupper@?$ctype@D@std@@MBEDD@Z      ; std::ctype<char>::do_toupper
PUBLIC  ?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z   ; std::ctype<char>::do_toupper
PUBLIC  ?do_widen@?$ctype@D@std@@MBEDD@Z            ; std::ctype<char>::do_widen
PUBLIC  ?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z    ; std::ctype<char>::do_widen
PUBLIC  ?do_narrow@?$ctype@D@std@@MBEDDD@Z      ; std::ctype<char>::do_narrow
PUBLIC  ?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z  ; std::ctype<char>::do_narrow
PUBLIC  ??_G?$ctype@D@std@@MAEPAXI@Z                        ; std::ctype<char>::`scalar deleting destructor'
PUBLIC  ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
PUBLIC  ??Iregex_constants@std@@YA?AW4syntax_option_type@01@W4201@0@Z ; std::regex_constants::operator&
PUBLIC  ??Uregex_constants@std@@YA?AW4syntax_option_type@01@W4201@0@Z ; std::regex_constants::operator|
PUBLIC  ??$_Get@D@_Cl_names@std@@QBEPBDXZ         ; std::_Cl_names::_Get<char>
PUBLIC  ?length@?$_Regex_traits@D@std@@SAIPBD@Z       ; std::_Regex_traits<char>::length
PUBLIC  ??0?$_Regex_traits@D@std@@QAE@XZ            ; std::_Regex_traits<char>::_Regex_traits<char>
PUBLIC  ?translate@?$_Regex_traits@D@std@@QBEDD@Z   ; std::_Regex_traits<char>::translate
PUBLIC  ?translate_nocase@?$_Regex_traits@D@std@@QBEDD@Z ; std::_Regex_traits<char>::translate_nocase
PUBLIC  ?isctype@?$_Regex_traits@D@std@@QBE_NDF@Z   ; std::_Regex_traits<char>::isctype
PUBLIC  ?_Getcoll@?$_Regex_traits@D@std@@QBEPBV?$collate@D@2@XZ ; std::_Regex_traits<char>::_Getcoll
PUBLIC  ?_Getctype@?$_Regex_traits@D@std@@QBEPBV?$ctype@D@2@XZ ; std::_Regex_traits<char>::_Getctype
PUBLIC  ?_Cache_locale@?$_Regex_traits@D@std@@AAEXXZ        ; std::_Regex_traits<char>::_Cache_locale
PUBLIC  ??1?$_Regex_traits@D@std@@QAE@XZ            ; std::_Regex_traits<char>::~_Regex_traits<char>
PUBLIC  ?value@?$regex_traits@D@std@@QBEHDH@Z             ; std::regex_traits<char>::value
PUBLIC  ??0?$regex_traits@D@std@@QAE@XZ           ; std::regex_traits<char>::regex_traits<char>
PUBLIC  ??1?$regex_traits@D@std@@QAE@XZ           ; std::regex_traits<char>::~regex_traits<char>
PUBLIC  ??_5std@@YA?AW4_Node_flags@0@AAW410@W410@@Z ; std::operator|=
PUBLIC  ??_6std@@YA?AW4_Node_flags@0@AAW410@W410@@Z ; std::operator^=
PUBLIC  ??0_Bitmap@std@@QAE@XZ                          ; std::_Bitmap::_Bitmap
PUBLIC  ??0_Node_base@std@@QAE@W4_Node_type@1@W4_Node_flags@1@@Z ; std::_Node_base::_Node_base
PUBLIC  ??1_Node_base@std@@UAE@XZ             ; std::_Node_base::~_Node_base
PUBLIC  ??_G_Node_base@std@@UAEPAXI@Z                 ; std::_Node_base::`scalar deleting destructor'
PUBLIC  ?_Destroy_node@std@@YAXPAV_Node_base@1@0@Z  ; std::_Destroy_node
PUBLIC  ??0_Root_node@std@@QAE@XZ             ; std::_Root_node::_Root_node
PUBLIC  ??1_Root_node@std@@UAE@XZ             ; std::_Root_node::~_Root_node
PUBLIC  ??_G_Root_node@std@@UAEPAXI@Z                 ; std::_Root_node::`scalar deleting destructor'
PUBLIC  ??0_Node_end_group@std@@QAE@W4_Node_type@1@W4_Node_flags@1@PAV_Node_base@1@@Z ; std::_Node_end_group::_Node_end_group
PUBLIC  ??1_Node_end_group@std@@UAE@XZ                  ; std::_Node_end_group::~_Node_end_group
PUBLIC  ??_G_Node_end_group@std@@UAEPAXI@Z      ; std::_Node_end_group::`scalar deleting destructor'
PUBLIC  ??0_Node_assert@std@@QAE@W4_Node_type@1@W4_Node_flags@1@@Z ; std::_Node_assert::_Node_assert
PUBLIC  ??1_Node_assert@std@@UAE@XZ       ; std::_Node_assert::~_Node_assert
PUBLIC  ??_G_Node_assert@std@@UAEPAXI@Z           ; std::_Node_assert::`scalar deleting destructor'
PUBLIC  ??0_Node_capture@std@@QAE@I@Z                 ; std::_Node_capture::_Node_capture
PUBLIC  ??1_Node_capture@std@@UAE@XZ                        ; std::_Node_capture::~_Node_capture
PUBLIC  ??_G_Node_capture@std@@UAEPAXI@Z            ; std::_Node_capture::`scalar deleting destructor'
PUBLIC  ??0_Node_back@std@@QAE@I@Z              ; std::_Node_back::_Node_back
PUBLIC  ??1_Node_back@std@@UAE@XZ             ; std::_Node_back::~_Node_back
PUBLIC  ??_G_Node_back@std@@UAEPAXI@Z                 ; std::_Node_back::`scalar deleting destructor'
PUBLIC  ??0_Node_endif@std@@QAE@XZ              ; std::_Node_endif::_Node_endif
PUBLIC  ??1_Node_endif@std@@UAE@XZ              ; std::_Node_endif::~_Node_endif
PUBLIC  ??_G_Node_endif@std@@UAEPAXI@Z                  ; std::_Node_endif::`scalar deleting destructor'
PUBLIC  ??0_Node_if@std@@QAE@PAV_Node_base@1@@Z       ; std::_Node_if::_Node_if
PUBLIC  ??1_Node_if@std@@UAE@XZ                   ; std::_Node_if::~_Node_if
PUBLIC  ??_G_Node_if@std@@UAEPAXI@Z       ; std::_Node_if::`scalar deleting destructor'
PUBLIC  ??0_Node_end_rep@std@@QAE@XZ                        ; std::_Node_end_rep::_Node_end_rep
PUBLIC  ??1_Node_end_rep@std@@UAE@XZ                        ; std::_Node_end_rep::~_Node_end_rep
PUBLIC  ??_G_Node_end_rep@std@@UAEPAXI@Z            ; std::_Node_end_rep::`scalar deleting destructor'
PUBLIC  ??0_Node_rep@std@@QAE@_NHHPAV_Node_end_rep@1@I@Z ; std::_Node_rep::_Node_rep
PUBLIC  ??1_Node_rep@std@@UAE@XZ                    ; std::_Node_rep::~_Node_rep
PUBLIC  ??_G_Node_rep@std@@UAEPAXI@Z                        ; std::_Node_rep::`scalar deleting destructor'
PUBLIC  ??0?$allocator@_N@std@@QAE@XZ                 ; std::allocator<bool>::allocator<bool>
PUBLIC  ?deallocate@?$allocator@I@std@@QAEXPAII@Z   ; std::allocator<unsigned int>::deallocate
PUBLIC  ?allocate@?$allocator@I@std@@QAEPAII@Z          ; std::allocator<unsigned int>::allocate
PUBLIC  ?max_size@?$allocator@I@std@@QBEIXZ   ; std::allocator<unsigned int>::max_size
PUBLIC  ?max_size@?$allocator_traits@V?$allocator@I@std@@@std@@SAIABV?$allocator@I@2@@Z ; std::allocator_traits<std::allocator<unsigned int> >::max_size
PUBLIC  ?allocate@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEPAII@Z ; std::_Wrap_alloc<std::allocator<unsigned int> >::allocate
PUBLIC  ?deallocate@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAII@Z ; std::_Wrap_alloc<std::allocator<unsigned int> >::deallocate
PUBLIC  ?max_size@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<unsigned int> >::max_size
PUBLIC  ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Orphan_all
PUBLIC  ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Getal
PUBLIC  ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Getal
PUBLIC  ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@I@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Get_data
PUBLIC  ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@I@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Get_data
PUBLIC  ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myfirst
PUBLIC  ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABQAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myfirst
PUBLIC  ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Mylast
PUBLIC  ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABQAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Mylast
PUBLIC  ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myend
PUBLIC  ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABQAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myend
PUBLIC  ??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<unsigned int> >::_Vector_val<std::_Simple_types<unsigned int> >
PUBLIC  ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned int> >,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_first
PUBLIC  ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned int> >,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_first
PUBLIC  ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@I@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned int> >,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_second
PUBLIC  ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@I@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned int> >,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_second
PUBLIC  ??0?$vector@IV?$allocator@_N@std@@@std@@QAE@IABIABV?$allocator@_N@1@@Z ; std::vector<unsigned int,std::allocator<bool> >::vector<unsigned int,std::allocator<bool> >
PUBLIC  ?_Construct_n@?$vector@IV?$allocator@_N@std@@@std@@QAEXIPBI@Z ; std::vector<unsigned int,std::allocator<bool> >::_Construct_n
PUBLIC  ??1?$vector@IV?$allocator@_N@std@@@std@@QAE@XZ      ; std::vector<unsigned int,std::allocator<bool> >::~vector<unsigned int,std::allocator<bool> >
PUBLIC  ?capacity@?$vector@IV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<bool> >::capacity
PUBLIC  ?_Unused_capacity@?$vector@IV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<bool> >::_Unused_capacity
PUBLIC  ?begin@?$vector@IV?$allocator@_N@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ ; std::vector<unsigned int,std::allocator<bool> >::begin
PUBLIC  ?end@?$vector@IV?$allocator@_N@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ ; std::vector<unsigned int,std::allocator<bool> >::end
PUBLIC  ?_Make_iter@?$vector@IV?$allocator@_N@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@@Z ; std::vector<unsigned int,std::allocator<bool> >::_Make_iter
PUBLIC  ?resize@?$vector@IV?$allocator@_N@std@@@std@@QAEXIABI@Z ; std::vector<unsigned int,std::allocator<bool> >::resize
PUBLIC  ?size@?$vector@IV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<bool> >::size
PUBLIC  ?max_size@?$vector@IV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<bool> >::max_size
PUBLIC  ??A?$vector@IV?$allocator@_N@std@@@std@@QAEAAII@Z ; std::vector<unsigned int,std::allocator<bool> >::operator[]
PUBLIC  ?erase@?$vector@IV?$allocator@_N@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@0@Z ; std::vector<unsigned int,std::allocator<bool> >::erase
PUBLIC  ?_Pop_back_n@?$vector@IV?$allocator@_N@std@@@std@@QAEXI@Z ; std::vector<unsigned int,std::allocator<bool> >::_Pop_back_n
PUBLIC  ?clear@?$vector@IV?$allocator@_N@std@@@std@@QAEXXZ ; std::vector<unsigned int,std::allocator<bool> >::clear
PUBLIC  ?_Buy@?$vector@IV?$allocator@_N@std@@@std@@IAE_NI@Z ; std::vector<unsigned int,std::allocator<bool> >::_Buy
PUBLIC  ?_Destroy@?$vector@IV?$allocator@_N@std@@@std@@IAEXPAI0@Z ; std::vector<unsigned int,std::allocator<bool> >::_Destroy
PUBLIC  ?_Grow_to@?$vector@IV?$allocator@_N@std@@@std@@IBEII@Z ; std::vector<unsigned int,std::allocator<bool> >::_Grow_to
PUBLIC  ?_Inside@?$vector@IV?$allocator@_N@std@@@std@@IBE_NPBI@Z ; std::vector<unsigned int,std::allocator<bool> >::_Inside
PUBLIC  ?_Reallocate@?$vector@IV?$allocator@_N@std@@@std@@IAEXI@Z ; std::vector<unsigned int,std::allocator<bool> >::_Reallocate
PUBLIC  ?_Reserve@?$vector@IV?$allocator@_N@std@@@std@@IAEXI@Z ; std::vector<unsigned int,std::allocator<bool> >::_Reserve
PUBLIC  ?_Tidy@?$vector@IV?$allocator@_N@std@@@std@@IAEXXZ ; std::vector<unsigned int,std::allocator<bool> >::_Tidy
PUBLIC  ?_Ufill@?$vector@IV?$allocator@_N@std@@@std@@IAEPAIPAIIPBI@Z ; std::vector<unsigned int,std::allocator<bool> >::_Ufill
PUBLIC  ?_Xlen@?$vector@IV?$allocator@_N@std@@@std@@IBEXXZ ; std::vector<unsigned int,std::allocator<bool> >::_Xlen
PUBLIC  ??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@IAB_NABV?$allocator@_N@1@@Z ; std::_Vb_val<std::allocator<bool> >::_Vb_val<std::allocator<bool> >
PUBLIC  ??1?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@XZ      ; std::_Vb_val<std::allocator<bool> >::~_Vb_val<std::allocator<bool> >
PUBLIC  ?_Alloc_proxy@?$_Vb_val@V?$allocator@_N@std@@@std@@QAEXXZ ; std::_Vb_val<std::allocator<bool> >::_Alloc_proxy
PUBLIC  ?_Free_proxy@?$_Vb_val@V?$allocator@_N@std@@@std@@QAEXXZ ; std::_Vb_val<std::allocator<bool> >::_Free_proxy
PUBLIC  ?_Nw@?$_Vb_val@V?$allocator@_N@std@@@std@@SAII@Z ; std::_Vb_val<std::allocator<bool> >::_Nw
PUBLIC  ??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@IABV?$allocator@_N@1@@Z ; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >
PUBLIC  ??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ     ; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
PUBLIC  ?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::begin
PUBLIC  ?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::end
PUBLIC  ?_Make_iter@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@V?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@@Z ; std::vector<bool,std::allocator<bool> >::_Make_iter
PUBLIC  ?resize@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI_N@Z ; std::vector<bool,std::allocator<bool> >::resize
PUBLIC  ?size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<bool,std::allocator<bool> >::size
PUBLIC  ?max_size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<bool,std::allocator<bool> >::max_size
PUBLIC  ?empty@?$vector@_NV?$allocator@_N@std@@@std@@QBE_NXZ ; std::vector<bool,std::allocator<bool> >::empty
PUBLIC  ??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
PUBLIC  ?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@V?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@0@Z ; std::vector<bool,std::allocator<bool> >::erase
PUBLIC  ?_Insert_n@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@V?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@IAB_N@Z ; std::vector<bool,std::allocator<bool> >::_Insert_n
PUBLIC  ?_Insert_x@?$vector@_NV?$allocator@_N@std@@@std@@QAEIV?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@I@Z ; std::vector<bool,std::allocator<bool> >::_Insert_x
PUBLIC  ?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI@Z ; std::vector<bool,std::allocator<bool> >::_Trim
PUBLIC  ?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@QBEXXZ ; std::vector<bool,std::allocator<bool> >::_Xlen
PUBLIC  ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
PUBLIC  ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
PUBLIC  ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator-
PUBLIC  ??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE_NABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator==
PUBLIC  ?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEXABV12@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Compat
PUBLIC  ?_Calculate_loop_simplicity@std@@YAXPAV_Node_base@1@0PAV_Node_rep@1@@Z ; std::_Calculate_loop_simplicity
PUBLIC  ?regexTest@@YAXXZ                     ; regexTest
PUBLIC  ??0?$basic_regex@DV?$regex_traits@D@std@@@std@@QAE@PBDW4syntax_option_type@regex_constants@1@@Z ; std::basic_regex<char,std::regex_traits<char> >::basic_regex<char,std::regex_traits<char> >
PUBLIC  ??1?$basic_regex@DV?$regex_traits@D@std@@@std@@QAE@XZ ; std::basic_regex<char,std::regex_traits<char> >::~basic_regex<char,std::regex_traits<char> >
PUBLIC  ?_Tidy@?$basic_regex@DV?$regex_traits@D@std@@@std@@AAEXXZ ; std::basic_regex<char,std::regex_traits<char> >::_Tidy
PUBLIC  ?_Reset@?$basic_regex@DV?$regex_traits@D@std@@@std@@AAEXPAV_Root_node@2@@Z ; std::basic_regex<char,std::regex_traits<char> >::_Reset
PUBLIC  ??$_Reset@PBD@?$basic_regex@DV?$regex_traits@D@std@@@std@@AAEXPBD0W4syntax_option_type@regex_constants@1@Uforward_iterator_tag@1@@Z ; std::basic_regex<char,std::regex_traits<char> >::_Reset<char const *>
PUBLIC  ??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ; std::move<std::_Wrap_alloc<std::allocator<char> > &>
PUBLIC  ??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::_Wrap_alloc<std::allocator<char> >,void>
PUBLIC  ??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC  ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC  ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC  ??$addressof@D@std@@YAPADAAD@Z                  ; std::addressof<char>
PUBLIC  ??$?8V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ; std::operator==<std::allocator<char>,std::allocator<char> >
PUBLIC  ??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z       ; std::operator==<char,char>
PUBLIC  ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC  ??$use_facet@V?$collate@D@std@@@std@@YAABV?$collate@D@0@ABVlocale@0@@Z ; std::use_facet<std::collate<char> >
PUBLIC  ?transform@?$collate@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PBD0@Z ; std::collate<char>::transform
PUBLIC  ??0?$collate@D@std@@QAE@ABV_Locinfo@1@I@Z   ; std::collate<char>::collate<char>
PUBLIC  ?_Getcat@?$collate@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::collate<char>::_Getcat
PUBLIC  ??1?$collate@D@std@@MAE@XZ              ; std::collate<char>::~collate<char>
PUBLIC  ?_Init@?$collate@D@std@@IAEXABV_Locinfo@2@@Z        ; std::collate<char>::_Init
PUBLIC  ?do_compare@?$collate@D@std@@MBEHPBD000@Z   ; std::collate<char>::do_compare
PUBLIC  ?do_transform@?$collate@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PBD0@Z ; std::collate<char>::do_transform
PUBLIC  ?do_hash@?$collate@D@std@@MBEJPBD0@Z                ; std::collate<char>::do_hash
PUBLIC  ??_G?$collate@D@std@@MAEPAXI@Z                  ; std::collate<char>::`scalar deleting destructor'
PUBLIC  ??$?9V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ; std::operator!=<std::allocator<char>,std::allocator<char> >
PUBLIC  ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >
PUBLIC  ??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
PUBLIC  ??G?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator-
PUBLIC  ??0?$_Parser@PBDDV?$regex_traits@D@std@@@std@@QAE@ABV?$regex_traits@D@1@PBD1W4syntax_option_type@regex_constants@1@@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_Parser<char const *,char,std::regex_traits<char> >
PUBLIC  ?_Compile@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Root_node@2@XZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Compile
PUBLIC  ?_Mark_count@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@QBEIXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Mark_count
PUBLIC  ?_Error@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_Error
PUBLIC  ?_Is_esc@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@ABE_NXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Is_esc
PUBLIC  ?_Trans@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Trans
PUBLIC  ?_Next@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Next
PUBLIC  ?_Expect@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXW4_Meta_type@2@W4error_type@regex_constants@2@@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_Expect
PUBLIC  ?_Do_digits@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEHHH@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_Do_digits
PUBLIC  ?_DecimalDigits@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_NXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_DecimalDigits
PUBLIC  ?_HexDigits@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXH@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_HexDigits
PUBLIC  ?_OctalDigits@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_NXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_OctalDigits
PUBLIC  ?_Do_ex_class@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXW4_Meta_type@2@@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_Do_ex_class
PUBLIC  ?_CharacterClassEscape@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_N_N@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_CharacterClassEscape
PUBLIC  ?_ClassEscape@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE?AW4_Prs_ret@2@_N@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_ClassEscape
PUBLIC  ?_ClassAtom@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE?AW4_Prs_ret@2@XZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_ClassAtom
PUBLIC  ?_ClassRanges@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_ClassRanges
PUBLIC  ?_CharacterClass@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_CharacterClass
PUBLIC  ?_IdentityEscape@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_NXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_IdentityEscape
PUBLIC  ?_IsIdentityEscape@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@ABE_NXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_IsIdentityEscape
PUBLIC  ?_Do_ffn@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_ND@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_Do_ffn
PUBLIC  ?_Do_ffnx@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_ND@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_Do_ffnx
PUBLIC  ?_CharacterEscape@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_NXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_CharacterEscape
PUBLIC  ?_AtomEscape@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_AtomEscape
PUBLIC  ?_Do_capture_group@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Do_capture_group
PUBLIC  ?_Do_noncapture_group@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Do_noncapture_group
PUBLIC  ?_Do_assert_group@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEX_N@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_Do_assert_group
PUBLIC  ?_Wrapped_disjunction@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_NXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Wrapped_disjunction
PUBLIC  ?_Quantifier@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Quantifier
PUBLIC  ?_Alternative@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_NXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Alternative
PUBLIC  ?_Disjunction@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Disjunction
PUBLIC  ??0?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAE@ABV?$regex_traits@D@1@W4syntax_option_type@regex_constants@1@@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Builder<char const *,char,std::regex_traits<char> >
PUBLIC  ?_Beg_expr@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QBE_NXZ ; std::_Builder<char const *,char,std::regex_traits<char> >::_Beg_expr
PUBLIC  ?_Setlong@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXXZ ; std::_Builder<char const *,char,std::regex_traits<char> >::_Setlong
PUBLIC  ?_Discard_pattern@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXXZ ; std::_Builder<char const *,char,std::regex_traits<char> >::_Discard_pattern
PUBLIC  ?_Getmark@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QBEPAV_Node_base@2@XZ ; std::_Builder<char const *,char,std::regex_traits<char> >::_Getmark
PUBLIC  ?_Add_bol@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXXZ ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_bol
PUBLIC  ?_Add_eol@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXXZ ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_eol
PUBLIC  ?_Add_wbound@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXXZ ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_wbound
PUBLIC  ?_Add_dot@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXXZ ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_dot
PUBLIC  ?_Add_char@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXD@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_char
PUBLIC  ?_Add_class@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXXZ ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_class
PUBLIC  ?_Add_char_to_class@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXD@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_char_to_class
PUBLIC  ?_Add_range@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXDD@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_range
PUBLIC  ?_Add_named_class@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXF_N@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_named_class
PUBLIC  ?_Add_equiv@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXPBD0H@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_equiv
PUBLIC  ?_Add_coll@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXPBD0H@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_coll
PUBLIC  ?_Begin_group@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Node_base@2@XZ ; std::_Builder<char const *,char,std::regex_traits<char> >::_Begin_group
PUBLIC  ?_End_group@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXPAV_Node_base@2@@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_End_group
PUBLIC  ?_Begin_assert_group@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Node_base@2@_N@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Begin_assert_group
PUBLIC  ?_End_assert_group@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXPAV_Node_base@2@@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_End_assert_group
PUBLIC  ?_Begin_capture_group@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Node_base@2@I@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Begin_capture_group
PUBLIC  ?_Add_backreference@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXI@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_backreference
PUBLIC  ?_Begin_if@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Node_base@2@PAV32@@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Begin_if
PUBLIC  ?_Else_if@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXPAV_Node_base@2@0@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Else_if
PUBLIC  ?_Add_rep@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXHH_N@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_rep
PUBLIC  ?_Negate@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXXZ ; std::_Builder<char const *,char,std::regex_traits<char> >::_Negate
PUBLIC  ?_Mark_final@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXXZ ; std::_Builder<char const *,char,std::regex_traits<char> >::_Mark_final
PUBLIC  ?_End_pattern@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Root_node@2@XZ ; std::_Builder<char const *,char,std::regex_traits<char> >::_End_pattern
PUBLIC  ?_Link_node@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEPAV_Node_base@2@PAV32@@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Link_node
PUBLIC  ?_New_node@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEPAV_Node_base@2@W4_Node_type@2@@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_New_node
PUBLIC  ?_Add_str_node@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_str_node
PUBLIC  ?_Beg_expr@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@ABE_NPAV_Node_base@2@@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Beg_expr
PUBLIC  ?_Add_char_to_bitmap@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEXD@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_char_to_bitmap
PUBLIC  ?_Add_char_to_array@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEXD@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_char_to_array
PUBLIC  ?_Add_elts@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEXPAV?$_Node_class@DV?$regex_traits@D@std@@@2@F_N@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_elts
PUBLIC  ?_Char_to_elts@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEXPBD0HPAPAU?$_Sequence@D@2@@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Char_to_elts
PUBLIC  ?_Get_bmax@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@ABEIXZ ; std::_Builder<char const *,char,std::regex_traits<char> >::_Get_bmax
PUBLIC  ?_Get_tmax@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@ABEIXZ ; std::_Builder<char const *,char,std::regex_traits<char> >::_Get_tmax
PUBLIC  ??1?$_Parser@PBDDV?$regex_traits@D@std@@@std@@QAE@XZ ; std::_Parser<char const *,char,std::regex_traits<char> >::~_Parser<char const *,char,std::regex_traits<char> >
PUBLIC  ??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ; std::forward<std::_Wrap_alloc<std::allocator<char> > >
PUBLIC  ??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::_Wrap_alloc<std::allocator<char> > >
PUBLIC  ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC  ??$_Addressof@D@std@@YAPADAADU?$integral_constant@_N$0A@@0@@Z ; std::_Addressof<char>
PUBLIC  ??$forward@AAPAD@std@@YAAAPADAAPAD@Z                ; std::forward<char * &>
PUBLIC  ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC  ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAXPAI0AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<unsigned int> > >
PUBLIC  ??$_Unchecked@PAD@std@@YAPADPAD@Z         ; std::_Unchecked<char *>
PUBLIC  ??$_Iter_cat@PAD@std@@YA?AUrandom_access_iterator_tag@0@ABQAD@Z ; std::_Iter_cat<char *>
PUBLIC  ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z       ; std::allocator<char>::destroy<char *>
PUBLIC  ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC  ??$addressof@I@std@@YAPAIAAI@Z                  ; std::addressof<unsigned int>
PUBLIC  ??$destroy@I@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAI@Z ; std::_Wrap_alloc<std::allocator<unsigned int> >::destroy<unsigned int>
PUBLIC  ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >
PUBLIC  ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+=
PUBLIC  ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator==
PUBLIC  ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator!=
PUBLIC  ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Compat
PUBLIC  ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >
PUBLIC  ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+=
PUBLIC  ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+
PUBLIC  ??$_Move_unchecked@PAIPAI@std@@YAPAIPAI00@Z ; std::_Move_unchecked<unsigned int *,unsigned int *>
PUBLIC  ??$?0ABV?$allocator@_N@std@@@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAE@ABV?$allocator@_N@1@@Z ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > ><std::allocator<bool> const &>
PUBLIC  ??$addressof@$$CBI@std@@YAPBIABI@Z      ; std::addressof<unsigned int const >
PUBLIC  ??$_Uninitialized_fill_n@PAIIU?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAXPAIIPBIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z ; std::_Uninitialized_fill_n<unsigned int *,unsigned int,std::_Wrap_alloc<std::allocator<unsigned int> > >
PUBLIC  ??$_Addressof@I@std@@YAPAIAAIU?$integral_constant@_N$0A@@0@@Z ; std::_Addressof<unsigned int>
PUBLIC  ??$destroy@I@?$allocator_traits@V?$allocator@I@std@@@std@@SAXAAV?$allocator@I@1@PAI@Z ; std::allocator_traits<std::allocator<unsigned int> >::destroy<unsigned int>
PUBLIC  ??$_Ptr_move_cat@II@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAI0@Z ; std::_Ptr_move_cat<unsigned int,unsigned int>
PUBLIC  ??$_Move_unchecked1@PAIPAI@std@@YAPAIPAI00U_Trivially_copyable_ptr_iterator_tag@0@@Z ; std::_Move_unchecked1<unsigned int *,unsigned int *>
PUBLIC  ??$forward@ABV?$allocator@_N@std@@@std@@YAABV?$allocator@_N@0@ABV10@@Z ; std::forward<std::allocator<bool> const &>
PUBLIC  ??$?0ABV?$allocator@_N@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@_N@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned int> >,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned int> >,std::_Vector_val<std::_Simple_types<unsigned int> >,1><std::allocator<bool> const &>
PUBLIC  ??$_Addressof@$$CBI@std@@YAPBIABIU?$integral_constant@_N$0A@@0@@Z ; std::_Addressof<unsigned int const >
PUBLIC  ??$_Fill_memset_is_safe@PAII@std@@YA?AU?$integral_constant@_N$0A@@0@ABQAIABI@Z ; std::_Fill_memset_is_safe<unsigned int *,unsigned int>
PUBLIC  ??$_Uninit_alloc_fill_n1@PAIIV?$allocator@I@std@@U?$integral_constant@_N$0A@@2@@std@@YAXPAIIPBIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninit_alloc_fill_n1<unsigned int *,unsigned int,std::allocator<unsigned int>,std::integral_constant<bool,0> >
PUBLIC  ??$destroy@I@?$allocator@I@std@@QAEXPAI@Z   ; std::allocator<unsigned int>::destroy<unsigned int>
PUBLIC  ??$_Copy_memmove@PAIPAI@std@@YAPAIPAI00@Z   ; std::_Copy_memmove<unsigned int *,unsigned int *>
PUBLIC  ??$?0ABV?$allocator@_N@std@@@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAE@ABV?$allocator@_N@1@@Z ; std::_Wrap_alloc<std::allocator<unsigned int> >::_Wrap_alloc<std::allocator<unsigned int> ><std::allocator<bool> const &>
PUBLIC  ??$construct@IABI@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAIABI@Z ; std::_Wrap_alloc<std::allocator<unsigned int> >::construct<unsigned int,unsigned int const &>
PUBLIC  ??0?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIIPBU_Container_base0@1@@Z ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >
PUBLIC  ?_Advance@?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXI@Z ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Advance
PUBLIC  ??0?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@@Z ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >
PUBLIC  ??4?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator=
PUBLIC  ??4?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@_N@Z ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator=
PUBLIC  ??B?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE_NXZ ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator bool
PUBLIC  ?_Getptr@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEPBIXZ ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Getptr
PUBLIC  ?_Mask@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@IBEIXZ ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Mask
PUBLIC  ??0?$_Node_str@D@std@@QAE@W4_Node_flags@1@@Z        ; std::_Node_str<char>::_Node_str<char>
PUBLIC  ??0?$_Buf@D@std@@QAE@XZ                   ; std::_Buf<char>::_Buf<char>
PUBLIC  ??1?$_Buf@D@std@@QAE@XZ                   ; std::_Buf<char>::~_Buf<char>
PUBLIC  ?_Size@?$_Buf@D@std@@QBEIXZ       ; std::_Buf<char>::_Size
PUBLIC  ?_Insert@?$_Buf@D@std@@QAEXD@Z                  ; std::_Buf<char>::_Insert
PUBLIC  ?_Del@?$_Buf@D@std@@QAEDXZ              ; std::_Buf<char>::_Del
PUBLIC  ?_Expand@?$_Buf@D@std@@AAEXI@Z                  ; std::_Buf<char>::_Expand
PUBLIC  ??_G?$_Buf@D@std@@QAEPAXI@Z       ; std::_Buf<char>::`scalar deleting destructor'
PUBLIC  ??1?$_Node_str@D@std@@UAE@XZ                        ; std::_Node_str<char>::~_Node_str<char>
PUBLIC  ??_G?$_Node_str@D@std@@UAEPAXI@Z            ; std::_Node_str<char>::`scalar deleting destructor'
PUBLIC  ??$?0_N@?$allocator@I@std@@QAE@ABV?$allocator@_N@1@@Z ; std::allocator<unsigned int>::allocator<unsigned int><bool>
PUBLIC  ??$forward@ABI@std@@YAABIABI@Z                  ; std::forward<unsigned int const &>
PUBLIC  ??$construct@IABI@?$allocator_traits@V?$allocator@I@std@@@std@@SAXAAV?$allocator@I@1@PAIABI@Z ; std::allocator_traits<std::allocator<unsigned int> >::construct<unsigned int,unsigned int const &>
PUBLIC  ??0?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIPBU_Container_base0@1@@Z ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >
PUBLIC  ??E?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator++
PUBLIC  ??F?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator--
PUBLIC  ??Y?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator+=
PUBLIC  ??G?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEHABV01@@Z ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator-
PUBLIC  ??8?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator==
PUBLIC  ??9?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator!=
PUBLIC  ?_Compat@?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Compat
PUBLIC  ?_Dec@?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXXZ ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Dec
PUBLIC  ?_Inc@?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXXZ ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Inc
PUBLIC  ??0?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PAIPAU_Container_base0@1@@Z ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >
PUBLIC  ??D?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@XZ ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator*
PUBLIC  ??E?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator++
PUBLIC  ??F?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator--
PUBLIC  ??Y?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator+=
PUBLIC  ??H?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator+
PUBLIC  ??Z?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator-=
PUBLIC  ??G?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator-
PUBLIC  ??G?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEHABV?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@@Z ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator-
PUBLIC  ??$lookup_classname@PBD@?$_Regex_traits@D@std@@QBEFPBD0_N@Z ; std::_Regex_traits<char>::lookup_classname<char const *>
PUBLIC  ??0?$_Node_class@DV?$regex_traits@D@std@@@std@@QAE@W4_Node_type@1@W4_Node_flags@1@@Z ; std::_Node_class<char,std::regex_traits<char> >::_Node_class<char,std::regex_traits<char> >
PUBLIC  ??1?$_Node_class@DV?$regex_traits@D@std@@@std@@UAE@XZ ; std::_Node_class<char,std::regex_traits<char> >::~_Node_class<char,std::regex_traits<char> >
PUBLIC  ?_Tidy@?$_Node_class@DV?$regex_traits@D@std@@@std@@QAEXPAU?$_Sequence@D@2@@Z ; std::_Node_class<char,std::regex_traits<char> >::_Tidy
PUBLIC  ??_G?$_Node_class@DV?$regex_traits@D@std@@@std@@UAEPAXI@Z ; std::_Node_class<char,std::regex_traits<char> >::`scalar deleting destructor'
PUBLIC  ??$construct@IABI@?$allocator@I@std@@QAEXPAIABI@Z ; std::allocator<unsigned int>::construct<unsigned int,unsigned int const &>
PUBLIC  ??0?$_Sequence@D@std@@QAE@I@Z                 ; std::_Sequence<char>::_Sequence<char>
PUBLIC  ??1?$_Sequence@D@std@@QAE@XZ                        ; std::_Sequence<char>::~_Sequence<char>
PUBLIC  ??_G?$_Sequence@D@std@@QAEPAXI@Z            ; std::_Sequence<char>::`scalar deleting destructor'
PUBLIC  ??$fill@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@0AB_N@Z ; std::fill<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,bool>
PUBLIC  ??$copy@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00@Z ; std::copy<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
PUBLIC  ??$copy_backward@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00@Z ; std::copy_backward<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
PUBLIC  ??$_Umove@PAI@?$vector@IV?$allocator@_N@std@@@std@@IAEPAIPAI00@Z ; std::vector<unsigned int,std::allocator<bool> >::_Umove<unsigned int *>
PUBLIC  ??$_Mark@I@_Bitmap@std@@QAEXI@Z           ; std::_Bitmap::_Mark<unsigned int>
PUBLIC  ??$_Mark@E@_Bitmap@std@@QAEXE@Z           ; std::_Bitmap::_Mark<unsigned char>
PUBLIC  ??0?$_Cmp_icase@V?$_Regex_traits@D@std@@@std@@QAE@ABV?$_Regex_traits@D@1@@Z ; std::_Cmp_icase<std::_Regex_traits<char> >::_Cmp_icase<std::_Regex_traits<char> >
PUBLIC  ??R?$_Cmp_icase@V?$_Regex_traits@D@std@@@std@@QAE_NDD@Z ; std::_Cmp_icase<std::_Regex_traits<char> >::operator()
PUBLIC  ??$equal@PBDPBDU?$_Cmp_icase@V?$_Regex_traits@D@std@@@std@@@std@@YA_NPBD000U?$_Cmp_icase@V?$_Regex_traits@D@std@@@0@@Z ; std::equal<char const *,char const *,std::_Cmp_icase<std::_Regex_traits<char> > >
PUBLIC  ??$_Unchecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@@Z ; std::_Unchecked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
PUBLIC  ??$_Fill_unchecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@0AB_N@Z ; std::_Fill_unchecked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,bool>
PUBLIC  ??$_Is_checked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@@std@@YA?AU?$integral_constant@_N$00@0@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@@Z ; std::_Is_checked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
PUBLIC  ??$_Copy_no_deprecate@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00@Z ; std::_Copy_no_deprecate<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
PUBLIC  ??$_Iter_cat@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@@Z ; std::_Iter_cat<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
PUBLIC  ??$_Copy_backward1@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@1@Z ; std::_Copy_backward1<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
PUBLIC  ??$_Uninitialized_move@PAIPAIU?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAPAIPAI00AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z ; std::_Uninitialized_move<unsigned int *,unsigned int *,std::_Wrap_alloc<std::allocator<unsigned int> > >
PUBLIC  ??$_Unchecked@PBD@std@@YAPBDPBD@Z         ; std::_Unchecked<char const *>
PUBLIC  ??$_Iter_cat@PBD@std@@YA?AUrandom_access_iterator_tag@0@ABQBD@Z ; std::_Iter_cat<char const *>
PUBLIC  ??$_Equal@PBDPBDU?$_Cmp_icase@V?$_Regex_traits@D@std@@@std@@@std@@YA_NPBD000U?$_Cmp_icase@V?$_Regex_traits@D@std@@@0@Urandom_access_iterator_tag@0@2@Z ; std::_Equal<char const *,char const *,std::_Cmp_icase<std::_Regex_traits<char> > >
PUBLIC  ??$_Fill_memset_is_safe@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@_N@std@@YA?AU?$integral_constant@_N$0A@@0@ABV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@AB_N@Z ; std::_Fill_memset_is_safe<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,bool>
PUBLIC  ??$_Fill_unchecked1@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@0AB_NU?$integral_constant@_N$0A@@0@@Z ; std::_Fill_unchecked1<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,bool>
PUBLIC  ??$_Copy_no_deprecate1@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@1@Z ; std::_Copy_no_deprecate1<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
PUBLIC  ??$_Copy_backward_unchecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00@Z ; std::_Copy_backward_unchecked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
PUBLIC  ??$_Rechecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YAAAV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@AAV10@V10@@Z ; std::_Rechecked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
PUBLIC  ??$_Unchecked@PAI@std@@YAPAIPAI@Z         ; std::_Unchecked<unsigned int *>
PUBLIC  ??$_Uninitialized_move_al_unchecked@PAIPAIU?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAPAIPAI00AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z ; std::_Uninitialized_move_al_unchecked<unsigned int *,unsigned int *,std::_Wrap_alloc<std::allocator<unsigned int> > >
PUBLIC  ??$_Rechecked@PAIPAI@std@@YAAAPAIAAPAIPAI@Z ; std::_Rechecked<unsigned int *,unsigned int *>
PUBLIC  ??$transform_primary@PBD@?$_Regex_traits@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PBD0@Z ; std::_Regex_traits<char>::transform_primary<char const *>
PUBLIC  ??$transform_primary@PAD@?$_Regex_traits@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAD0@Z ; std::_Regex_traits<char>::transform_primary<char *>
PUBLIC  ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
PUBLIC  ??$_Equal@PBDPBDU?$_Cmp_icase@V?$_Regex_traits@D@std@@@std@@@std@@YA_NPBD00U?$_Cmp_icase@V?$_Regex_traits@D@std@@@0@@Z ; std::_Equal<char const *,char const *,std::_Cmp_icase<std::_Regex_traits<char> > >
PUBLIC  ??$_Copy_unchecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00@Z ; std::_Copy_unchecked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
PUBLIC  ??$_Ptr_copy_cat@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@0@Z ; std::_Ptr_copy_cat<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
PUBLIC  ??$_Copy_backward_unchecked1@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z ; std::_Copy_backward_unchecked1<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
PUBLIC  ??$_Uninitialized_move_al_unchecked1@II@std@@YAPAIPAI00AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U_Really_trivial_ptr_iterator_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<unsigned int,unsigned int>
PUBLIC  ??$_Insert@PBD@?$_Buf@D@std@@QAEXPBD0@Z       ; std::_Buf<char>::_Insert<char const *>
PUBLIC  ??0?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >
PUBLIC  ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Orphan_all
PUBLIC  ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Getal
PUBLIC  ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Getal
PUBLIC  ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Get_data
PUBLIC  ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Get_data
PUBLIC  ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPADXZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Myfirst
PUBLIC  ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABQADXZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Myfirst
PUBLIC  ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPADXZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Mylast
PUBLIC  ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABQADXZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Mylast
PUBLIC  ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPADXZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Myend
PUBLIC  ??0?$_Vector_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<char> >::_Vector_val<std::_Simple_types<char> >
PUBLIC  ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_Vector_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC  ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_Vector_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC  ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_Vector_val<std::_Simple_types<char> >,1>::_Get_second
PUBLIC  ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_Vector_val<std::_Simple_types<char> >,1>::_Get_second
PUBLIC  ??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ       ; std::vector<char,std::allocator<char> >::~vector<char,std::allocator<char> >
PUBLIC  ?begin@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::vector<char,std::allocator<char> >::begin
PUBLIC  ?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
PUBLIC  ?max_size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::max_size
PUBLIC  ?_Buy@?$vector@DV?$allocator@D@std@@@std@@IAE_NI@Z ; std::vector<char,std::allocator<char> >::_Buy
PUBLIC  ?_Destroy@?$vector@DV?$allocator@D@std@@@std@@IAEXPAD0@Z ; std::vector<char,std::allocator<char> >::_Destroy
PUBLIC  ?_Tidy@?$vector@DV?$allocator@D@std@@@std@@IAEXXZ ; std::vector<char,std::allocator<char> >::_Tidy
PUBLIC  ?_Xlen@?$vector@DV?$allocator@D@std@@@std@@IBEXXZ ; std::vector<char,std::allocator<char> >::_Xlen
PUBLIC  ??$?0PBDX@?$vector@DV?$allocator@D@std@@@std@@QAE@PBD0@Z ; std::vector<char,std::allocator<char> >::vector<char,std::allocator<char> ><char const *,void>
PUBLIC  ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<char> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<char> > >
PUBLIC  ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<char> > >::operator*
PUBLIC  ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<char> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<char> > >
PUBLIC  ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<char> > >::operator*
PUBLIC  ??$?0PADX@?$vector@DV?$allocator@D@std@@@std@@QAE@PAD0@Z ; std::vector<char,std::allocator<char> >::vector<char,std::allocator<char> ><char *,void>
PUBLIC  ??$_Copy_unchecked1@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z ; std::_Copy_unchecked1<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
PUBLIC  ??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > >
PUBLIC  ??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ; std::_Pocma<std::_Wrap_alloc<std::allocator<char> > >
PUBLIC  ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXPAD0AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<char> > >
PUBLIC  ??$_Construct@PBD@?$vector@DV?$allocator@D@std@@@std@@QAEXPBD0@Z ; std::vector<char,std::allocator<char> >::_Construct<char const *>
PUBLIC  ??$_Construct@PAD@?$vector@DV?$allocator@D@std@@@std@@QAEXPAD0@Z ; std::vector<char,std::allocator<char> >::_Construct<char *>
PUBLIC  ??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U?$integral_constant@_N$00@0@@Z ; std::_Pocma<std::_Wrap_alloc<std::allocator<char> > >
PUBLIC  ??$destroy@D@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char>
PUBLIC  ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_Vector_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_Vector_val<std::_Simple_types<char> >,1><>
PUBLIC  ??$_Construct@PBD@?$vector@DV?$allocator@D@std@@@std@@QAEXPBD0Uforward_iterator_tag@1@@Z ; std::vector<char,std::allocator<char> >::_Construct<char const *>
PUBLIC  ??$_Construct@PAD@?$vector@DV?$allocator@D@std@@@std@@QAEXPAD0Uforward_iterator_tag@1@@Z ; std::vector<char,std::allocator<char> >::_Construct<char *>
PUBLIC  ??$destroy@D@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char>
PUBLIC  ??$distance@PBD@std@@YAHPBD0@Z                  ; std::distance<char const *>
PUBLIC  ??$_Ucopy@PBD@?$vector@DV?$allocator@D@std@@@std@@IAEPADPBD0PAD@Z ; std::vector<char,std::allocator<char> >::_Ucopy<char const *>
PUBLIC  ??$distance@PAD@std@@YAHPAD0@Z                  ; std::distance<char *>
PUBLIC  ??$_Ucopy@PAD@?$vector@DV?$allocator@D@std@@@std@@IAEPADPAD00@Z ; std::vector<char,std::allocator<char> >::_Ucopy<char *>
PUBLIC  ??$destroy@D@?$allocator@D@std@@QAEXPAD@Z   ; std::allocator<char>::destroy<char>
PUBLIC  ??$_Distance2@PBDH@std@@YAXPBD0AAHUrandom_access_iterator_tag@0@@Z ; std::_Distance2<char const *,int>
PUBLIC  ??$_Uninitialized_copy@PBDPADU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAPADPBD0PADAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z ; std::_Uninitialized_copy<char const *,char *,std::_Wrap_alloc<std::allocator<char> > >
PUBLIC  ??$_Distance2@PADH@std@@YAXPAD0AAHUrandom_access_iterator_tag@0@@Z ; std::_Distance2<char *,int>
PUBLIC  ??$_Uninitialized_copy@PADPADU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAPADPAD00AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z ; std::_Uninitialized_copy<char *,char *,std::_Wrap_alloc<std::allocator<char> > >
PUBLIC  ??$_Uninitialized_copy_al_unchecked@PBDPADU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAPADPBD0PADAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z ; std::_Uninitialized_copy_al_unchecked<char const *,char *,std::_Wrap_alloc<std::allocator<char> > >
PUBLIC  ??$_Rechecked@PADPAD@std@@YAAAPADAAPADPAD@Z ; std::_Rechecked<char *,char *>
PUBLIC  ??$_Uninitialized_copy_al_unchecked@PADPADU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAPADPAD00AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z ; std::_Uninitialized_copy_al_unchecked<char *,char *,std::_Wrap_alloc<std::allocator<char> > >
PUBLIC  ??$_Ptr_copy_cat@$$CBDD@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQBDABQAD@Z ; std::_Ptr_copy_cat<char const ,char>
PUBLIC  ??$_Uninitialized_copy_al_unchecked1@$$CBDD@std@@YAPADPBD0PADAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@U_Really_trivial_ptr_iterator_tag@0@@Z ; std::_Uninitialized_copy_al_unchecked1<char const ,char>
PUBLIC  ??$_Ptr_copy_cat@DD@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAD0@Z ; std::_Ptr_copy_cat<char,char>
PUBLIC  ??$_Uninitialized_copy_al_unchecked1@DD@std@@YAPADPAD00AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@U_Really_trivial_ptr_iterator_tag@0@@Z ; std::_Uninitialized_copy_al_unchecked1<char,char>
PUBLIC  ??$_Copy_memmove@PBDPAD@std@@YAPADPBD0PAD@Z ; std::_Copy_memmove<char const *,char *>
PUBLIC  ??$_Copy_memmove@PADPAD@std@@YAPADPAD00@Z   ; std::_Copy_memmove<char *,char *>
PUBLIC  ??_7exception@std@@6B@                          ; std::exception::`vftable'
PUBLIC  ??_C@_0BC@EOODALEL@Unknown?5exception?$AA@  ; `string'
PUBLIC  ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
PUBLIC  ??_7runtime_error@std@@6B@              ; std::runtime_error::`vftable'
PUBLIC  ??_7bad_cast@std@@6B@                         ; std::bad_cast::`vftable'
PUBLIC  ??_C@_08EPJLHIJG@bad?5cast?$AA@           ; `string'
PUBLIC  __TI2?AVruntime_error@std@@
PUBLIC  __CTA2?AVruntime_error@std@@
PUBLIC  ??_R0?AVruntime_error@std@@@8                 ; std::runtime_error `RTTI Type Descriptor'
PUBLIC  __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
PUBLIC  ??_R0?AVexception@std@@@8             ; std::exception `RTTI Type Descriptor'
PUBLIC  __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC  ??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@   ; `string'
PUBLIC  ??_7_Facet_base@std@@6B@                    ; std::_Facet_base::`vftable'
PUBLIC  ??_7facet@locale@std@@6B@             ; std::locale::facet::`vftable'
PUBLIC  ??_C@_00CNPNBAHC@?$AA@                          ; `string'
PUBLIC  ??_7ctype_base@std@@6B@                   ; std::ctype_base::`vftable'
PUBLIC  ??_7?$ctype@D@std@@6B@                          ; std::ctype<char>::`vftable'
PUBLIC  ??_7_Node_base@std@@6B@                   ; std::_Node_base::`vftable'
PUBLIC  ??_7_Root_node@std@@6B@                   ; std::_Root_node::`vftable'
PUBLIC  ??_7_Node_end_group@std@@6B@                        ; std::_Node_end_group::`vftable'
PUBLIC  ??_7_Node_assert@std@@6B@             ; std::_Node_assert::`vftable'
PUBLIC  ??_7_Node_capture@std@@6B@              ; std::_Node_capture::`vftable'
PUBLIC  ??_7_Node_back@std@@6B@                   ; std::_Node_back::`vftable'
PUBLIC  ??_7_Node_endif@std@@6B@                    ; std::_Node_endif::`vftable'
PUBLIC  ??_7_Node_if@std@@6B@                         ; std::_Node_if::`vftable'
PUBLIC  ??_7_Node_end_rep@std@@6B@              ; std::_Node_end_rep::`vftable'
PUBLIC  ??_7_Node_rep@std@@6B@                          ; std::_Node_rep::`vftable'
PUBLIC  ?id@?$collate@D@std@@2V0locale@2@A      ; std::collate<char>::id
PUBLIC  ??_7?$collate@D@std@@6B@                    ; std::collate<char>::`vftable'
PUBLIC  ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@   ; `string'
PUBLIC  ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC  ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
PUBLIC  __TI2?AVbad_cast@std@@
PUBLIC  __CTA2?AVbad_cast@std@@
PUBLIC  ??_R0?AVbad_cast@std@@@8                    ; std::bad_cast `RTTI Type Descriptor'
PUBLIC  __CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
PUBLIC  ?_Psave@?$_Facetptr@V?$collate@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::collate<char> >::_Psave
PUBLIC  ??_C@_0BG@EOMJEIFA@vector?$DMbool?$DO?5too?5long?$AA@ ; `string'
PUBLIC  ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC  ??_7?$_Node_str@D@std@@6B@              ; std::_Node_str<char>::`vftable'
PUBLIC  ??_7?$_Node_class@DV?$regex_traits@D@std@@@std@@6B@ ; std::_Node_class<char,std::regex_traits<char> >::`vftable'
PUBLIC  ??_C@_05IIMHCHIO@alnum?$AA@       ; `string'
PUBLIC  ??_C@_1M@KLMEPMCM@?$AAa?$AAl?$AAn?$AAu?$AAm?$AA?$AA@ ; `string'
PUBLIC  ??_C@_05IAEKHIAN@alpha?$AA@       ; `string'
PUBLIC  ??_C@_1M@DHGLHBMI@?$AAa?$AAl?$AAp?$AAh?$AAa?$AA?$AA@ ; `string'
PUBLIC  ??_C@_05BABJKOGB@blank?$AA@       ; `string'
PUBLIC  ??_C@_1M@EJAAJBPE@?$AAb?$AAl?$AAa?$AAn?$AAk?$AA?$AA@ ; `string'
PUBLIC  ??_C@_05JMDPEFNK@cntrl?$AA@       ; `string'
PUBLIC  ??_C@_1M@LMIMILA@?$AAc?$AAn?$AAt?$AAr?$AAl?$AA?$AA@ ; `string'
PUBLIC  ??_C@_01LPLHEDKD@d?$AA@                   ; `string'
PUBLIC  ??_C@_13GKPPEALH@?$AAd?$AA?$AA@           ; `string'
PUBLIC  ??_C@_05ODNOIFML@digit?$AA@       ; `string'
PUBLIC  ??_C@_1M@JDAEIBKG@?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?$AA@ ; `string'
PUBLIC  ??_C@_05KCJBMLII@graph?$AA@       ; `string'
PUBLIC  ??_C@_1M@MDKNJLLK@?$AAg?$AAr?$AAa?$AAp?$AAh?$AA?$AA@ ; `string'
PUBLIC  ??_C@_05IPJEPLHL@lower?$AA@       ; `string'
PUBLIC  ??_C@_1M@LGAECJJD@?$AAl?$AAo?$AAw?$AAe?$AAr?$AA?$AA@ ; `string'
PUBLIC  ??_C@_05IJDJACGD@print?$AA@       ; `string'
PUBLIC  ??_C@_1M@ELNLAPLA@?$AAp?$AAr?$AAi?$AAn?$AAt?$AA?$AA@ ; `string'
PUBLIC  ??_C@_05KOBGHFJJ@punct?$AA@       ; `string'
PUBLIC  ??_C@_1M@BPFMAOAO@?$AAp?$AAu?$AAn?$AAc?$AAt?$AA?$AA@ ; `string'
PUBLIC  ??_C@_05OLNILLAB@space?$AA@       ; `string'
PUBLIC  ??_C@_1M@LPGODFOM@?$AAs?$AAp?$AAa?$AAc?$AAe?$AA?$AA@ ; `string'
PUBLIC  ??_C@_01LKDEMHDF@s?$AA@                   ; `string'
PUBLIC  ??_C@_13KHDBCPJB@?$AAs?$AA?$AA@           ; `string'
PUBLIC  ??_C@_05NECKJAMC@upper?$AA@       ; `string'
PUBLIC  ??_C@_1M@PLNFCNIC@?$AAu?$AAp?$AAp?$AAe?$AAr?$AA?$AA@ ; `string'
PUBLIC  ??_C@_01NOFIACDB@w?$AA@                   ; `string'
PUBLIC  ??_C@_13CIFDLIMG@?$AAw?$AA?$AA@           ; `string'
PUBLIC  ??_C@_06BAPHGFFK@xdigit?$AA@                        ; `string'
PUBLIC  ??_C@_1O@OAFMJDHN@?$AAx?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?$AA@ ; `string'
PUBLIC  ??_R4exception@std@@6B@                   ; std::exception::`RTTI Complete Object Locator'
PUBLIC  ??_R3exception@std@@8                         ; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC  ??_R2exception@std@@8                         ; std::exception::`RTTI Base Class Array'
PUBLIC  ??_R1A@?0A@EA@exception@std@@8                  ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC  ??_R4runtime_error@std@@6B@       ; std::runtime_error::`RTTI Complete Object Locator'
PUBLIC  ??_R3runtime_error@std@@8             ; std::runtime_error::`RTTI Class Hierarchy Descriptor'
PUBLIC  ??_R2runtime_error@std@@8             ; std::runtime_error::`RTTI Base Class Array'
PUBLIC  ??_R1A@?0A@EA@runtime_error@std@@8      ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC  ??_R4bad_cast@std@@6B@                          ; std::bad_cast::`RTTI Complete Object Locator'
PUBLIC  ??_R3bad_cast@std@@8                                ; std::bad_cast::`RTTI Class Hierarchy Descriptor'
PUBLIC  ??_R2bad_cast@std@@8                                ; std::bad_cast::`RTTI Base Class Array'
PUBLIC  ??_R1A@?0A@EA@bad_cast@std@@8                 ; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC  ??_R4_Facet_base@std@@6B@             ; std::_Facet_base::`RTTI Complete Object Locator'
PUBLIC  ??_R0?AV_Facet_base@std@@@8       ; std::_Facet_base `RTTI Type Descriptor'
PUBLIC  ??_R3_Facet_base@std@@8                   ; std::_Facet_base::`RTTI Class Hierarchy Descriptor'
PUBLIC  ??_R2_Facet_base@std@@8                   ; std::_Facet_base::`RTTI Base Class Array'
PUBLIC  ??_R1A@?0A@EA@_Facet_base@std@@8            ; std::_Facet_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC  ??_R1A@?0A@EA@facet@locale@std@@8         ; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC  ??_R0?AVfacet@locale@std@@@8                        ; std::locale::facet `RTTI Type Descriptor'
PUBLIC  ??_R3facet@locale@std@@8                    ; std::locale::facet::`RTTI Class Hierarchy Descriptor'
PUBLIC  ??_R2facet@locale@std@@8                    ; std::locale::facet::`RTTI Base Class Array'
PUBLIC  ??_R13?0A@EA@_Crt_new_delete@std@@8   ; std::_Crt_new_delete::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC  ??_R0?AU_Crt_new_delete@std@@@8           ; std::_Crt_new_delete `RTTI Type Descriptor'
PUBLIC  ??_R3_Crt_new_delete@std@@8       ; std::_Crt_new_delete::`RTTI Class Hierarchy Descriptor'
PUBLIC  ??_R2_Crt_new_delete@std@@8       ; std::_Crt_new_delete::`RTTI Base Class Array'
PUBLIC  ??_R1A@?0A@EA@_Crt_new_delete@std@@8                ; std::_Crt_new_delete::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC  ??_R4facet@locale@std@@6B@              ; std::locale::facet::`RTTI Complete Object Locator'
PUBLIC  ??_R4ctype_base@std@@6B@                    ; std::ctype_base::`RTTI Complete Object Locator'
PUBLIC  ??_R0?AUctype_base@std@@@8              ; std::ctype_base `RTTI Type Descriptor'
PUBLIC  ??_R3ctype_base@std@@8                          ; std::ctype_base::`RTTI Class Hierarchy Descriptor'
PUBLIC  ??_R2ctype_base@std@@8                          ; std::ctype_base::`RTTI Base Class Array'
PUBLIC  ??_R1A@?0A@EA@ctype_base@std@@8           ; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC  ??_R4?$ctype@D@std@@6B@                   ; std::ctype<char>::`RTTI Complete Object Locator'
PUBLIC  ??_R0?AV?$ctype@D@std@@@8             ; std::ctype<char> `RTTI Type Descriptor'
PUBLIC  ??_R3?$ctype@D@std@@8                         ; std::ctype<char>::`RTTI Class Hierarchy Descriptor'
PUBLIC  ??_R2?$ctype@D@std@@8                         ; std::ctype<char>::`RTTI Base Class Array'
PUBLIC  ??_R1A@?0A@EA@?$ctype@D@std@@8                  ; std::ctype<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC  ??_R4?$collate@D@std@@6B@             ; std::collate<char>::`RTTI Complete Object Locator'
PUBLIC  ??_R0?AV?$collate@D@std@@@8       ; std::collate<char> `RTTI Type Descriptor'
PUBLIC  ??_R3?$collate@D@std@@8                   ; std::collate<char>::`RTTI Class Hierarchy Descriptor'
PUBLIC  ??_R2?$collate@D@std@@8                   ; std::collate<char>::`RTTI Base Class Array'
PUBLIC  ??_R1A@?0A@EA@?$collate@D@std@@8            ; std::collate<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC  ??_R4_Node_base@std@@6B@                    ; std::_Node_base::`RTTI Complete Object Locator'
PUBLIC  ??_R0?AV_Node_base@std@@@8              ; std::_Node_base `RTTI Type Descriptor'
PUBLIC  ??_R3_Node_base@std@@8                          ; std::_Node_base::`RTTI Class Hierarchy Descriptor'
PUBLIC  ??_R2_Node_base@std@@8                          ; std::_Node_base::`RTTI Base Class Array'
PUBLIC  ??_R1A@?0A@EA@_Node_base@std@@8           ; std::_Node_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC  ??_R4_Root_node@std@@6B@                    ; std::_Root_node::`RTTI Complete Object Locator'
PUBLIC  ??_R0?AV_Root_node@std@@@8              ; std::_Root_node `RTTI Type Descriptor'
PUBLIC  ??_R3_Root_node@std@@8                          ; std::_Root_node::`RTTI Class Hierarchy Descriptor'
PUBLIC  ??_R2_Root_node@std@@8                          ; std::_Root_node::`RTTI Base Class Array'
PUBLIC  ??_R1A@?0A@EA@_Root_node@std@@8           ; std::_Root_node::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC  ??_R4_Node_end_group@std@@6B@                 ; std::_Node_end_group::`RTTI Complete Object Locator'
PUBLIC  ??_R0?AV_Node_end_group@std@@@8           ; std::_Node_end_group `RTTI Type Descriptor'
PUBLIC  ??_R3_Node_end_group@std@@8       ; std::_Node_end_group::`RTTI Class Hierarchy Descriptor'
PUBLIC  ??_R2_Node_end_group@std@@8       ; std::_Node_end_group::`RTTI Base Class Array'
PUBLIC  ??_R1A@?0A@EA@_Node_end_group@std@@8                ; std::_Node_end_group::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC  ??_R4_Node_assert@std@@6B@              ; std::_Node_assert::`RTTI Complete Object Locator'
PUBLIC  ??_R0?AV_Node_assert@std@@@8                        ; std::_Node_assert `RTTI Type Descriptor'
PUBLIC  ??_R3_Node_assert@std@@8                    ; std::_Node_assert::`RTTI Class Hierarchy Descriptor'
PUBLIC  ??_R2_Node_assert@std@@8                    ; std::_Node_assert::`RTTI Base Class Array'
PUBLIC  ??_R1A@?0A@EA@_Node_assert@std@@8         ; std::_Node_assert::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC  ??_R4_Node_capture@std@@6B@       ; std::_Node_capture::`RTTI Complete Object Locator'
PUBLIC  ??_R0?AV_Node_capture@std@@@8                 ; std::_Node_capture `RTTI Type Descriptor'
PUBLIC  ??_R3_Node_capture@std@@8             ; std::_Node_capture::`RTTI Class Hierarchy Descriptor'
PUBLIC  ??_R2_Node_capture@std@@8             ; std::_Node_capture::`RTTI Base Class Array'
PUBLIC  ??_R1A@?0A@EA@_Node_capture@std@@8      ; std::_Node_capture::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC  ??_R4_Node_back@std@@6B@                    ; std::_Node_back::`RTTI Complete Object Locator'
PUBLIC  ??_R0?AV_Node_back@std@@@8              ; std::_Node_back `RTTI Type Descriptor'
PUBLIC  ??_R3_Node_back@std@@8                          ; std::_Node_back::`RTTI Class Hierarchy Descriptor'
PUBLIC  ??_R2_Node_back@std@@8                          ; std::_Node_back::`RTTI Base Class Array'
PUBLIC  ??_R1A@?0A@EA@_Node_back@std@@8           ; std::_Node_back::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC  ??_R4_Node_endif@std@@6B@             ; std::_Node_endif::`RTTI Complete Object Locator'
PUBLIC  ??_R0?AV_Node_endif@std@@@8       ; std::_Node_endif `RTTI Type Descriptor'
PUBLIC  ??_R3_Node_endif@std@@8                   ; std::_Node_endif::`RTTI Class Hierarchy Descriptor'
PUBLIC  ??_R2_Node_endif@std@@8                   ; std::_Node_endif::`RTTI Base Class Array'
PUBLIC  ??_R1A@?0A@EA@_Node_endif@std@@8            ; std::_Node_endif::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC  ??_R4_Node_if@std@@6B@                          ; std::_Node_if::`RTTI Complete Object Locator'
PUBLIC  ??_R0?AV_Node_if@std@@@8                    ; std::_Node_if `RTTI Type Descriptor'
PUBLIC  ??_R3_Node_if@std@@8                                ; std::_Node_if::`RTTI Class Hierarchy Descriptor'
PUBLIC  ??_R2_Node_if@std@@8                                ; std::_Node_if::`RTTI Base Class Array'
PUBLIC  ??_R1A@?0A@EA@_Node_if@std@@8                 ; std::_Node_if::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC  ??_R4_Node_rep@std@@6B@                   ; std::_Node_rep::`RTTI Complete Object Locator'
PUBLIC  ??_R0?AV_Node_rep@std@@@8             ; std::_Node_rep `RTTI Type Descriptor'
PUBLIC  ??_R3_Node_rep@std@@8                         ; std::_Node_rep::`RTTI Class Hierarchy Descriptor'
PUBLIC  ??_R2_Node_rep@std@@8                         ; std::_Node_rep::`RTTI Base Class Array'
PUBLIC  ??_R1A@?0A@EA@_Node_rep@std@@8                  ; std::_Node_rep::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC  ??_R4_Node_end_rep@std@@6B@       ; std::_Node_end_rep::`RTTI Complete Object Locator'
PUBLIC  ??_R0?AV_Node_end_rep@std@@@8                 ; std::_Node_end_rep `RTTI Type Descriptor'
PUBLIC  ??_R3_Node_end_rep@std@@8             ; std::_Node_end_rep::`RTTI Class Hierarchy Descriptor'
PUBLIC  ??_R2_Node_end_rep@std@@8             ; std::_Node_end_rep::`RTTI Base Class Array'
PUBLIC  ??_R1A@?0A@EA@_Node_end_rep@std@@8      ; std::_Node_end_rep::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC  ??_R4?$_Node_class@DV?$regex_traits@D@std@@@std@@6B@ ; std::_Node_class<char,std::regex_traits<char> >::`RTTI Complete Object Locator'
PUBLIC  ??_R0?AV?$_Node_class@DV?$regex_traits@D@std@@@std@@@8 ; std::_Node_class<char,std::regex_traits<char> > `RTTI Type Descriptor'
PUBLIC  ??_R3?$_Node_class@DV?$regex_traits@D@std@@@std@@8 ; std::_Node_class<char,std::regex_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC  ??_R2?$_Node_class@DV?$regex_traits@D@std@@@std@@8 ; std::_Node_class<char,std::regex_traits<char> >::`RTTI Base Class Array'
PUBLIC  ??_R1A@?0A@EA@?$_Node_class@DV?$regex_traits@D@std@@@std@@8 ; std::_Node_class<char,std::regex_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC  ??_R4?$_Node_str@D@std@@6B@       ; std::_Node_str<char>::`RTTI Complete Object Locator'
PUBLIC  ??_R0?AV?$_Node_str@D@std@@@8                 ; std::_Node_str<char> `RTTI Type Descriptor'
PUBLIC  ??_R3?$_Node_str@D@std@@8             ; std::_Node_str<char>::`RTTI Class Hierarchy Descriptor'
PUBLIC  ??_R2?$_Node_str@D@std@@8             ; std::_Node_str<char>::`RTTI Base Class Array'
PUBLIC  ??_R1A@?0A@EA@?$_Node_str@D@std@@8      ; std::_Node_str<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN   __purecall:PROC
EXTRN   ??2@YAPAXI@Z:PROC                   ; operator new
EXTRN   ??3@YAXPAX@Z:PROC                   ; operator delete
EXTRN   ??3@YAXPAXI@Z:PROC                            ; operator delete
EXTRN   ??_V@YAXPAX@Z:PROC                            ; operator delete[]
EXTRN   __invalid_parameter_noinfo_noreturn:PROC
EXTRN   ??0_Lockit@std@@QAE@H@Z:PROC              ; std::_Lockit::_Lockit
EXTRN   ??1_Lockit@std@@QAE@XZ:PROC             ; std::_Lockit::~_Lockit
EXTRN   _free:PROC
EXTRN   _realloc:PROC
EXTRN   _memcmp:PROC
EXTRN   _memcpy:PROC
EXTRN   _memmove:PROC
EXTRN   _memset:PROC
EXTRN   _strchr:PROC
EXTRN   _strlen:PROC
EXTRN   ___std_exception_copy:PROC
EXTRN   ___std_exception_destroy:PROC
EXTRN   ??_Eexception@std@@UAEPAXI@Z:PROC       ; std::exception::`vector deleting destructor'
EXTRN   ?_Xbad_alloc@std@@YAXXZ:PROC              ; std::_Xbad_alloc
EXTRN   ?_Xlength_error@std@@YAXPBD@Z:PROC            ; std::_Xlength_error
EXTRN   ?_Xout_of_range@std@@YAXPBD@Z:PROC            ; std::_Xout_of_range
EXTRN   ??_Eruntime_error@std@@UAEPAXI@Z:PROC   ; std::runtime_error::`vector deleting destructor'
EXTRN   ??_Ebad_cast@std@@UAEPAXI@Z:PROC          ; std::bad_cast::`vector deleting destructor'
EXTRN   __Getcoll:PROC
EXTRN   __Getctype:PROC
EXTRN   __Strcoll:PROC
EXTRN   __Strxfrm:PROC
EXTRN   __Tolower:PROC
EXTRN   __Toupper:PROC
EXTRN   ?_Locinfo_ctor@_Locinfo@std@@SAXPAV12@PBD@Z:PROC ; std::_Locinfo::_Locinfo_ctor
EXTRN   ?_Locinfo_dtor@_Locinfo@std@@SAXPAV12@@Z:PROC ; std::_Locinfo::_Locinfo_dtor
EXTRN   ??_E_Facet_base@std@@UAEPAXI@Z:PROC         ; std::_Facet_base::`vector deleting destructor'
EXTRN   ?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z:PROC ; std::_Facet_Register
EXTRN   ??_Efacet@locale@std@@MAEPAXI@Z:PROC      ; std::locale::facet::`vector deleting destructor'
EXTRN   ?_Init@locale@std@@CAPAV_Locimp@12@_N@Z:PROC  ; std::locale::_Init
EXTRN   ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ:PROC ; std::locale::_Getgloballocale
EXTRN   ??_Ectype_base@std@@UAEPAXI@Z:PROC            ; std::ctype_base::`vector deleting destructor'
EXTRN   ??_E?$ctype@D@std@@MAEPAXI@Z:PROC       ; std::ctype<char>::`vector deleting destructor'
EXTRN   ?_Xregex_error@std@@YAXW4error_type@regex_constants@1@@Z:PROC ; std::_Xregex_error
EXTRN   ??_E_Node_base@std@@UAEPAXI@Z:PROC            ; std::_Node_base::`vector deleting destructor'
EXTRN   ??_E_Root_node@std@@UAEPAXI@Z:PROC            ; std::_Root_node::`vector deleting destructor'
EXTRN   ??_E_Node_end_group@std@@UAEPAXI@Z:PROC             ; std::_Node_end_group::`vector deleting destructor'
EXTRN   ??_E_Node_assert@std@@UAEPAXI@Z:PROC      ; std::_Node_assert::`vector deleting destructor'
EXTRN   ??_E_Node_capture@std@@UAEPAXI@Z:PROC   ; std::_Node_capture::`vector deleting destructor'
EXTRN   ??_E_Node_back@std@@UAEPAXI@Z:PROC            ; std::_Node_back::`vector deleting destructor'
EXTRN   ??_E_Node_endif@std@@UAEPAXI@Z:PROC         ; std::_Node_endif::`vector deleting destructor'
EXTRN   ??_E_Node_if@std@@UAEPAXI@Z:PROC          ; std::_Node_if::`vector deleting destructor'
EXTRN   ??_E_Node_end_rep@std@@UAEPAXI@Z:PROC   ; std::_Node_end_rep::`vector deleting destructor'
EXTRN   ??_E_Node_rep@std@@UAEPAXI@Z:PROC       ; std::_Node_rep::`vector deleting destructor'
EXTRN   ??_E?$collate@D@std@@MAEPAXI@Z:PROC         ; std::collate<char>::`vector deleting destructor'
EXTRN   ??_E?$_Node_str@D@std@@UAEPAXI@Z:PROC   ; std::_Node_str<char>::`vector deleting destructor'
EXTRN   ??_E?$_Node_class@DV?$regex_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::_Node_class<char,std::regex_traits<char> >::`vector deleting destructor'
EXTRN   @__security_check_cookie@4:PROC
EXTRN   __CxxThrowException@8:PROC
EXTRN   ___CxxFrameHandler3:PROC
EXTRN   ??_7type_info@@6B@:QWORD                  ; type_info::`vftable'
EXTRN   ?_Id_cnt@id@locale@std@@0HA:DWORD       ; std::locale::id::_Id_cnt
EXTRN   ?id@?$ctype@D@std@@2V0locale@2@A:DWORD                ; std::ctype<char>::id
EXTRN   ___security_cookie:DWORD
;       COMDAT ?id@?$collate@D@std@@2V0locale@2@A
_BSS    SEGMENT
?id@?$collate@D@std@@2V0locale@2@A DD 01H DUP (?)       ; std::collate<char>::id
_BSS    ENDS
;       COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_BSS    SEGMENT
?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::ctype<char> >::_Psave
_BSS    ENDS
;       COMDAT ?_Psave@?$_Facetptr@V?$collate@D@std@@@std@@2PBVfacet@locale@2@B
_BSS    SEGMENT
?_Psave@?$_Facetptr@V?$collate@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::collate<char> >::_Psave
_BSS    ENDS
;       COMDAT CRT$XCU
CRT$XCU SEGMENT
??id$initializer$@?$collate@D@std@@2P6AXXZA@@3P6AXXZA DD FLAT:??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$collate@D@std@@2P6AXXZA@@3P6AXXZA
CRT$XCU ENDS
;       COMDAT ??_R1A@?0A@EA@?$_Node_str@D@std@@8
rdata$r SEGMENT
??_R1A@?0A@EA@?$_Node_str@D@std@@8 DD FLAT:??_R0?AV?$_Node_str@D@std@@@8 ; std::_Node_str<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
        DD      01H
        DD      00H
        DD      0ffffffffH
        DD      00H
        DD      040H
        DD      FLAT:??_R3?$_Node_str@D@std@@8
rdata$r ENDS
;       COMDAT ??_R2?$_Node_str@D@std@@8
rdata$r SEGMENT
??_R2?$_Node_str@D@std@@8 DD FLAT:??_R1A@?0A@EA@?$_Node_str@D@std@@8 ; std::_Node_str<char>::`RTTI Base Class Array'
        DD      FLAT:??_R1A@?0A@EA@_Node_base@std@@8
rdata$r ENDS
;       COMDAT ??_R3?$_Node_str@D@std@@8
rdata$r SEGMENT
??_R3?$_Node_str@D@std@@8 DD 00H                        ; std::_Node_str<char>::`RTTI Class Hierarchy Descriptor'
        DD      00H
        DD      02H
        DD      FLAT:??_R2?$_Node_str@D@std@@8
rdata$r ENDS
;       COMDAT ??_R0?AV?$_Node_str@D@std@@@8
data$r  SEGMENT
??_R0?AV?$_Node_str@D@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Node_str<char> `RTTI Type Descriptor'
        DD      00H
        DB      '.?AV?$_Node_str@D@std@@', 00H
data$r  ENDS
;       COMDAT ??_R4?$_Node_str@D@std@@6B@
rdata$r SEGMENT
??_R4?$_Node_str@D@std@@6B@ DD 00H                  ; std::_Node_str<char>::`RTTI Complete Object Locator'
        DD      00H
        DD      00H
        DD      FLAT:??_R0?AV?$_Node_str@D@std@@@8
        DD      FLAT:??_R3?$_Node_str@D@std@@8
rdata$r ENDS
;       COMDAT ??_R1A@?0A@EA@?$_Node_class@DV?$regex_traits@D@std@@@std@@8
rdata$r SEGMENT
??_R1A@?0A@EA@?$_Node_class@DV?$regex_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$_Node_class@DV?$regex_traits@D@std@@@std@@@8 ; std::_Node_class<char,std::regex_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
        DD      01H
        DD      00H
        DD      0ffffffffH
        DD      00H
        DD      040H
        DD      FLAT:??_R3?$_Node_class@DV?$regex_traits@D@std@@@std@@8
rdata$r ENDS
;       COMDAT ??_R2?$_Node_class@DV?$regex_traits@D@std@@@std@@8
rdata$r SEGMENT
??_R2?$_Node_class@DV?$regex_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$_Node_class@DV?$regex_traits@D@std@@@std@@8 ; std::_Node_class<char,std::regex_traits<char> >::`RTTI Base Class Array'
        DD      FLAT:??_R1A@?0A@EA@_Node_base@std@@8
rdata$r ENDS
;       COMDAT ??_R3?$_Node_class@DV?$regex_traits@D@std@@@std@@8
rdata$r SEGMENT
??_R3?$_Node_class@DV?$regex_traits@D@std@@@std@@8 DD 00H ; std::_Node_class<char,std::regex_traits<char> >::`RTTI Class Hierarchy Descriptor'
        DD      00H
        DD      02H
        DD      FLAT:??_R2?$_Node_class@DV?$regex_traits@D@std@@@std@@8
rdata$r ENDS
;       COMDAT ??_R0?AV?$_Node_class@DV?$regex_traits@D@std@@@std@@@8
data$r  SEGMENT
??_R0?AV?$_Node_class@DV?$regex_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Node_class<char,std::regex_traits<char> > `RTTI Type Descriptor'
        DD      00H
        DB      '.?AV?$_Node_class@DV?$regex_traits@D@std@@@std@@', 00H
data$r  ENDS
;       COMDAT ??_R4?$_Node_class@DV?$regex_traits@D@std@@@std@@6B@
rdata$r SEGMENT
??_R4?$_Node_class@DV?$regex_traits@D@std@@@std@@6B@ DD 00H ; std::_Node_class<char,std::regex_traits<char> >::`RTTI Complete Object Locator'
        DD      00H
        DD      00H
        DD      FLAT:??_R0?AV?$_Node_class@DV?$regex_traits@D@std@@@std@@@8
        DD      FLAT:??_R3?$_Node_class@DV?$regex_traits@D@std@@@std@@8
rdata$r ENDS
;       COMDAT ??_R1A@?0A@EA@_Node_end_rep@std@@8
rdata$r SEGMENT
??_R1A@?0A@EA@_Node_end_rep@std@@8 DD FLAT:??_R0?AV_Node_end_rep@std@@@8 ; std::_Node_end_rep::`RTTI Base Class Descriptor at (0,-1,0,64)'
        DD      01H
        DD      00H
        DD      0ffffffffH
        DD      00H
        DD      040H
        DD      FLAT:??_R3_Node_end_rep@std@@8
rdata$r ENDS
;       COMDAT ??_R2_Node_end_rep@std@@8
rdata$r SEGMENT
??_R2_Node_end_rep@std@@8 DD FLAT:??_R1A@?0A@EA@_Node_end_rep@std@@8 ; std::_Node_end_rep::`RTTI Base Class Array'
        DD      FLAT:??_R1A@?0A@EA@_Node_base@std@@8
rdata$r ENDS
;       COMDAT ??_R3_Node_end_rep@std@@8
rdata$r SEGMENT
??_R3_Node_end_rep@std@@8 DD 00H                        ; std::_Node_end_rep::`RTTI Class Hierarchy Descriptor'
        DD      00H
        DD      02H
        DD      FLAT:??_R2_Node_end_rep@std@@8
rdata$r ENDS
;       COMDAT ??_R0?AV_Node_end_rep@std@@@8
data$r  SEGMENT
??_R0?AV_Node_end_rep@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Node_end_rep `RTTI Type Descriptor'
        DD      00H
        DB      '.?AV_Node_end_rep@std@@', 00H
data$r  ENDS
;       COMDAT ??_R4_Node_end_rep@std@@6B@
rdata$r SEGMENT
??_R4_Node_end_rep@std@@6B@ DD 00H                  ; std::_Node_end_rep::`RTTI Complete Object Locator'
        DD      00H
        DD      00H
        DD      FLAT:??_R0?AV_Node_end_rep@std@@@8
        DD      FLAT:??_R3_Node_end_rep@std@@8
rdata$r ENDS
;       COMDAT ??_R1A@?0A@EA@_Node_rep@std@@8
rdata$r SEGMENT
??_R1A@?0A@EA@_Node_rep@std@@8 DD FLAT:??_R0?AV_Node_rep@std@@@8 ; std::_Node_rep::`RTTI Base Class Descriptor at (0,-1,0,64)'
        DD      01H
        DD      00H
        DD      0ffffffffH
        DD      00H
        DD      040H
        DD      FLAT:??_R3_Node_rep@std@@8
rdata$r ENDS
;       COMDAT ??_R2_Node_rep@std@@8
rdata$r SEGMENT
??_R2_Node_rep@std@@8 DD FLAT:??_R1A@?0A@EA@_Node_rep@std@@8 ; std::_Node_rep::`RTTI Base Class Array'
        DD      FLAT:??_R1A@?0A@EA@_Node_base@std@@8
rdata$r ENDS
;       COMDAT ??_R3_Node_rep@std@@8
rdata$r SEGMENT
??_R3_Node_rep@std@@8 DD 00H                            ; std::_Node_rep::`RTTI Class Hierarchy Descriptor'
        DD      00H
        DD      02H
        DD      FLAT:??_R2_Node_rep@std@@8
rdata$r ENDS
;       COMDAT ??_R0?AV_Node_rep@std@@@8
data$r  SEGMENT
??_R0?AV_Node_rep@std@@@8 DD FLAT:??_7type_info@@6B@    ; std::_Node_rep `RTTI Type Descriptor'
        DD      00H
        DB      '.?AV_Node_rep@std@@', 00H
data$r  ENDS
;       COMDAT ??_R4_Node_rep@std@@6B@
rdata$r SEGMENT
??_R4_Node_rep@std@@6B@ DD 00H                      ; std::_Node_rep::`RTTI Complete Object Locator'
        DD      00H
        DD      00H
        DD      FLAT:??_R0?AV_Node_rep@std@@@8
        DD      FLAT:??_R3_Node_rep@std@@8
rdata$r ENDS
;       COMDAT ??_R1A@?0A@EA@_Node_if@std@@8
rdata$r SEGMENT
??_R1A@?0A@EA@_Node_if@std@@8 DD FLAT:??_R0?AV_Node_if@std@@@8 ; std::_Node_if::`RTTI Base Class Descriptor at (0,-1,0,64)'
        DD      01H
        DD      00H
        DD      0ffffffffH
        DD      00H
        DD      040H
        DD      FLAT:??_R3_Node_if@std@@8
rdata$r ENDS
;       COMDAT ??_R2_Node_if@std@@8
rdata$r SEGMENT
??_R2_Node_if@std@@8 DD FLAT:??_R1A@?0A@EA@_Node_if@std@@8 ; std::_Node_if::`RTTI Base Class Array'
        DD      FLAT:??_R1A@?0A@EA@_Node_base@std@@8
rdata$r ENDS
;       COMDAT ??_R3_Node_if@std@@8
rdata$r SEGMENT
??_R3_Node_if@std@@8 DD 00H                   ; std::_Node_if::`RTTI Class Hierarchy Descriptor'
        DD      00H
        DD      02H
        DD      FLAT:??_R2_Node_if@std@@8
rdata$r ENDS
;       COMDAT ??_R0?AV_Node_if@std@@@8
data$r  SEGMENT
??_R0?AV_Node_if@std@@@8 DD FLAT:??_7type_info@@6B@     ; std::_Node_if `RTTI Type Descriptor'
        DD      00H
        DB      '.?AV_Node_if@std@@', 00H
data$r  ENDS
;       COMDAT ??_R4_Node_if@std@@6B@
rdata$r SEGMENT
??_R4_Node_if@std@@6B@ DD 00H                     ; std::_Node_if::`RTTI Complete Object Locator'
        DD      00H
        DD      00H
        DD      FLAT:??_R0?AV_Node_if@std@@@8
        DD      FLAT:??_R3_Node_if@std@@8
rdata$r ENDS
;       COMDAT ??_R1A@?0A@EA@_Node_endif@std@@8
rdata$r SEGMENT
??_R1A@?0A@EA@_Node_endif@std@@8 DD FLAT:??_R0?AV_Node_endif@std@@@8 ; std::_Node_endif::`RTTI Base Class Descriptor at (0,-1,0,64)'
        DD      01H
        DD      00H
        DD      0ffffffffH
        DD      00H
        DD      040H
        DD      FLAT:??_R3_Node_endif@std@@8
rdata$r ENDS
;       COMDAT ??_R2_Node_endif@std@@8
rdata$r SEGMENT
??_R2_Node_endif@std@@8 DD FLAT:??_R1A@?0A@EA@_Node_endif@std@@8 ; std::_Node_endif::`RTTI Base Class Array'
        DD      FLAT:??_R1A@?0A@EA@_Node_base@std@@8
rdata$r ENDS
;       COMDAT ??_R3_Node_endif@std@@8
rdata$r SEGMENT
??_R3_Node_endif@std@@8 DD 00H                      ; std::_Node_endif::`RTTI Class Hierarchy Descriptor'
        DD      00H
        DD      02H
        DD      FLAT:??_R2_Node_endif@std@@8
rdata$r ENDS
;       COMDAT ??_R0?AV_Node_endif@std@@@8
data$r  SEGMENT
??_R0?AV_Node_endif@std@@@8 DD FLAT:??_7type_info@@6B@  ; std::_Node_endif `RTTI Type Descriptor'
        DD      00H
        DB      '.?AV_Node_endif@std@@', 00H
data$r  ENDS
;       COMDAT ??_R4_Node_endif@std@@6B@
rdata$r SEGMENT
??_R4_Node_endif@std@@6B@ DD 00H                        ; std::_Node_endif::`RTTI Complete Object Locator'
        DD      00H
        DD      00H
        DD      FLAT:??_R0?AV_Node_endif@std@@@8
        DD      FLAT:??_R3_Node_endif@std@@8
rdata$r ENDS
;       COMDAT ??_R1A@?0A@EA@_Node_back@std@@8
rdata$r SEGMENT
??_R1A@?0A@EA@_Node_back@std@@8 DD FLAT:??_R0?AV_Node_back@std@@@8 ; std::_Node_back::`RTTI Base Class Descriptor at (0,-1,0,64)'
        DD      01H
        DD      00H
        DD      0ffffffffH
        DD      00H
        DD      040H
        DD      FLAT:??_R3_Node_back@std@@8
rdata$r ENDS
;       COMDAT ??_R2_Node_back@std@@8
rdata$r SEGMENT
??_R2_Node_back@std@@8 DD FLAT:??_R1A@?0A@EA@_Node_back@std@@8 ; std::_Node_back::`RTTI Base Class Array'
        DD      FLAT:??_R1A@?0A@EA@_Node_base@std@@8
rdata$r ENDS
;       COMDAT ??_R3_Node_back@std@@8
rdata$r SEGMENT
??_R3_Node_back@std@@8 DD 00H                     ; std::_Node_back::`RTTI Class Hierarchy Descriptor'
        DD      00H
        DD      02H
        DD      FLAT:??_R2_Node_back@std@@8
rdata$r ENDS
;       COMDAT ??_R0?AV_Node_back@std@@@8
data$r  SEGMENT
??_R0?AV_Node_back@std@@@8 DD FLAT:??_7type_info@@6B@   ; std::_Node_back `RTTI Type Descriptor'
        DD      00H
        DB      '.?AV_Node_back@std@@', 00H
data$r  ENDS
;       COMDAT ??_R4_Node_back@std@@6B@
rdata$r SEGMENT
??_R4_Node_back@std@@6B@ DD 00H               ; std::_Node_back::`RTTI Complete Object Locator'
        DD      00H
        DD      00H
        DD      FLAT:??_R0?AV_Node_back@std@@@8
        DD      FLAT:??_R3_Node_back@std@@8
rdata$r ENDS
;       COMDAT ??_R1A@?0A@EA@_Node_capture@std@@8
rdata$r SEGMENT
??_R1A@?0A@EA@_Node_capture@std@@8 DD FLAT:??_R0?AV_Node_capture@std@@@8 ; std::_Node_capture::`RTTI Base Class Descriptor at (0,-1,0,64)'
        DD      01H
        DD      00H
        DD      0ffffffffH
        DD      00H
        DD      040H
        DD      FLAT:??_R3_Node_capture@std@@8
rdata$r ENDS
;       COMDAT ??_R2_Node_capture@std@@8
rdata$r SEGMENT
??_R2_Node_capture@std@@8 DD FLAT:??_R1A@?0A@EA@_Node_capture@std@@8 ; std::_Node_capture::`RTTI Base Class Array'
        DD      FLAT:??_R1A@?0A@EA@_Node_base@std@@8
rdata$r ENDS
;       COMDAT ??_R3_Node_capture@std@@8
rdata$r SEGMENT
??_R3_Node_capture@std@@8 DD 00H                        ; std::_Node_capture::`RTTI Class Hierarchy Descriptor'
        DD      00H
        DD      02H
        DD      FLAT:??_R2_Node_capture@std@@8
rdata$r ENDS
;       COMDAT ??_R0?AV_Node_capture@std@@@8
data$r  SEGMENT
??_R0?AV_Node_capture@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Node_capture `RTTI Type Descriptor'
        DD      00H
        DB      '.?AV_Node_capture@std@@', 00H
data$r  ENDS
;       COMDAT ??_R4_Node_capture@std@@6B@
rdata$r SEGMENT
??_R4_Node_capture@std@@6B@ DD 00H                  ; std::_Node_capture::`RTTI Complete Object Locator'
        DD      00H
        DD      00H
        DD      FLAT:??_R0?AV_Node_capture@std@@@8
        DD      FLAT:??_R3_Node_capture@std@@8
rdata$r ENDS
;       COMDAT ??_R1A@?0A@EA@_Node_assert@std@@8
rdata$r SEGMENT
??_R1A@?0A@EA@_Node_assert@std@@8 DD FLAT:??_R0?AV_Node_assert@std@@@8 ; std::_Node_assert::`RTTI Base Class Descriptor at (0,-1,0,64)'
        DD      01H
        DD      00H
        DD      0ffffffffH
        DD      00H
        DD      040H
        DD      FLAT:??_R3_Node_assert@std@@8
rdata$r ENDS
;       COMDAT ??_R2_Node_assert@std@@8
rdata$r SEGMENT
??_R2_Node_assert@std@@8 DD FLAT:??_R1A@?0A@EA@_Node_assert@std@@8 ; std::_Node_assert::`RTTI Base Class Array'
        DD      FLAT:??_R1A@?0A@EA@_Node_base@std@@8
rdata$r ENDS
;       COMDAT ??_R3_Node_assert@std@@8
rdata$r SEGMENT
??_R3_Node_assert@std@@8 DD 00H               ; std::_Node_assert::`RTTI Class Hierarchy Descriptor'
        DD      00H
        DD      02H
        DD      FLAT:??_R2_Node_assert@std@@8
rdata$r ENDS
;       COMDAT ??_R0?AV_Node_assert@std@@@8
data$r  SEGMENT
??_R0?AV_Node_assert@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Node_assert `RTTI Type Descriptor'
        DD      00H
        DB      '.?AV_Node_assert@std@@', 00H
data$r  ENDS
;       COMDAT ??_R4_Node_assert@std@@6B@
rdata$r SEGMENT
??_R4_Node_assert@std@@6B@ DD 00H                 ; std::_Node_assert::`RTTI Complete Object Locator'
        DD      00H
        DD      00H
        DD      FLAT:??_R0?AV_Node_assert@std@@@8
        DD      FLAT:??_R3_Node_assert@std@@8
rdata$r ENDS
;       COMDAT ??_R1A@?0A@EA@_Node_end_group@std@@8
rdata$r SEGMENT
??_R1A@?0A@EA@_Node_end_group@std@@8 DD FLAT:??_R0?AV_Node_end_group@std@@@8 ; std::_Node_end_group::`RTTI Base Class Descriptor at (0,-1,0,64)'
        DD      01H
        DD      00H
        DD      0ffffffffH
        DD      00H
        DD      040H
        DD      FLAT:??_R3_Node_end_group@std@@8
rdata$r ENDS
;       COMDAT ??_R2_Node_end_group@std@@8
rdata$r SEGMENT
??_R2_Node_end_group@std@@8 DD FLAT:??_R1A@?0A@EA@_Node_end_group@std@@8 ; std::_Node_end_group::`RTTI Base Class Array'
        DD      FLAT:??_R1A@?0A@EA@_Node_base@std@@8
rdata$r ENDS
;       COMDAT ??_R3_Node_end_group@std@@8
rdata$r SEGMENT
??_R3_Node_end_group@std@@8 DD 00H                  ; std::_Node_end_group::`RTTI Class Hierarchy Descriptor'
        DD      00H
        DD      02H
        DD      FLAT:??_R2_Node_end_group@std@@8
rdata$r ENDS
;       COMDAT ??_R0?AV_Node_end_group@std@@@8
data$r  SEGMENT
??_R0?AV_Node_end_group@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Node_end_group `RTTI Type Descriptor'
        DD      00H
        DB      '.?AV_Node_end_group@std@@', 00H
data$r  ENDS
;       COMDAT ??_R4_Node_end_group@std@@6B@
rdata$r SEGMENT
??_R4_Node_end_group@std@@6B@ DD 00H                    ; std::_Node_end_group::`RTTI Complete Object Locator'
        DD      00H
        DD      00H
        DD      FLAT:??_R0?AV_Node_end_group@std@@@8
        DD      FLAT:??_R3_Node_end_group@std@@8
rdata$r ENDS
;       COMDAT ??_R1A@?0A@EA@_Root_node@std@@8
rdata$r SEGMENT
??_R1A@?0A@EA@_Root_node@std@@8 DD FLAT:??_R0?AV_Root_node@std@@@8 ; std::_Root_node::`RTTI Base Class Descriptor at (0,-1,0,64)'
        DD      01H
        DD      00H
        DD      0ffffffffH
        DD      00H
        DD      040H
        DD      FLAT:??_R3_Root_node@std@@8
rdata$r ENDS
;       COMDAT ??_R2_Root_node@std@@8
rdata$r SEGMENT
??_R2_Root_node@std@@8 DD FLAT:??_R1A@?0A@EA@_Root_node@std@@8 ; std::_Root_node::`RTTI Base Class Array'
        DD      FLAT:??_R1A@?0A@EA@_Node_base@std@@8
rdata$r ENDS
;       COMDAT ??_R3_Root_node@std@@8
rdata$r SEGMENT
??_R3_Root_node@std@@8 DD 00H                     ; std::_Root_node::`RTTI Class Hierarchy Descriptor'
        DD      00H
        DD      02H
        DD      FLAT:??_R2_Root_node@std@@8
rdata$r ENDS
;       COMDAT ??_R0?AV_Root_node@std@@@8
data$r  SEGMENT
??_R0?AV_Root_node@std@@@8 DD FLAT:??_7type_info@@6B@   ; std::_Root_node `RTTI Type Descriptor'
        DD      00H
        DB      '.?AV_Root_node@std@@', 00H
data$r  ENDS
;       COMDAT ??_R4_Root_node@std@@6B@
rdata$r SEGMENT
??_R4_Root_node@std@@6B@ DD 00H               ; std::_Root_node::`RTTI Complete Object Locator'
        DD      00H
        DD      00H
        DD      FLAT:??_R0?AV_Root_node@std@@@8
        DD      FLAT:??_R3_Root_node@std@@8
rdata$r ENDS
;       COMDAT ??_R1A@?0A@EA@_Node_base@std@@8
rdata$r SEGMENT
??_R1A@?0A@EA@_Node_base@std@@8 DD FLAT:??_R0?AV_Node_base@std@@@8 ; std::_Node_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
        DD      00H
        DD      00H
        DD      0ffffffffH
        DD      00H
        DD      040H
        DD      FLAT:??_R3_Node_base@std@@8
rdata$r ENDS
;       COMDAT ??_R2_Node_base@std@@8
rdata$r SEGMENT
??_R2_Node_base@std@@8 DD FLAT:??_R1A@?0A@EA@_Node_base@std@@8 ; std::_Node_base::`RTTI Base Class Array'
rdata$r ENDS
;       COMDAT ??_R3_Node_base@std@@8
rdata$r SEGMENT
??_R3_Node_base@std@@8 DD 00H                     ; std::_Node_base::`RTTI Class Hierarchy Descriptor'
        DD      00H
        DD      01H
        DD      FLAT:??_R2_Node_base@std@@8
rdata$r ENDS
;       COMDAT ??_R0?AV_Node_base@std@@@8
data$r  SEGMENT
??_R0?AV_Node_base@std@@@8 DD FLAT:??_7type_info@@6B@   ; std::_Node_base `RTTI Type Descriptor'
        DD      00H
        DB      '.?AV_Node_base@std@@', 00H
data$r  ENDS
;       COMDAT ??_R4_Node_base@std@@6B@
rdata$r SEGMENT
??_R4_Node_base@std@@6B@ DD 00H               ; std::_Node_base::`RTTI Complete Object Locator'
        DD      00H
        DD      00H
        DD      FLAT:??_R0?AV_Node_base@std@@@8
        DD      FLAT:??_R3_Node_base@std@@8
rdata$r ENDS
;       COMDAT ??_R1A@?0A@EA@?$collate@D@std@@8
rdata$r SEGMENT
??_R1A@?0A@EA@?$collate@D@std@@8 DD FLAT:??_R0?AV?$collate@D@std@@@8 ; std::collate<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
        DD      03H
        DD      00H
        DD      0ffffffffH
        DD      00H
        DD      040H
        DD      FLAT:??_R3?$collate@D@std@@8
rdata$r ENDS
;       COMDAT ??_R2?$collate@D@std@@8
rdata$r SEGMENT
??_R2?$collate@D@std@@8 DD FLAT:??_R1A@?0A@EA@?$collate@D@std@@8 ; std::collate<char>::`RTTI Base Class Array'
        DD      FLAT:??_R1A@?0A@EA@facet@locale@std@@8
        DD      FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
        DD      FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r ENDS
;       COMDAT ??_R3?$collate@D@std@@8
rdata$r SEGMENT
??_R3?$collate@D@std@@8 DD 00H                      ; std::collate<char>::`RTTI Class Hierarchy Descriptor'
        DD      01H
        DD      04H
        DD      FLAT:??_R2?$collate@D@std@@8
rdata$r ENDS
;       COMDAT ??_R0?AV?$collate@D@std@@@8
data$r  SEGMENT
??_R0?AV?$collate@D@std@@@8 DD FLAT:??_7type_info@@6B@  ; std::collate<char> `RTTI Type Descriptor'
        DD      00H
        DB      '.?AV?$collate@D@std@@', 00H
data$r  ENDS
;       COMDAT ??_R4?$collate@D@std@@6B@
rdata$r SEGMENT
??_R4?$collate@D@std@@6B@ DD 00H                        ; std::collate<char>::`RTTI Complete Object Locator'
        DD      00H
        DD      00H
        DD      FLAT:??_R0?AV?$collate@D@std@@@8
        DD      FLAT:??_R3?$collate@D@std@@8
rdata$r ENDS
;       COMDAT ??_R1A@?0A@EA@?$ctype@D@std@@8
rdata$r SEGMENT
??_R1A@?0A@EA@?$ctype@D@std@@8 DD FLAT:??_R0?AV?$ctype@D@std@@@8 ; std::ctype<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
        DD      04H
        DD      00H
        DD      0ffffffffH
        DD      00H
        DD      040H
        DD      FLAT:??_R3?$ctype@D@std@@8
rdata$r ENDS
;       COMDAT ??_R2?$ctype@D@std@@8
rdata$r SEGMENT
??_R2?$ctype@D@std@@8 DD FLAT:??_R1A@?0A@EA@?$ctype@D@std@@8 ; std::ctype<char>::`RTTI Base Class Array'
        DD      FLAT:??_R1A@?0A@EA@ctype_base@std@@8
        DD      FLAT:??_R1A@?0A@EA@facet@locale@std@@8
        DD      FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
        DD      FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r ENDS
;       COMDAT ??_R3?$ctype@D@std@@8
rdata$r SEGMENT
??_R3?$ctype@D@std@@8 DD 00H                            ; std::ctype<char>::`RTTI Class Hierarchy Descriptor'
        DD      01H
        DD      05H
        DD      FLAT:??_R2?$ctype@D@std@@8
rdata$r ENDS
;       COMDAT ??_R0?AV?$ctype@D@std@@@8
data$r  SEGMENT
??_R0?AV?$ctype@D@std@@@8 DD FLAT:??_7type_info@@6B@    ; std::ctype<char> `RTTI Type Descriptor'
        DD      00H
        DB      '.?AV?$ctype@D@std@@', 00H
data$r  ENDS
;       COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r SEGMENT
??_R4?$ctype@D@std@@6B@ DD 00H                      ; std::ctype<char>::`RTTI Complete Object Locator'
        DD      00H
        DD      00H
        DD      FLAT:??_R0?AV?$ctype@D@std@@@8
        DD      FLAT:??_R3?$ctype@D@std@@8
rdata$r ENDS
;       COMDAT ??_R1A@?0A@EA@ctype_base@std@@8
rdata$r SEGMENT
??_R1A@?0A@EA@ctype_base@std@@8 DD FLAT:??_R0?AUctype_base@std@@@8 ; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
        DD      03H
        DD      00H
        DD      0ffffffffH
        DD      00H
        DD      040H
        DD      FLAT:??_R3ctype_base@std@@8
rdata$r ENDS
;       COMDAT ??_R2ctype_base@std@@8
rdata$r SEGMENT
??_R2ctype_base@std@@8 DD FLAT:??_R1A@?0A@EA@ctype_base@std@@8 ; std::ctype_base::`RTTI Base Class Array'
        DD      FLAT:??_R1A@?0A@EA@facet@locale@std@@8
        DD      FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
        DD      FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r ENDS
;       COMDAT ??_R3ctype_base@std@@8
rdata$r SEGMENT
??_R3ctype_base@std@@8 DD 00H                     ; std::ctype_base::`RTTI Class Hierarchy Descriptor'
        DD      01H
        DD      04H
        DD      FLAT:??_R2ctype_base@std@@8
rdata$r ENDS
;       COMDAT ??_R0?AUctype_base@std@@@8
data$r  SEGMENT
??_R0?AUctype_base@std@@@8 DD FLAT:??_7type_info@@6B@   ; std::ctype_base `RTTI Type Descriptor'
        DD      00H
        DB      '.?AUctype_base@std@@', 00H
data$r  ENDS
;       COMDAT ??_R4ctype_base@std@@6B@
rdata$r SEGMENT
??_R4ctype_base@std@@6B@ DD 00H               ; std::ctype_base::`RTTI Complete Object Locator'
        DD      00H
        DD      00H
        DD      FLAT:??_R0?AUctype_base@std@@@8
        DD      FLAT:??_R3ctype_base@std@@8
rdata$r ENDS
;       COMDAT ??_R4facet@locale@std@@6B@
rdata$r SEGMENT
??_R4facet@locale@std@@6B@ DD 00H                 ; std::locale::facet::`RTTI Complete Object Locator'
        DD      00H
        DD      00H
        DD      FLAT:??_R0?AVfacet@locale@std@@@8
        DD      FLAT:??_R3facet@locale@std@@8
rdata$r ENDS
;       COMDAT ??_R1A@?0A@EA@_Crt_new_delete@std@@8
rdata$r SEGMENT
??_R1A@?0A@EA@_Crt_new_delete@std@@8 DD FLAT:??_R0?AU_Crt_new_delete@std@@@8 ; std::_Crt_new_delete::`RTTI Base Class Descriptor at (0,-1,0,64)'
        DD      00H
        DD      00H
        DD      0ffffffffH
        DD      00H
        DD      040H
        DD      FLAT:??_R3_Crt_new_delete@std@@8
rdata$r ENDS
;       COMDAT ??_R2_Crt_new_delete@std@@8
rdata$r SEGMENT
??_R2_Crt_new_delete@std@@8 DD FLAT:??_R1A@?0A@EA@_Crt_new_delete@std@@8 ; std::_Crt_new_delete::`RTTI Base Class Array'
rdata$r ENDS
;       COMDAT ??_R3_Crt_new_delete@std@@8
rdata$r SEGMENT
??_R3_Crt_new_delete@std@@8 DD 00H                  ; std::_Crt_new_delete::`RTTI Class Hierarchy Descriptor'
        DD      00H
        DD      01H
        DD      FLAT:??_R2_Crt_new_delete@std@@8
rdata$r ENDS
;       COMDAT ??_R0?AU_Crt_new_delete@std@@@8
data$r  SEGMENT
??_R0?AU_Crt_new_delete@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Crt_new_delete `RTTI Type Descriptor'
        DD      00H
        DB      '.?AU_Crt_new_delete@std@@', 00H
data$r  ENDS
;       COMDAT ??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r SEGMENT
??_R13?0A@EA@_Crt_new_delete@std@@8 DD FLAT:??_R0?AU_Crt_new_delete@std@@@8 ; std::_Crt_new_delete::`RTTI Base Class Descriptor at (4,-1,0,64)'
        DD      00H
        DD      04H
        DD      0ffffffffH
        DD      00H
        DD      040H
        DD      FLAT:??_R3_Crt_new_delete@std@@8
rdata$r ENDS
;       COMDAT ??_R2facet@locale@std@@8
rdata$r SEGMENT
??_R2facet@locale@std@@8 DD FLAT:??_R1A@?0A@EA@facet@locale@std@@8 ; std::locale::facet::`RTTI Base Class Array'
        DD      FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
        DD      FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r ENDS
;       COMDAT ??_R3facet@locale@std@@8
rdata$r SEGMENT
??_R3facet@locale@std@@8 DD 00H               ; std::locale::facet::`RTTI Class Hierarchy Descriptor'
        DD      01H
        DD      03H
        DD      FLAT:??_R2facet@locale@std@@8
rdata$r ENDS
;       COMDAT ??_R0?AVfacet@locale@std@@@8
data$r  SEGMENT
??_R0?AVfacet@locale@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::locale::facet `RTTI Type Descriptor'
        DD      00H
        DB      '.?AVfacet@locale@std@@', 00H
data$r  ENDS
;       COMDAT ??_R1A@?0A@EA@facet@locale@std@@8
rdata$r SEGMENT
??_R1A@?0A@EA@facet@locale@std@@8 DD FLAT:??_R0?AVfacet@locale@std@@@8 ; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
        DD      02H
        DD      00H
        DD      0ffffffffH
        DD      00H
        DD      040H
        DD      FLAT:??_R3facet@locale@std@@8
rdata$r ENDS
;       COMDAT ??_R1A@?0A@EA@_Facet_base@std@@8
rdata$r SEGMENT
??_R1A@?0A@EA@_Facet_base@std@@8 DD FLAT:??_R0?AV_Facet_base@std@@@8 ; std::_Facet_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
        DD      00H
        DD      00H
        DD      0ffffffffH
        DD      00H
        DD      040H
        DD      FLAT:??_R3_Facet_base@std@@8
rdata$r ENDS
;       COMDAT ??_R2_Facet_base@std@@8
rdata$r SEGMENT
??_R2_Facet_base@std@@8 DD FLAT:??_R1A@?0A@EA@_Facet_base@std@@8 ; std::_Facet_base::`RTTI Base Class Array'
rdata$r ENDS
;       COMDAT ??_R3_Facet_base@std@@8
rdata$r SEGMENT
??_R3_Facet_base@std@@8 DD 00H                      ; std::_Facet_base::`RTTI Class Hierarchy Descriptor'
        DD      00H
        DD      01H
        DD      FLAT:??_R2_Facet_base@std@@8
rdata$r ENDS
;       COMDAT ??_R0?AV_Facet_base@std@@@8
data$r  SEGMENT
??_R0?AV_Facet_base@std@@@8 DD FLAT:??_7type_info@@6B@  ; std::_Facet_base `RTTI Type Descriptor'
        DD      00H
        DB      '.?AV_Facet_base@std@@', 00H
data$r  ENDS
;       COMDAT ??_R4_Facet_base@std@@6B@
rdata$r SEGMENT
??_R4_Facet_base@std@@6B@ DD 00H                        ; std::_Facet_base::`RTTI Complete Object Locator'
        DD      00H
        DD      00H
        DD      FLAT:??_R0?AV_Facet_base@std@@@8
        DD      FLAT:??_R3_Facet_base@std@@8
rdata$r ENDS
;       COMDAT ??_R1A@?0A@EA@bad_cast@std@@8
rdata$r SEGMENT
??_R1A@?0A@EA@bad_cast@std@@8 DD FLAT:??_R0?AVbad_cast@std@@@8 ; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
        DD      01H
        DD      00H
        DD      0ffffffffH
        DD      00H
        DD      040H
        DD      FLAT:??_R3bad_cast@std@@8
rdata$r ENDS
;       COMDAT ??_R2bad_cast@std@@8
rdata$r SEGMENT
??_R2bad_cast@std@@8 DD FLAT:??_R1A@?0A@EA@bad_cast@std@@8 ; std::bad_cast::`RTTI Base Class Array'
        DD      FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r ENDS
;       COMDAT ??_R3bad_cast@std@@8
rdata$r SEGMENT
??_R3bad_cast@std@@8 DD 00H                   ; std::bad_cast::`RTTI Class Hierarchy Descriptor'
        DD      00H
        DD      02H
        DD      FLAT:??_R2bad_cast@std@@8
rdata$r ENDS
;       COMDAT ??_R4bad_cast@std@@6B@
rdata$r SEGMENT
??_R4bad_cast@std@@6B@ DD 00H                     ; std::bad_cast::`RTTI Complete Object Locator'
        DD      00H
        DD      00H
        DD      FLAT:??_R0?AVbad_cast@std@@@8
        DD      FLAT:??_R3bad_cast@std@@8
rdata$r ENDS
;       COMDAT ??_R1A@?0A@EA@runtime_error@std@@8
rdata$r SEGMENT
??_R1A@?0A@EA@runtime_error@std@@8 DD FLAT:??_R0?AVruntime_error@std@@@8 ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
        DD      01H
        DD      00H
        DD      0ffffffffH
        DD      00H
        DD      040H
        DD      FLAT:??_R3runtime_error@std@@8
rdata$r ENDS
;       COMDAT ??_R2runtime_error@std@@8
rdata$r SEGMENT
??_R2runtime_error@std@@8 DD FLAT:??_R1A@?0A@EA@runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
        DD      FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r ENDS
;       COMDAT ??_R3runtime_error@std@@8
rdata$r SEGMENT
??_R3runtime_error@std@@8 DD 00H                        ; std::runtime_error::`RTTI Class Hierarchy Descriptor'
        DD      00H
        DD      02H
        DD      FLAT:??_R2runtime_error@std@@8
rdata$r ENDS
;       COMDAT ??_R4runtime_error@std@@6B@
rdata$r SEGMENT
??_R4runtime_error@std@@6B@ DD 00H                  ; std::runtime_error::`RTTI Complete Object Locator'
        DD      00H
        DD      00H
        DD      FLAT:??_R0?AVruntime_error@std@@@8
        DD      FLAT:??_R3runtime_error@std@@8
rdata$r ENDS
;       COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
        DD      00H
        DD      00H
        DD      0ffffffffH
        DD      00H
        DD      040H
        DD      FLAT:??_R3exception@std@@8
rdata$r ENDS
;       COMDAT ??_R2exception@std@@8
rdata$r SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r ENDS
;       COMDAT ??_R3exception@std@@8
rdata$r SEGMENT
??_R3exception@std@@8 DD 00H                            ; std::exception::`RTTI Class Hierarchy Descriptor'
        DD      00H
        DD      01H
        DD      FLAT:??_R2exception@std@@8
rdata$r ENDS
;       COMDAT ??_R4exception@std@@6B@
rdata$r SEGMENT
??_R4exception@std@@6B@ DD 00H                      ; std::exception::`RTTI Complete Object Locator'
        DD      00H
        DD      00H
        DD      FLAT:??_R0?AVexception@std@@@8
        DD      FLAT:??_R3exception@std@@8
rdata$r ENDS
;       COMDAT ??_C@_1O@OAFMJDHN@?$AAx?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?$AA@
CONST   SEGMENT
??_C@_1O@OAFMJDHN@?$AAx?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?$AA@ DB 'x', 00H, 'd'
        DB      00H, 'i', 00H, 'g', 00H, 'i', 00H, 't', 00H, 00H, 00H ; `string'
CONST   ENDS
;       COMDAT ??_C@_06BAPHGFFK@xdigit?$AA@
CONST   SEGMENT
??_C@_06BAPHGFFK@xdigit?$AA@ DB 'xdigit', 00H         ; `string'
CONST   ENDS
;       COMDAT ??_C@_13CIFDLIMG@?$AAw?$AA?$AA@
CONST   SEGMENT
??_C@_13CIFDLIMG@?$AAw?$AA?$AA@ DB 'w', 00H, 00H, 00H   ; `string'
CONST   ENDS
;       COMDAT ??_C@_01NOFIACDB@w?$AA@
CONST   SEGMENT
??_C@_01NOFIACDB@w?$AA@ DB 'w', 00H           ; `string'
CONST   ENDS
;       COMDAT ??_C@_1M@PLNFCNIC@?$AAu?$AAp?$AAp?$AAe?$AAr?$AA?$AA@
CONST   SEGMENT
??_C@_1M@PLNFCNIC@?$AAu?$AAp?$AAp?$AAe?$AAr?$AA?$AA@ DB 'u', 00H, 'p', 00H
        DB      'p', 00H, 'e', 00H, 'r', 00H, 00H, 00H      ; `string'
CONST   ENDS
;       COMDAT ??_C@_05NECKJAMC@upper?$AA@
CONST   SEGMENT
??_C@_05NECKJAMC@upper?$AA@ DB 'upper', 00H       ; `string'
CONST   ENDS
;       COMDAT ??_C@_13KHDBCPJB@?$AAs?$AA?$AA@
CONST   SEGMENT
??_C@_13KHDBCPJB@?$AAs?$AA?$AA@ DB 's', 00H, 00H, 00H   ; `string'
CONST   ENDS
;       COMDAT ??_C@_01LKDEMHDF@s?$AA@
CONST   SEGMENT
??_C@_01LKDEMHDF@s?$AA@ DB 's', 00H           ; `string'
CONST   ENDS
;       COMDAT ??_C@_1M@LPGODFOM@?$AAs?$AAp?$AAa?$AAc?$AAe?$AA?$AA@
CONST   SEGMENT
??_C@_1M@LPGODFOM@?$AAs?$AAp?$AAa?$AAc?$AAe?$AA?$AA@ DB 's', 00H, 'p', 00H
        DB      'a', 00H, 'c', 00H, 'e', 00H, 00H, 00H      ; `string'
CONST   ENDS
;       COMDAT ??_C@_05OLNILLAB@space?$AA@
CONST   SEGMENT
??_C@_05OLNILLAB@space?$AA@ DB 'space', 00H       ; `string'
CONST   ENDS
;       COMDAT ??_C@_1M@BPFMAOAO@?$AAp?$AAu?$AAn?$AAc?$AAt?$AA?$AA@
CONST   SEGMENT
??_C@_1M@BPFMAOAO@?$AAp?$AAu?$AAn?$AAc?$AAt?$AA?$AA@ DB 'p', 00H, 'u', 00H
        DB      'n', 00H, 'c', 00H, 't', 00H, 00H, 00H      ; `string'
CONST   ENDS
;       COMDAT ??_C@_05KOBGHFJJ@punct?$AA@
CONST   SEGMENT
??_C@_05KOBGHFJJ@punct?$AA@ DB 'punct', 00H       ; `string'
CONST   ENDS
;       COMDAT ??_C@_1M@ELNLAPLA@?$AAp?$AAr?$AAi?$AAn?$AAt?$AA?$AA@
CONST   SEGMENT
??_C@_1M@ELNLAPLA@?$AAp?$AAr?$AAi?$AAn?$AAt?$AA?$AA@ DB 'p', 00H, 'r', 00H
        DB      'i', 00H, 'n', 00H, 't', 00H, 00H, 00H      ; `string'
CONST   ENDS
;       COMDAT ??_C@_05IJDJACGD@print?$AA@
CONST   SEGMENT
??_C@_05IJDJACGD@print?$AA@ DB 'print', 00H       ; `string'
CONST   ENDS
;       COMDAT ??_C@_1M@LGAECJJD@?$AAl?$AAo?$AAw?$AAe?$AAr?$AA?$AA@
CONST   SEGMENT
??_C@_1M@LGAECJJD@?$AAl?$AAo?$AAw?$AAe?$AAr?$AA?$AA@ DB 'l', 00H, 'o', 00H
        DB      'w', 00H, 'e', 00H, 'r', 00H, 00H, 00H      ; `string'
CONST   ENDS
;       COMDAT ??_C@_05IPJEPLHL@lower?$AA@
CONST   SEGMENT
??_C@_05IPJEPLHL@lower?$AA@ DB 'lower', 00H       ; `string'
CONST   ENDS
;       COMDAT ??_C@_1M@MDKNJLLK@?$AAg?$AAr?$AAa?$AAp?$AAh?$AA?$AA@
CONST   SEGMENT
??_C@_1M@MDKNJLLK@?$AAg?$AAr?$AAa?$AAp?$AAh?$AA?$AA@ DB 'g', 00H, 'r', 00H
        DB      'a', 00H, 'p', 00H, 'h', 00H, 00H, 00H      ; `string'
CONST   ENDS
;       COMDAT ??_C@_05KCJBMLII@graph?$AA@
CONST   SEGMENT
??_C@_05KCJBMLII@graph?$AA@ DB 'graph', 00H       ; `string'
CONST   ENDS
;       COMDAT ??_C@_1M@JDAEIBKG@?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?$AA@
CONST   SEGMENT
??_C@_1M@JDAEIBKG@?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?$AA@ DB 'd', 00H, 'i', 00H
        DB      'g', 00H, 'i', 00H, 't', 00H, 00H, 00H      ; `string'
CONST   ENDS
;       COMDAT ??_C@_05ODNOIFML@digit?$AA@
CONST   SEGMENT
??_C@_05ODNOIFML@digit?$AA@ DB 'digit', 00H       ; `string'
CONST   ENDS
;       COMDAT ??_C@_13GKPPEALH@?$AAd?$AA?$AA@
CONST   SEGMENT
??_C@_13GKPPEALH@?$AAd?$AA?$AA@ DB 'd', 00H, 00H, 00H   ; `string'
CONST   ENDS
;       COMDAT ??_C@_01LPLHEDKD@d?$AA@
CONST   SEGMENT
??_C@_01LPLHEDKD@d?$AA@ DB 'd', 00H           ; `string'
CONST   ENDS
;       COMDAT ??_C@_1M@LMIMILA@?$AAc?$AAn?$AAt?$AAr?$AAl?$AA?$AA@
CONST   SEGMENT
??_C@_1M@LMIMILA@?$AAc?$AAn?$AAt?$AAr?$AAl?$AA?$AA@ DB 'c', 00H, 'n', 00H
        DB      't', 00H, 'r', 00H, 'l', 00H, 00H, 00H      ; `string'
CONST   ENDS
;       COMDAT ??_C@_05JMDPEFNK@cntrl?$AA@
CONST   SEGMENT
??_C@_05JMDPEFNK@cntrl?$AA@ DB 'cntrl', 00H       ; `string'
CONST   ENDS
;       COMDAT ??_C@_1M@EJAAJBPE@?$AAb?$AAl?$AAa?$AAn?$AAk?$AA?$AA@
CONST   SEGMENT
??_C@_1M@EJAAJBPE@?$AAb?$AAl?$AAa?$AAn?$AAk?$AA?$AA@ DB 'b', 00H, 'l', 00H
        DB      'a', 00H, 'n', 00H, 'k', 00H, 00H, 00H      ; `string'
CONST   ENDS
;       COMDAT ??_C@_05BABJKOGB@blank?$AA@
CONST   SEGMENT
??_C@_05BABJKOGB@blank?$AA@ DB 'blank', 00H       ; `string'
CONST   ENDS
;       COMDAT ??_C@_1M@DHGLHBMI@?$AAa?$AAl?$AAp?$AAh?$AAa?$AA?$AA@
CONST   SEGMENT
??_C@_1M@DHGLHBMI@?$AAa?$AAl?$AAp?$AAh?$AAa?$AA?$AA@ DB 'a', 00H, 'l', 00H
        DB      'p', 00H, 'h', 00H, 'a', 00H, 00H, 00H      ; `string'
CONST   ENDS
;       COMDAT ??_C@_05IAEKHIAN@alpha?$AA@
CONST   SEGMENT
??_C@_05IAEKHIAN@alpha?$AA@ DB 'alpha', 00H       ; `string'
CONST   ENDS
;       COMDAT ??_C@_1M@KLMEPMCM@?$AAa?$AAl?$AAn?$AAu?$AAm?$AA?$AA@
CONST   SEGMENT
??_C@_1M@KLMEPMCM@?$AAa?$AAl?$AAn?$AAu?$AAm?$AA?$AA@ DB 'a', 00H, 'l', 00H
        DB      'n', 00H, 'u', 00H, 'm', 00H, 00H, 00H      ; `string'
CONST   ENDS
;       COMDAT ??_C@_05IIMHCHIO@alnum?$AA@
CONST   SEGMENT
??_C@_05IIMHCHIO@alnum?$AA@ DB 'alnum', 00H       ; `string'
CONST   ENDS
;       COMDAT ??_7?$_Node_class@DV?$regex_traits@D@std@@@std@@6B@
CONST   SEGMENT
??_7?$_Node_class@DV?$regex_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$_Node_class@DV?$regex_traits@D@std@@@std@@6B@ ; std::_Node_class<char,std::regex_traits<char> >::`vftable'
        DD      FLAT:??_E?$_Node_class@DV?$regex_traits@D@std@@@std@@UAEPAXI@Z
CONST   ENDS
;       COMDAT ??_7?$_Node_str@D@std@@6B@
CONST   SEGMENT
??_7?$_Node_str@D@std@@6B@ DD FLAT:??_R4?$_Node_str@D@std@@6B@ ; std::_Node_str<char>::`vftable'
        DD      FLAT:??_E?$_Node_str@D@std@@UAEPAXI@Z
CONST   ENDS
;       COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST   SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
        DB      00H                               ; `string'
CONST   ENDS
;       COMDAT ??_C@_0BG@EOMJEIFA@vector?$DMbool?$DO?5too?5long?$AA@
CONST   SEGMENT
??_C@_0BG@EOMJEIFA@vector?$DMbool?$DO?5too?5long?$AA@ DB 'vector<bool> to'
        DB      'o long', 00H                         ; `string'
CONST   ENDS
;       COMDAT __CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
xdata$x SEGMENT
__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12 DD 00H
        DD      FLAT:??_R0?AVbad_cast@std@@@8
        DD      00H
        DD      0ffffffffH
        ORG $+4
        DD      0cH
        DD      FLAT:??0bad_cast@std@@QAE@ABV01@@Z
xdata$x ENDS
;       COMDAT ??_R0?AVbad_cast@std@@@8
data$r  SEGMENT
??_R0?AVbad_cast@std@@@8 DD FLAT:??_7type_info@@6B@     ; std::bad_cast `RTTI Type Descriptor'
        DD      00H
        DB      '.?AVbad_cast@std@@', 00H
data$r  ENDS
;       COMDAT __CTA2?AVbad_cast@std@@
xdata$x SEGMENT
__CTA2?AVbad_cast@std@@ DD 02H
        DD      FLAT:__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
        DD      FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x ENDS
;       COMDAT __TI2?AVbad_cast@std@@
xdata$x SEGMENT
__TI2?AVbad_cast@std@@ DD 00H
        DD      FLAT:??1bad_cast@std@@UAE@XZ
        DD      00H
        DD      FLAT:__CTA2?AVbad_cast@std@@
xdata$x ENDS
;       COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST   SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
        DB      'tion', 00H                       ; `string'
CONST   ENDS
;       COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST   SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST   ENDS
;       COMDAT ??_7?$collate@D@std@@6B@
CONST   SEGMENT
??_7?$collate@D@std@@6B@ DD FLAT:??_R4?$collate@D@std@@6B@ ; std::collate<char>::`vftable'
        DD      FLAT:??_E?$collate@D@std@@MAEPAXI@Z
        DD      FLAT:?_Incref@facet@locale@std@@UAEXXZ
        DD      FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
        DD      FLAT:?do_compare@?$collate@D@std@@MBEHPBD000@Z
        DD      FLAT:?do_transform@?$collate@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PBD0@Z
        DD      FLAT:?do_hash@?$collate@D@std@@MBEJPBD0@Z
CONST   ENDS
;       COMDAT ??_7_Node_rep@std@@6B@
CONST   SEGMENT
??_7_Node_rep@std@@6B@ DD FLAT:??_R4_Node_rep@std@@6B@  ; std::_Node_rep::`vftable'
        DD      FLAT:??_E_Node_rep@std@@UAEPAXI@Z
CONST   ENDS
;       COMDAT ??_7_Node_end_rep@std@@6B@
CONST   SEGMENT
??_7_Node_end_rep@std@@6B@ DD FLAT:??_R4_Node_end_rep@std@@6B@ ; std::_Node_end_rep::`vftable'
        DD      FLAT:??_E_Node_end_rep@std@@UAEPAXI@Z
CONST   ENDS
;       COMDAT ??_7_Node_if@std@@6B@
CONST   SEGMENT
??_7_Node_if@std@@6B@ DD FLAT:??_R4_Node_if@std@@6B@    ; std::_Node_if::`vftable'
        DD      FLAT:??_E_Node_if@std@@UAEPAXI@Z
CONST   ENDS
;       COMDAT ??_7_Node_endif@std@@6B@
CONST   SEGMENT
??_7_Node_endif@std@@6B@ DD FLAT:??_R4_Node_endif@std@@6B@ ; std::_Node_endif::`vftable'
        DD      FLAT:??_E_Node_endif@std@@UAEPAXI@Z
CONST   ENDS
;       COMDAT ??_7_Node_back@std@@6B@
CONST   SEGMENT
??_7_Node_back@std@@6B@ DD FLAT:??_R4_Node_back@std@@6B@ ; std::_Node_back::`vftable'
        DD      FLAT:??_E_Node_back@std@@UAEPAXI@Z
CONST   ENDS
;       COMDAT ??_7_Node_capture@std@@6B@
CONST   SEGMENT
??_7_Node_capture@std@@6B@ DD FLAT:??_R4_Node_capture@std@@6B@ ; std::_Node_capture::`vftable'
        DD      FLAT:??_E_Node_capture@std@@UAEPAXI@Z
CONST   ENDS
;       COMDAT ??_7_Node_assert@std@@6B@
CONST   SEGMENT
??_7_Node_assert@std@@6B@ DD FLAT:??_R4_Node_assert@std@@6B@ ; std::_Node_assert::`vftable'
        DD      FLAT:??_E_Node_assert@std@@UAEPAXI@Z
CONST   ENDS
;       COMDAT ??_7_Node_end_group@std@@6B@
CONST   SEGMENT
??_7_Node_end_group@std@@6B@ DD FLAT:??_R4_Node_end_group@std@@6B@ ; std::_Node_end_group::`vftable'
        DD      FLAT:??_E_Node_end_group@std@@UAEPAXI@Z
CONST   ENDS
;       COMDAT ??_7_Root_node@std@@6B@
CONST   SEGMENT
??_7_Root_node@std@@6B@ DD FLAT:??_R4_Root_node@std@@6B@ ; std::_Root_node::`vftable'
        DD      FLAT:??_E_Root_node@std@@UAEPAXI@Z
CONST   ENDS
;       COMDAT ??_7_Node_base@std@@6B@
CONST   SEGMENT
??_7_Node_base@std@@6B@ DD FLAT:??_R4_Node_base@std@@6B@ ; std::_Node_base::`vftable'
        DD      FLAT:??_E_Node_base@std@@UAEPAXI@Z
CONST   ENDS
;       COMDAT ??_7?$ctype@D@std@@6B@
CONST   SEGMENT
??_7?$ctype@D@std@@6B@ DD FLAT:??_R4?$ctype@D@std@@6B@  ; std::ctype<char>::`vftable'
        DD      FLAT:??_E?$ctype@D@std@@MAEPAXI@Z
        DD      FLAT:?_Incref@facet@locale@std@@UAEXXZ
        DD      FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
        DD      FLAT:?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
        DD      FLAT:?do_tolower@?$ctype@D@std@@MBEDD@Z
        DD      FLAT:?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
        DD      FLAT:?do_toupper@?$ctype@D@std@@MBEDD@Z
        DD      FLAT:?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
        DD      FLAT:?do_widen@?$ctype@D@std@@MBEDD@Z
        DD      FLAT:?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
        DD      FLAT:?do_narrow@?$ctype@D@std@@MBEDDD@Z
CONST   ENDS
;       COMDAT ??_7ctype_base@std@@6B@
CONST   SEGMENT
??_7ctype_base@std@@6B@ DD FLAT:??_R4ctype_base@std@@6B@ ; std::ctype_base::`vftable'
        DD      FLAT:??_Ectype_base@std@@UAEPAXI@Z
        DD      FLAT:?_Incref@facet@locale@std@@UAEXXZ
        DD      FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
CONST   ENDS
;       COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST   SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H                     ; `string'
CONST   ENDS
;       COMDAT ??_7facet@locale@std@@6B@
CONST   SEGMENT
??_7facet@locale@std@@6B@ DD FLAT:??_R4facet@locale@std@@6B@ ; std::locale::facet::`vftable'
        DD      FLAT:??_Efacet@locale@std@@MAEPAXI@Z
        DD      FLAT:?_Incref@facet@locale@std@@UAEXXZ
        DD      FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
CONST   ENDS
;       COMDAT ??_7_Facet_base@std@@6B@
CONST   SEGMENT
??_7_Facet_base@std@@6B@ DD FLAT:??_R4_Facet_base@std@@6B@ ; std::_Facet_base::`vftable'
        DD      FLAT:??_E_Facet_base@std@@UAEPAXI@Z
        DD      FLAT:__purecall
        DD      FLAT:__purecall
CONST   ENDS
;       COMDAT ??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@
CONST   SEGMENT
??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@ DB 'bad locale name', 00H ; `string'
CONST   ENDS
;       COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
        DD      FLAT:??_R0?AVexception@std@@@8
        DD      00H
        DD      0ffffffffH
        ORG $+4
        DD      0cH
        DD      FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x ENDS
;       COMDAT ??_R0?AVexception@std@@@8
data$r  SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@    ; std::exception `RTTI Type Descriptor'
        DD      00H
        DB      '.?AVexception@std@@', 00H
data$r  ENDS
;       COMDAT __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
xdata$x SEGMENT
__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12 DD 00H
        DD      FLAT:??_R0?AVruntime_error@std@@@8
        DD      00H
        DD      0ffffffffH
        ORG $+4
        DD      0cH
        DD      FLAT:??0runtime_error@std@@QAE@ABV01@@Z
xdata$x ENDS
;       COMDAT ??_R0?AVruntime_error@std@@@8
data$r  SEGMENT
??_R0?AVruntime_error@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::runtime_error `RTTI Type Descriptor'
        DD      00H
        DB      '.?AVruntime_error@std@@', 00H
data$r  ENDS
;       COMDAT __CTA2?AVruntime_error@std@@
xdata$x SEGMENT
__CTA2?AVruntime_error@std@@ DD 02H
        DD      FLAT:__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
        DD      FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x ENDS
;       COMDAT __TI2?AVruntime_error@std@@
xdata$x SEGMENT
__TI2?AVruntime_error@std@@ DD 00H
        DD      FLAT:??1runtime_error@std@@UAE@XZ
        DD      00H
        DD      FLAT:__CTA2?AVruntime_error@std@@
xdata$x ENDS
;       COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST   SEGMENT
??_C@_08EPJLHIJG@bad?5cast?$AA@ DB 'bad cast', 00H      ; `string'
CONST   ENDS
;       COMDAT ??_7bad_cast@std@@6B@
CONST   SEGMENT
??_7bad_cast@std@@6B@ DD FLAT:??_R4bad_cast@std@@6B@    ; std::bad_cast::`vftable'
        DD      FLAT:??_Ebad_cast@std@@UAEPAXI@Z
        DD      FLAT:?what@exception@std@@UBEPBDXZ
CONST   ENDS
;       COMDAT ??_7runtime_error@std@@6B@
CONST   SEGMENT
??_7runtime_error@std@@6B@ DD FLAT:??_R4runtime_error@std@@6B@ ; std::runtime_error::`vftable'
        DD      FLAT:??_Eruntime_error@std@@UAEPAXI@Z
        DD      FLAT:?what@exception@std@@UBEPBDXZ
CONST   ENDS
;       COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
CONST   SEGMENT
?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB DD 0ffffffffH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
CONST   ENDS
;       COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception?$AA@
CONST   SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception?$AA@ DB 'Unknown exception', 00H ; `string'
CONST   ENDS
;       COMDAT ??_7exception@std@@6B@
CONST   SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@  ; std::exception::`vftable'
        DD      FLAT:??_Eexception@std@@UAEPAXI@Z
        DD      FLAT:?what@exception@std@@UBEPBDXZ
CONST   ENDS
;       COMDAT xdata$x
xdata$x SEGMENT
__catchsym$??$_Construct@PAD@?$vector@DV?$allocator@D@std@@@std@@QAEXPAD0Uforward_iterator_tag@1@@Z$2 DD 00H
        DD      00H
        DD      00H
        DD      FLAT:__catch$??$_Construct@PAD@?$vector@DV?$allocator@D@std@@@std@@QAEXPAD0Uforward_iterator_tag@1@@Z$0
__unwindtable$??$_Construct@PAD@?$vector@DV?$allocator@D@std@@@std@@QAEXPAD0Uforward_iterator_tag@1@@Z DD 0ffffffffH
        DD      00H
        DD      0ffffffffH
        DD      00H
__tryblocktable$??$_Construct@PAD@?$vector@DV?$allocator@D@std@@@std@@QAEXPAD0Uforward_iterator_tag@1@@Z DD 00H
        DD      00H
        DD      01H
        DD      01H
        DD      FLAT:__catchsym$??$_Construct@PAD@?$vector@DV?$allocator@D@std@@@std@@QAEXPAD0Uforward_iterator_tag@1@@Z$2
__ehfuncinfo$??$_Construct@PAD@?$vector@DV?$allocator@D@std@@@std@@QAEXPAD0Uforward_iterator_tag@1@@Z DD 019930522H
        DD      02H
        DD      FLAT:__unwindtable$??$_Construct@PAD@?$vector@DV?$allocator@D@std@@@std@@QAEXPAD0Uforward_iterator_tag@1@@Z
        DD      01H
        DD      FLAT:__tryblocktable$??$_Construct@PAD@?$vector@DV?$allocator@D@std@@@std@@QAEXPAD0Uforward_iterator_tag@1@@Z
        DD      2 DUP(00H)
        DD      00H
        DD      00H
xdata$x ENDS
;       COMDAT xdata$x
xdata$x SEGMENT
__catchsym$??$_Construct@PBD@?$vector@DV?$allocator@D@std@@@std@@QAEXPBD0Uforward_iterator_tag@1@@Z$2 DD 00H
        DD      00H
        DD      00H
        DD      FLAT:__catch$??$_Construct@PBD@?$vector@DV?$allocator@D@std@@@std@@QAEXPBD0Uforward_iterator_tag@1@@Z$0
__unwindtable$??$_Construct@PBD@?$vector@DV?$allocator@D@std@@@std@@QAEXPBD0Uforward_iterator_tag@1@@Z DD 0ffffffffH
        DD      00H
        DD      0ffffffffH
        DD      00H
__tryblocktable$??$_Construct@PBD@?$vector@DV?$allocator@D@std@@@std@@QAEXPBD0Uforward_iterator_tag@1@@Z DD 00H
        DD      00H
        DD      01H
        DD      01H
        DD      FLAT:__catchsym$??$_Construct@PBD@?$vector@DV?$allocator@D@std@@@std@@QAEXPBD0Uforward_iterator_tag@1@@Z$2
__ehfuncinfo$??$_Construct@PBD@?$vector@DV?$allocator@D@std@@@std@@QAEXPBD0Uforward_iterator_tag@1@@Z DD 019930522H
        DD      02H
        DD      FLAT:__unwindtable$??$_Construct@PBD@?$vector@DV?$allocator@D@std@@@std@@QAEXPBD0Uforward_iterator_tag@1@@Z
        DD      01H
        DD      FLAT:__tryblocktable$??$_Construct@PBD@?$vector@DV?$allocator@D@std@@@std@@QAEXPBD0Uforward_iterator_tag@1@@Z
        DD      2 DUP(00H)
        DD      00H
        DD      00H
xdata$x ENDS
;       COMDAT xdata$x
xdata$x SEGMENT
__catchsym$??$_Uninit_alloc_fill_n1@PAIIV?$allocator@I@std@@U?$integral_constant@_N$0A@@2@@std@@YAXPAIIPBIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U?$integral_constant@_N$0A@@0@@Z$2 DD 00H
        DD      00H
        DD      00H
        DD      FLAT:__catch$??$_Uninit_alloc_fill_n1@PAIIV?$allocator@I@std@@U?$integral_constant@_N$0A@@2@@std@@YAXPAIIPBIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U?$integral_constant@_N$0A@@0@@Z$0
__unwindtable$??$_Uninit_alloc_fill_n1@PAIIV?$allocator@I@std@@U?$integral_constant@_N$0A@@2@@std@@YAXPAIIPBIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U?$integral_constant@_N$0A@@0@@Z DD 0ffffffffH
        DD      00H
        DD      0ffffffffH
        DD      00H
__tryblocktable$??$_Uninit_alloc_fill_n1@PAIIV?$allocator@I@std@@U?$integral_constant@_N$0A@@2@@std@@YAXPAIIPBIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U?$integral_constant@_N$0A@@0@@Z DD 00H
        DD      00H
        DD      01H
        DD      01H
        DD      FLAT:__catchsym$??$_Uninit_alloc_fill_n1@PAIIV?$allocator@I@std@@U?$integral_constant@_N$0A@@2@@std@@YAXPAIIPBIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U?$integral_constant@_N$0A@@0@@Z$2
__ehfuncinfo$??$_Uninit_alloc_fill_n1@PAIIV?$allocator@I@std@@U?$integral_constant@_N$0A@@2@@std@@YAXPAIIPBIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U?$integral_constant@_N$0A@@0@@Z DD 019930522H
        DD      02H
        DD      FLAT:__unwindtable$??$_Uninit_alloc_fill_n1@PAIIV?$allocator@I@std@@U?$integral_constant@_N$0A@@2@@std@@YAXPAIIPBIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U?$integral_constant@_N$0A@@0@@Z
        DD      01H
        DD      FLAT:__tryblocktable$??$_Uninit_alloc_fill_n1@PAIIV?$allocator@I@std@@U?$integral_constant@_N$0A@@2@@std@@YAXPAIIPBIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U?$integral_constant@_N$0A@@0@@Z
        DD      2 DUP(00H)
        DD      00H
        DD      00H
xdata$x ENDS
;       COMDAT xdata$x
xdata$x SEGMENT
__catchsym$?_Begin_assert_group@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Node_base@2@_N@Z$2 DD 00H
        DD      00H
        DD      00H
        DD      FLAT:__catch$?_Begin_assert_group@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Node_base@2@_N@Z$0
__unwindtable$?_Begin_assert_group@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Node_base@2@_N@Z DD 0ffffffffH
        DD      00H
        DD      0ffffffffH
        DD      00H
__tryblocktable$?_Begin_assert_group@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Node_base@2@_N@Z DD 00H
        DD      00H
        DD      01H
        DD      01H
        DD      FLAT:__catchsym$?_Begin_assert_group@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Node_base@2@_N@Z$2
__ehfuncinfo$?_Begin_assert_group@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Node_base@2@_N@Z DD 019930522H
        DD      02H
        DD      FLAT:__unwindtable$?_Begin_assert_group@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Node_base@2@_N@Z
        DD      01H
        DD      FLAT:__tryblocktable$?_Begin_assert_group@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Node_base@2@_N@Z
        DD      2 DUP(00H)
        DD      00H
        DD      00H
xdata$x ENDS
;       COMDAT xdata$x
xdata$x SEGMENT
__catchsym$?_Compile@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Root_node@2@XZ$2 DD 00H
        DD      00H
        DD      00H
        DD      FLAT:__catch$?_Compile@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Root_node@2@XZ$0
__unwindtable$?_Compile@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Root_node@2@XZ DD 0ffffffffH
        DD      00H
        DD      0ffffffffH
        DD      00H
__tryblocktable$?_Compile@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Root_node@2@XZ DD 00H
        DD      00H
        DD      01H
        DD      01H
        DD      FLAT:__catchsym$?_Compile@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Root_node@2@XZ$2
__ehfuncinfo$?_Compile@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Root_node@2@XZ DD 019930522H
        DD      02H
        DD      FLAT:__unwindtable$?_Compile@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Root_node@2@XZ
        DD      01H
        DD      FLAT:__tryblocktable$?_Compile@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Root_node@2@XZ
        DD      2 DUP(00H)
        DD      00H
        DD      00H
xdata$x ENDS
;       COMDAT xdata$x
xdata$x SEGMENT
__catchsym$?_Reallocate@?$vector@IV?$allocator@_N@std@@@std@@IAEXI@Z$2 DD 00H
        DD      00H
        DD      00H
        DD      FLAT:__catch$?_Reallocate@?$vector@IV?$allocator@_N@std@@@std@@IAEXI@Z$0
__unwindtable$?_Reallocate@?$vector@IV?$allocator@_N@std@@@std@@IAEXI@Z DD 0ffffffffH
        DD      00H
        DD      0ffffffffH
        DD      00H
__tryblocktable$?_Reallocate@?$vector@IV?$allocator@_N@std@@@std@@IAEXI@Z DD 00H
        DD      00H
        DD      01H
        DD      01H
        DD      FLAT:__catchsym$?_Reallocate@?$vector@IV?$allocator@_N@std@@@std@@IAEXI@Z$2
__ehfuncinfo$?_Reallocate@?$vector@IV?$allocator@_N@std@@@std@@IAEXI@Z DD 019930522H
        DD      02H
        DD      FLAT:__unwindtable$?_Reallocate@?$vector@IV?$allocator@_N@std@@@std@@IAEXI@Z
        DD      01H
        DD      FLAT:__tryblocktable$?_Reallocate@?$vector@IV?$allocator@_N@std@@@std@@IAEXI@Z
        DD      2 DUP(00H)
        DD      00H
        DD      00H
xdata$x ENDS
;       COMDAT xdata$x
xdata$x SEGMENT
__catchsym$?resize@?$vector@IV?$allocator@_N@std@@@std@@QAEXIABI@Z$2 DD 00H
        DD      00H
        DD      00H
        DD      FLAT:__catch$?resize@?$vector@IV?$allocator@_N@std@@@std@@QAEXIABI@Z$0
__unwindtable$?resize@?$vector@IV?$allocator@_N@std@@@std@@QAEXIABI@Z DD 0ffffffffH
        DD      00H
        DD      0ffffffffH
        DD      00H
__tryblocktable$?resize@?$vector@IV?$allocator@_N@std@@@std@@QAEXIABI@Z DD 00H
        DD      00H
        DD      01H
        DD      01H
        DD      FLAT:__catchsym$?resize@?$vector@IV?$allocator@_N@std@@@std@@QAEXIABI@Z$2
__ehfuncinfo$?resize@?$vector@IV?$allocator@_N@std@@@std@@QAEXIABI@Z DD 019930522H
        DD      02H
        DD      FLAT:__unwindtable$?resize@?$vector@IV?$allocator@_N@std@@@std@@QAEXIABI@Z
        DD      01H
        DD      FLAT:__tryblocktable$?resize@?$vector@IV?$allocator@_N@std@@@std@@QAEXIABI@Z
        DD      2 DUP(00H)
        DD      00H
        DD      00H
xdata$x ENDS
;       COMDAT xdata$x
xdata$x SEGMENT
__catchsym$?_Construct_n@?$vector@IV?$allocator@_N@std@@@std@@QAEXIPBI@Z$2 DD 00H
        DD      00H
        DD      00H
        DD      FLAT:__catch$?_Construct_n@?$vector@IV?$allocator@_N@std@@@std@@QAEXIPBI@Z$0
__unwindtable$?_Construct_n@?$vector@IV?$allocator@_N@std@@@std@@QAEXIPBI@Z DD 0ffffffffH
        DD      00H
        DD      0ffffffffH
        DD      00H
__tryblocktable$?_Construct_n@?$vector@IV?$allocator@_N@std@@@std@@QAEXIPBI@Z DD 00H
        DD      00H
        DD      01H
        DD      01H
        DD      FLAT:__catchsym$?_Construct_n@?$vector@IV?$allocator@_N@std@@@std@@QAEXIPBI@Z$2
__ehfuncinfo$?_Construct_n@?$vector@IV?$allocator@_N@std@@@std@@QAEXIPBI@Z DD 019930522H
        DD      02H
        DD      FLAT:__unwindtable$?_Construct_n@?$vector@IV?$allocator@_N@std@@@std@@QAEXIPBI@Z
        DD      01H
        DD      FLAT:__tryblocktable$?_Construct_n@?$vector@IV?$allocator@_N@std@@@std@@QAEXIPBI@Z
        DD      2 DUP(00H)
        DD      00H
        DD      00H
xdata$x ENDS
;       COMDAT xdata$x
xdata$x SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 00H
        DD      00H
        DD      00H
        DD      FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 00H
        DD      00H
        DD      00H
        DD      FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
        DD      00H
        DD      0ffffffffH
        DD      00H
        DD      01H
        DD      00H
        DD      01H
        DD      00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
        DD      04H
        DD      FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
        DD      02H
        DD      FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
        DD      2 DUP(00H)
        DD      00H
        DD      00H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
        DD      02H
        DD      03H
        DD      01H
        DD      FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
        DD      00H
        DD      00H
        DD      03H
        DD      01H
        DD      FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ??$_Copy_memmove@PADPAD@std@@YAPADPAD00@Z
_TEXT   SEGMENT
__Last_ch$ = -16                                        ; size = 4
__Count$ = -12                                      ; size = 4
__Dest_ch$ = -8                               ; size = 4
__First_ch$ = -4                                        ; size = 4
__First$ = 8                                            ; size = 4
__Last$ = 12                                            ; size = 4
__Dest$ = 16                                            ; size = 4
??$_Copy_memmove@PADPAD@std@@YAPADPAD00@Z PROC      ; std::_Copy_memmove<char *,char *>, COMDAT

; 2251 :        {     // implement copy-like function as memmove

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 10   sub         esp, 16                        ; 00000010H

; 2252 :        const char * const _First_ch = reinterpret_cast<const char *>(_First);

  00006 8b 45 08   mov         eax, DWORD PTR __First$[ebp]
  00009 89 45 fc   mov         DWORD PTR __First_ch$[ebp], eax

; 2253 :        const char * const _Last_ch = reinterpret_cast<const char *>(_Last);

  0000c 8b 4d 0c   mov         ecx, DWORD PTR __Last$[ebp]
  0000f 89 4d f0   mov         DWORD PTR __Last_ch$[ebp], ecx

; 2254 :        char * const _Dest_ch = reinterpret_cast<char *>(_Dest);

  00012 8b 55 10   mov         edx, DWORD PTR __Dest$[ebp]
  00015 89 55 f8   mov         DWORD PTR __Dest_ch$[ebp], edx

; 2255 :        const size_t _Count = _Last_ch - _First_ch;

  00018 8b 45 f0   mov         eax, DWORD PTR __Last_ch$[ebp]
  0001b 2b 45 fc   sub         eax, DWORD PTR __First_ch$[ebp]
  0001e 89 45 f4   mov         DWORD PTR __Count$[ebp], eax

; 2256 :        _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021 8b 4d f4   mov         ecx, DWORD PTR __Count$[ebp]
  00024 51                 push    ecx
  00025 8b 55 fc   mov         edx, DWORD PTR __First_ch$[ebp]
  00028 52                 push    edx
  00029 8b 45 f8   mov         eax, DWORD PTR __Dest_ch$[ebp]
  0002c 50                 push    eax
  0002d e8 00 00 00 00     call    _memmove
  00032 83 c4 0c   add         esp, 12                        ; 0000000cH

; 2257 :        return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

  00035 8b 45 f8   mov         eax, DWORD PTR __Dest_ch$[ebp]
  00038 03 45 f4   add         eax, DWORD PTR __Count$[ebp]

; 2258 :        }

  0003b 8b e5        mov         esp, ebp
  0003d 5d                 pop     ebp
  0003e c3                 ret     0
??$_Copy_memmove@PADPAD@std@@YAPADPAD00@Z ENDP      ; std::_Copy_memmove<char *,char *>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ??$_Copy_memmove@PBDPAD@std@@YAPADPBD0PAD@Z
_TEXT   SEGMENT
__Last_ch$ = -16                                        ; size = 4
__Count$ = -12                                      ; size = 4
__Dest_ch$ = -8                               ; size = 4
__First_ch$ = -4                                        ; size = 4
__First$ = 8                                            ; size = 4
__Last$ = 12                                            ; size = 4
__Dest$ = 16                                            ; size = 4
??$_Copy_memmove@PBDPAD@std@@YAPADPBD0PAD@Z PROC        ; std::_Copy_memmove<char const *,char *>, COMDAT

; 2251 :        {     // implement copy-like function as memmove

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 10   sub         esp, 16                        ; 00000010H

; 2252 :        const char * const _First_ch = reinterpret_cast<const char *>(_First);

  00006 8b 45 08   mov         eax, DWORD PTR __First$[ebp]
  00009 89 45 fc   mov         DWORD PTR __First_ch$[ebp], eax

; 2253 :        const char * const _Last_ch = reinterpret_cast<const char *>(_Last);

  0000c 8b 4d 0c   mov         ecx, DWORD PTR __Last$[ebp]
  0000f 89 4d f0   mov         DWORD PTR __Last_ch$[ebp], ecx

; 2254 :        char * const _Dest_ch = reinterpret_cast<char *>(_Dest);

  00012 8b 55 10   mov         edx, DWORD PTR __Dest$[ebp]
  00015 89 55 f8   mov         DWORD PTR __Dest_ch$[ebp], edx

; 2255 :        const size_t _Count = _Last_ch - _First_ch;

  00018 8b 45 f0   mov         eax, DWORD PTR __Last_ch$[ebp]
  0001b 2b 45 fc   sub         eax, DWORD PTR __First_ch$[ebp]
  0001e 89 45 f4   mov         DWORD PTR __Count$[ebp], eax

; 2256 :        _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021 8b 4d f4   mov         ecx, DWORD PTR __Count$[ebp]
  00024 51                 push    ecx
  00025 8b 55 fc   mov         edx, DWORD PTR __First_ch$[ebp]
  00028 52                 push    edx
  00029 8b 45 f8   mov         eax, DWORD PTR __Dest_ch$[ebp]
  0002c 50                 push    eax
  0002d e8 00 00 00 00     call    _memmove
  00032 83 c4 0c   add         esp, 12                        ; 0000000cH

; 2257 :        return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

  00035 8b 45 f8   mov         eax, DWORD PTR __Dest_ch$[ebp]
  00038 03 45 f4   add         eax, DWORD PTR __Count$[ebp]

; 2258 :        }

  0003b 8b e5        mov         esp, ebp
  0003d 5d                 pop     ebp
  0003e c3                 ret     0
??$_Copy_memmove@PBDPAD@std@@YAPADPBD0PAD@Z ENDP        ; std::_Copy_memmove<char const *,char *>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;       COMDAT ??$_Uninitialized_copy_al_unchecked1@DD@std@@YAPADPAD00AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@U_Really_trivial_ptr_iterator_tag@0@@Z
_TEXT   SEGMENT
__First$ = 8                                            ; size = 4
__Last$ = 12                                            ; size = 4
__Dest$ = 16                                            ; size = 4
___formal$ = 20                               ; size = 4
___formal$ = 24                               ; size = 1
??$_Uninitialized_copy_al_unchecked1@DD@std@@YAPADPAD00AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@U_Really_trivial_ptr_iterator_tag@0@@Z PROC ; std::_Uninitialized_copy_al_unchecked1<char,char>, COMDAT

; 284  :        {     // copy [_First, _Last) to raw _Dest, using std::allocator, memmove optimization

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 285  :        return (_Copy_memmove(_First, _Last, _Dest));

  00003 8b 45 10   mov         eax, DWORD PTR __Dest$[ebp]
  00006 50                 push    eax
  00007 8b 4d 0c   mov         ecx, DWORD PTR __Last$[ebp]
  0000a 51                 push    ecx
  0000b 8b 55 08   mov         edx, DWORD PTR __First$[ebp]
  0000e 52                 push    edx
  0000f e8 00 00 00 00     call    ??$_Copy_memmove@PADPAD@std@@YAPADPAD00@Z ; std::_Copy_memmove<char *,char *>
  00014 83 c4 0c   add         esp, 12                        ; 0000000cH

; 286  :        }

  00017 5d                 pop     ebp
  00018 c3                 ret     0
??$_Uninitialized_copy_al_unchecked1@DD@std@@YAPADPAD00AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@U_Really_trivial_ptr_iterator_tag@0@@Z ENDP ; std::_Uninitialized_copy_al_unchecked1<char,char>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ??$_Ptr_copy_cat@DD@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAD0@Z
_TEXT   SEGMENT
___$ReturnUdt$ = 8                                  ; size = 4
___formal$ = 12                               ; size = 4
___formal$ = 16                               ; size = 4
??$_Ptr_copy_cat@DD@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAD0@Z PROC ; std::_Ptr_copy_cat<char,char>, COMDAT

; 708  :        {     // return pointer copy optimization category for pointers

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 709  :        return {};

  00003 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]

; 710  :        }

  00006 5d                 pop     ebp
  00007 c3                 ret     0
??$_Ptr_copy_cat@DD@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAD0@Z ENDP ; std::_Ptr_copy_cat<char,char>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;       COMDAT ??$_Uninitialized_copy_al_unchecked1@$$CBDD@std@@YAPADPBD0PADAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@U_Really_trivial_ptr_iterator_tag@0@@Z
_TEXT   SEGMENT
__First$ = 8                                            ; size = 4
__Last$ = 12                                            ; size = 4
__Dest$ = 16                                            ; size = 4
___formal$ = 20                               ; size = 4
___formal$ = 24                               ; size = 1
??$_Uninitialized_copy_al_unchecked1@$$CBDD@std@@YAPADPBD0PADAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@U_Really_trivial_ptr_iterator_tag@0@@Z PROC ; std::_Uninitialized_copy_al_unchecked1<char const ,char>, COMDAT

; 284  :        {     // copy [_First, _Last) to raw _Dest, using std::allocator, memmove optimization

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 285  :        return (_Copy_memmove(_First, _Last, _Dest));

  00003 8b 45 10   mov         eax, DWORD PTR __Dest$[ebp]
  00006 50                 push    eax
  00007 8b 4d 0c   mov         ecx, DWORD PTR __Last$[ebp]
  0000a 51                 push    ecx
  0000b 8b 55 08   mov         edx, DWORD PTR __First$[ebp]
  0000e 52                 push    edx
  0000f e8 00 00 00 00     call    ??$_Copy_memmove@PBDPAD@std@@YAPADPBD0PAD@Z ; std::_Copy_memmove<char const *,char *>
  00014 83 c4 0c   add         esp, 12                        ; 0000000cH

; 286  :        }

  00017 5d                 pop     ebp
  00018 c3                 ret     0
??$_Uninitialized_copy_al_unchecked1@$$CBDD@std@@YAPADPBD0PADAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@U_Really_trivial_ptr_iterator_tag@0@@Z ENDP ; std::_Uninitialized_copy_al_unchecked1<char const ,char>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ??$_Ptr_copy_cat@$$CBDD@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQBDABQAD@Z
_TEXT   SEGMENT
___$ReturnUdt$ = 8                                  ; size = 4
___formal$ = 12                               ; size = 4
___formal$ = 16                               ; size = 4
??$_Ptr_copy_cat@$$CBDD@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQBDABQAD@Z PROC ; std::_Ptr_copy_cat<char const ,char>, COMDAT

; 708  :        {     // return pointer copy optimization category for pointers

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 709  :        return {};

  00003 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]

; 710  :        }

  00006 5d                 pop     ebp
  00007 c3                 ret     0
??$_Ptr_copy_cat@$$CBDD@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQBDABQAD@Z ENDP ; std::_Ptr_copy_cat<char const ,char>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;       COMDAT ??$_Uninitialized_copy_al_unchecked@PADPADU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAPADPAD00AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z
_TEXT   SEGMENT
$T1 = -1                                                ; size = 1
__First$ = 8                                            ; size = 4
__Last$ = 12                                            ; size = 4
__Dest$ = 16                                            ; size = 4
__Al$ = 20                                          ; size = 4
??$_Uninitialized_copy_al_unchecked@PADPADU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAPADPAD00AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z PROC ; std::_Uninitialized_copy_al_unchecked<char *,char *,std::_Wrap_alloc<std::allocator<char> > >, COMDAT

; 293  :        {     // copy [_First, _Last) to raw _Dest, using _Al, choose optimization

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx

; 294  :        return (_Uninitialized_copy_al_unchecked1(_First, _Last, _Dest, _Al,

  00004 8d 45 10   lea         eax, DWORD PTR __Dest$[ebp]
  00007 50                 push    eax
  00008 8d 4d 08   lea         ecx, DWORD PTR __First$[ebp]
  0000b 51                 push    ecx
  0000c 8d 55 ff   lea         edx, DWORD PTR $T1[ebp]
  0000f 52                 push    edx
  00010 e8 00 00 00 00     call    ??$_Ptr_copy_cat@DD@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAD0@Z ; std::_Ptr_copy_cat<char,char>
  00015 83 c4 0c   add         esp, 12                        ; 0000000cH
  00018 8a 00        mov         al, BYTE PTR [eax]
  0001a 0f b6 c8   movzx       ecx, al
  0001d 51                 push    ecx
  0001e 8b 55 14   mov         edx, DWORD PTR __Al$[ebp]
  00021 52                 push    edx
  00022 8b 45 10   mov         eax, DWORD PTR __Dest$[ebp]
  00025 50                 push    eax
  00026 8b 4d 0c   mov         ecx, DWORD PTR __Last$[ebp]
  00029 51                 push    ecx
  0002a 8b 55 08   mov         edx, DWORD PTR __First$[ebp]
  0002d 52                 push    edx
  0002e e8 00 00 00 00     call    ??$_Uninitialized_copy_al_unchecked1@DD@std@@YAPADPAD00AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@U_Really_trivial_ptr_iterator_tag@0@@Z ; std::_Uninitialized_copy_al_unchecked1<char,char>
  00033 83 c4 14   add         esp, 20                        ; 00000014H

; 295  :              _Ptr_copy_cat(_First, _Dest)));
; 296  :        }

  00036 8b e5        mov         esp, ebp
  00038 5d                 pop     ebp
  00039 c3                 ret     0
??$_Uninitialized_copy_al_unchecked@PADPADU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAPADPAD00AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z ENDP ; std::_Uninitialized_copy_al_unchecked<char *,char *,std::_Wrap_alloc<std::allocator<char> > >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ??$_Rechecked@PADPAD@std@@YAAAPADAAPADPAD@Z
_TEXT   SEGMENT
__Dest$ = 8                                   ; size = 4
__Src$ = 12                                   ; size = 4
??$_Rechecked@PADPAD@std@@YAAAPADAAPADPAD@Z PROC        ; std::_Rechecked<char *,char *>, COMDAT

; 465  :        {     // reset checked from unchecked, generic

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 466  :        _Dest = _Src;

  00003 8b 45 08   mov         eax, DWORD PTR __Dest$[ebp]
  00006 8b 4d 0c   mov         ecx, DWORD PTR __Src$[ebp]
  00009 89 08        mov         DWORD PTR [eax], ecx

; 467  :        return (_Dest);

  0000b 8b 45 08   mov         eax, DWORD PTR __Dest$[ebp]

; 468  :        }

  0000e 5d                 pop     ebp
  0000f c3                 ret     0
??$_Rechecked@PADPAD@std@@YAAAPADAAPADPAD@Z ENDP        ; std::_Rechecked<char *,char *>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;       COMDAT ??$_Uninitialized_copy_al_unchecked@PBDPADU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAPADPBD0PADAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z
_TEXT   SEGMENT
$T1 = -1                                                ; size = 1
__First$ = 8                                            ; size = 4
__Last$ = 12                                            ; size = 4
__Dest$ = 16                                            ; size = 4
__Al$ = 20                                          ; size = 4
??$_Uninitialized_copy_al_unchecked@PBDPADU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAPADPBD0PADAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z PROC ; std::_Uninitialized_copy_al_unchecked<char const *,char *,std::_Wrap_alloc<std::allocator<char> > >, COMDAT

; 293  :        {     // copy [_First, _Last) to raw _Dest, using _Al, choose optimization

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx

; 294  :        return (_Uninitialized_copy_al_unchecked1(_First, _Last, _Dest, _Al,

  00004 8d 45 10   lea         eax, DWORD PTR __Dest$[ebp]
  00007 50                 push    eax
  00008 8d 4d 08   lea         ecx, DWORD PTR __First$[ebp]
  0000b 51                 push    ecx
  0000c 8d 55 ff   lea         edx, DWORD PTR $T1[ebp]
  0000f 52                 push    edx
  00010 e8 00 00 00 00     call    ??$_Ptr_copy_cat@$$CBDD@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQBDABQAD@Z ; std::_Ptr_copy_cat<char const ,char>
  00015 83 c4 0c   add         esp, 12                        ; 0000000cH
  00018 8a 00        mov         al, BYTE PTR [eax]
  0001a 0f b6 c8   movzx       ecx, al
  0001d 51                 push    ecx
  0001e 8b 55 14   mov         edx, DWORD PTR __Al$[ebp]
  00021 52                 push    edx
  00022 8b 45 10   mov         eax, DWORD PTR __Dest$[ebp]
  00025 50                 push    eax
  00026 8b 4d 0c   mov         ecx, DWORD PTR __Last$[ebp]
  00029 51                 push    ecx
  0002a 8b 55 08   mov         edx, DWORD PTR __First$[ebp]
  0002d 52                 push    edx
  0002e e8 00 00 00 00     call    ??$_Uninitialized_copy_al_unchecked1@$$CBDD@std@@YAPADPBD0PADAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@U_Really_trivial_ptr_iterator_tag@0@@Z ; std::_Uninitialized_copy_al_unchecked1<char const ,char>
  00033 83 c4 14   add         esp, 20                        ; 00000014H

; 295  :              _Ptr_copy_cat(_First, _Dest)));
; 296  :        }

  00036 8b e5        mov         esp, ebp
  00038 5d                 pop     ebp
  00039 c3                 ret     0
??$_Uninitialized_copy_al_unchecked@PBDPADU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAPADPBD0PADAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z ENDP ; std::_Uninitialized_copy_al_unchecked<char const *,char *,std::_Wrap_alloc<std::allocator<char> > >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;       COMDAT ??$_Uninitialized_copy@PADPADU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAPADPAD00AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z
_TEXT   SEGMENT
__First$ = 8                                            ; size = 4
__Last$ = 12                                            ; size = 4
__Dest$ = 16                                            ; size = 4
__Al$ = 20                                          ; size = 4
??$_Uninitialized_copy@PADPADU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAPADPAD00AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z PROC ; std::_Uninitialized_copy<char *,char *,std::_Wrap_alloc<std::allocator<char> > >, COMDAT

; 303  :        {     // copy [_First, _Last) to raw _Dest, using _Al

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 304  :              // note: only called internally from elsewhere in the STL, debug checks
; 305  :              // and deprecation warnings omitted
; 306  :        return (_Rechecked(_Dest,

  00003 8b 45 14   mov         eax, DWORD PTR __Al$[ebp]
  00006 50                 push    eax
  00007 8b 4d 10   mov         ecx, DWORD PTR __Dest$[ebp]
  0000a 51                 push    ecx
  0000b e8 00 00 00 00     call    ??$_Unchecked@PAD@std@@YAPADPAD@Z ; std::_Unchecked<char *>
  00010 83 c4 04   add         esp, 4
  00013 50                 push    eax
  00014 8b 55 0c   mov         edx, DWORD PTR __Last$[ebp]
  00017 52                 push    edx
  00018 e8 00 00 00 00     call    ??$_Unchecked@PAD@std@@YAPADPAD@Z ; std::_Unchecked<char *>
  0001d 83 c4 04   add         esp, 4
  00020 50                 push    eax
  00021 8b 45 08   mov         eax, DWORD PTR __First$[ebp]
  00024 50                 push    eax
  00025 e8 00 00 00 00     call    ??$_Unchecked@PAD@std@@YAPADPAD@Z ; std::_Unchecked<char *>
  0002a 83 c4 04   add         esp, 4
  0002d 50                 push    eax
  0002e e8 00 00 00 00     call    ??$_Uninitialized_copy_al_unchecked@PADPADU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAPADPAD00AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z ; std::_Uninitialized_copy_al_unchecked<char *,char *,std::_Wrap_alloc<std::allocator<char> > >
  00033 83 c4 10   add         esp, 16                        ; 00000010H
  00036 50                 push    eax
  00037 8d 4d 10   lea         ecx, DWORD PTR __Dest$[ebp]
  0003a 51                 push    ecx
  0003b e8 00 00 00 00     call    ??$_Rechecked@PADPAD@std@@YAAAPADAAPADPAD@Z ; std::_Rechecked<char *,char *>
  00040 83 c4 08   add         esp, 8
  00043 8b 00        mov         eax, DWORD PTR [eax]

; 307  :              _Uninitialized_copy_al_unchecked(_Unchecked(_First), _Unchecked(_Last),
; 308  :                  _Unchecked(_Dest), _Al)));
; 309  :        }

  00045 5d                 pop     ebp
  00046 c3                 ret     0
??$_Uninitialized_copy@PADPADU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAPADPAD00AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z ENDP ; std::_Uninitialized_copy<char *,char *,std::_Wrap_alloc<std::allocator<char> > >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ??$_Distance2@PADH@std@@YAXPAD0AAHUrandom_access_iterator_tag@0@@Z
_TEXT   SEGMENT
__First$ = 8                                            ; size = 4
__Last$ = 12                                            ; size = 4
__Off$ = 16                                   ; size = 4
___formal$ = 20                               ; size = 1
??$_Distance2@PADH@std@@YAXPAD0AAHUrandom_access_iterator_tag@0@@Z PROC ; std::_Distance2<char *,int>, COMDAT

; 1049 :        {     // add to _Off distance between random-access iterators

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 1050 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1051 :        if (_First != _Last)
; 1052 :              {   // check for null pointers
; 1053 :              _DEBUG_POINTER(_First);
; 1054 :              _DEBUG_POINTER(_Last);
; 1055 :              }
; 1056 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1057 :
; 1058 :        _Off += _Last - _First;

  00003 8b 45 0c   mov         eax, DWORD PTR __Last$[ebp]
  00006 2b 45 08   sub         eax, DWORD PTR __First$[ebp]
  00009 8b 4d 10   mov         ecx, DWORD PTR __Off$[ebp]
  0000c 03 01        add         eax, DWORD PTR [ecx]
  0000e 8b 55 10   mov         edx, DWORD PTR __Off$[ebp]
  00011 89 02        mov         DWORD PTR [edx], eax

; 1059 :        }

  00013 5d                 pop     ebp
  00014 c3                 ret     0
??$_Distance2@PADH@std@@YAXPAD0AAHUrandom_access_iterator_tag@0@@Z ENDP ; std::_Distance2<char *,int>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;       COMDAT ??$_Uninitialized_copy@PBDPADU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAPADPBD0PADAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z
_TEXT   SEGMENT
__First$ = 8                                            ; size = 4
__Last$ = 12                                            ; size = 4
__Dest$ = 16                                            ; size = 4
__Al$ = 20                                          ; size = 4
??$_Uninitialized_copy@PBDPADU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAPADPBD0PADAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z PROC ; std::_Uninitialized_copy<char const *,char *,std::_Wrap_alloc<std::allocator<char> > >, COMDAT

; 303  :        {     // copy [_First, _Last) to raw _Dest, using _Al

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 304  :              // note: only called internally from elsewhere in the STL, debug checks
; 305  :              // and deprecation warnings omitted
; 306  :        return (_Rechecked(_Dest,

  00003 8b 45 14   mov         eax, DWORD PTR __Al$[ebp]
  00006 50                 push    eax
  00007 8b 4d 10   mov         ecx, DWORD PTR __Dest$[ebp]
  0000a 51                 push    ecx
  0000b e8 00 00 00 00     call    ??$_Unchecked@PAD@std@@YAPADPAD@Z ; std::_Unchecked<char *>
  00010 83 c4 04   add         esp, 4
  00013 50                 push    eax
  00014 8b 55 0c   mov         edx, DWORD PTR __Last$[ebp]
  00017 52                 push    edx
  00018 e8 00 00 00 00     call    ??$_Unchecked@PBD@std@@YAPBDPBD@Z ; std::_Unchecked<char const *>
  0001d 83 c4 04   add         esp, 4
  00020 50                 push    eax
  00021 8b 45 08   mov         eax, DWORD PTR __First$[ebp]
  00024 50                 push    eax
  00025 e8 00 00 00 00     call    ??$_Unchecked@PBD@std@@YAPBDPBD@Z ; std::_Unchecked<char const *>
  0002a 83 c4 04   add         esp, 4
  0002d 50                 push    eax
  0002e e8 00 00 00 00     call    ??$_Uninitialized_copy_al_unchecked@PBDPADU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAPADPBD0PADAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z ; std::_Uninitialized_copy_al_unchecked<char const *,char *,std::_Wrap_alloc<std::allocator<char> > >
  00033 83 c4 10   add         esp, 16                        ; 00000010H
  00036 50                 push    eax
  00037 8d 4d 10   lea         ecx, DWORD PTR __Dest$[ebp]
  0003a 51                 push    ecx
  0003b e8 00 00 00 00     call    ??$_Rechecked@PADPAD@std@@YAAAPADAAPADPAD@Z ; std::_Rechecked<char *,char *>
  00040 83 c4 08   add         esp, 8
  00043 8b 00        mov         eax, DWORD PTR [eax]

; 307  :              _Uninitialized_copy_al_unchecked(_Unchecked(_First), _Unchecked(_Last),
; 308  :                  _Unchecked(_Dest), _Al)));
; 309  :        }

  00045 5d                 pop     ebp
  00046 c3                 ret     0
??$_Uninitialized_copy@PBDPADU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAPADPBD0PADAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z ENDP ; std::_Uninitialized_copy<char const *,char *,std::_Wrap_alloc<std::allocator<char> > >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ??$_Distance2@PBDH@std@@YAXPBD0AAHUrandom_access_iterator_tag@0@@Z
_TEXT   SEGMENT
__First$ = 8                                            ; size = 4
__Last$ = 12                                            ; size = 4
__Off$ = 16                                   ; size = 4
___formal$ = 20                               ; size = 1
??$_Distance2@PBDH@std@@YAXPBD0AAHUrandom_access_iterator_tag@0@@Z PROC ; std::_Distance2<char const *,int>, COMDAT

; 1049 :        {     // add to _Off distance between random-access iterators

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 1050 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1051 :        if (_First != _Last)
; 1052 :              {   // check for null pointers
; 1053 :              _DEBUG_POINTER(_First);
; 1054 :              _DEBUG_POINTER(_Last);
; 1055 :              }
; 1056 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1057 :
; 1058 :        _Off += _Last - _First;

  00003 8b 45 0c   mov         eax, DWORD PTR __Last$[ebp]
  00006 2b 45 08   sub         eax, DWORD PTR __First$[ebp]
  00009 8b 4d 10   mov         ecx, DWORD PTR __Off$[ebp]
  0000c 03 01        add         eax, DWORD PTR [ecx]
  0000e 8b 55 10   mov         edx, DWORD PTR __Off$[ebp]
  00011 89 02        mov         DWORD PTR [edx], eax

; 1059 :        }

  00013 5d                 pop     ebp
  00014 c3                 ret     0
??$_Distance2@PBDH@std@@YAXPBD0AAHUrandom_access_iterator_tag@0@@Z ENDP ; std::_Distance2<char const *,int>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;       COMDAT ??$destroy@D@?$allocator@D@std@@QAEXPAD@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Ptr$ = 8                                          ; size = 4
??$destroy@D@?$allocator@D@std@@QAEXPAD@Z PROC      ; std::allocator<char>::destroy<char>, COMDAT
; _this$ = ecx

; 643  :              {   // destroy object at _Ptr

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 644  :              _Ptr->~_Uty();
; 645  :              }

  00007 8b e5        mov         esp, ebp
  00009 5d                 pop     ebp
  0000a c2 04 00   ret         4
??$destroy@D@?$allocator@D@std@@QAEXPAD@Z ENDP      ; std::allocator<char>::destroy<char>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??$_Ucopy@PAD@?$vector@DV?$allocator@D@std@@@std@@IAEPADPAD00@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__First$ = 8                                            ; size = 4
__Last$ = 12                                            ; size = 4
__Ptr$ = 16                                   ; size = 4
??$_Ucopy@PAD@?$vector@DV?$allocator@D@std@@@std@@IAEPADPAD00@Z PROC ; std::vector<char,std::allocator<char> >::_Ucopy<char *>, COMDAT
; _this$ = ecx

; 1674 :              {   // copy initializing [_First, _Last), using allocator

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1675 :              return (_Uninitialized_copy(_First, _Last,

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Getal
  0000f 50                 push    eax
  00010 8b 45 10   mov         eax, DWORD PTR __Ptr$[ebp]
  00013 50                 push    eax
  00014 8b 4d 0c   mov         ecx, DWORD PTR __Last$[ebp]
  00017 51                 push    ecx
  00018 8b 55 08   mov         edx, DWORD PTR __First$[ebp]
  0001b 52                 push    edx
  0001c e8 00 00 00 00     call    ??$_Uninitialized_copy@PADPADU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAPADPAD00AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z ; std::_Uninitialized_copy<char *,char *,std::_Wrap_alloc<std::allocator<char> > >
  00021 83 c4 10   add         esp, 16                        ; 00000010H

; 1676 :                  _Ptr, this->_Getal()));
; 1677 :              }

  00024 8b e5        mov         esp, ebp
  00026 5d                 pop     ebp
  00027 c2 0c 00   ret         12           ; 0000000cH
??$_Ucopy@PAD@?$vector@DV?$allocator@D@std@@@std@@IAEPADPAD00@Z ENDP ; std::vector<char,std::allocator<char> >::_Ucopy<char *>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ??$distance@PAD@std@@YAHPAD0@Z
_TEXT   SEGMENT
__Off$ = -8                                   ; size = 4
$T1 = -1                                                ; size = 1
__First$ = 8                                            ; size = 4
__Last$ = 12                                            ; size = 4
??$distance@PAD@std@@YAHPAD0@Z PROC           ; std::distance<char *>, COMDAT

; 1064 :        {     // return distance between iterators

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8

; 1065 :        typename iterator_traits<_InIt>::difference_type _Off = 0;

  00006 c7 45 f8 00 00
        00 00          mov         DWORD PTR __Off$[ebp], 0

; 1066 :        _Distance2(_First, _Last, _Off, _Iter_cat(_First));

  0000d 8d 45 08   lea         eax, DWORD PTR __First$[ebp]
  00010 50                 push    eax
  00011 8d 4d ff   lea         ecx, DWORD PTR $T1[ebp]
  00014 51                 push    ecx
  00015 e8 00 00 00 00     call    ??$_Iter_cat@PAD@std@@YA?AUrandom_access_iterator_tag@0@ABQAD@Z ; std::_Iter_cat<char *>
  0001a 83 c4 08   add         esp, 8
  0001d 8a 10        mov         dl, BYTE PTR [eax]
  0001f 0f b6 c2   movzx       eax, dl
  00022 50                 push    eax
  00023 8d 4d f8   lea         ecx, DWORD PTR __Off$[ebp]
  00026 51                 push    ecx
  00027 8b 55 0c   mov         edx, DWORD PTR __Last$[ebp]
  0002a 52                 push    edx
  0002b 8b 45 08   mov         eax, DWORD PTR __First$[ebp]
  0002e 50                 push    eax
  0002f e8 00 00 00 00     call    ??$_Distance2@PADH@std@@YAXPAD0AAHUrandom_access_iterator_tag@0@@Z ; std::_Distance2<char *,int>
  00034 83 c4 10   add         esp, 16                        ; 00000010H

; 1067 :        return (_Off);

  00037 8b 45 f8   mov         eax, DWORD PTR __Off$[ebp]

; 1068 :        }

  0003a 8b e5        mov         esp, ebp
  0003c 5d                 pop     ebp
  0003d c3                 ret     0
??$distance@PAD@std@@YAHPAD0@Z ENDP           ; std::distance<char *>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??$_Ucopy@PBD@?$vector@DV?$allocator@D@std@@@std@@IAEPADPBD0PAD@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__First$ = 8                                            ; size = 4
__Last$ = 12                                            ; size = 4
__Ptr$ = 16                                   ; size = 4
??$_Ucopy@PBD@?$vector@DV?$allocator@D@std@@@std@@IAEPADPBD0PAD@Z PROC ; std::vector<char,std::allocator<char> >::_Ucopy<char const *>, COMDAT
; _this$ = ecx

; 1674 :              {   // copy initializing [_First, _Last), using allocator

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1675 :              return (_Uninitialized_copy(_First, _Last,

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Getal
  0000f 50                 push    eax
  00010 8b 45 10   mov         eax, DWORD PTR __Ptr$[ebp]
  00013 50                 push    eax
  00014 8b 4d 0c   mov         ecx, DWORD PTR __Last$[ebp]
  00017 51                 push    ecx
  00018 8b 55 08   mov         edx, DWORD PTR __First$[ebp]
  0001b 52                 push    edx
  0001c e8 00 00 00 00     call    ??$_Uninitialized_copy@PBDPADU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAPADPBD0PADAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z ; std::_Uninitialized_copy<char const *,char *,std::_Wrap_alloc<std::allocator<char> > >
  00021 83 c4 10   add         esp, 16                        ; 00000010H

; 1676 :                  _Ptr, this->_Getal()));
; 1677 :              }

  00024 8b e5        mov         esp, ebp
  00026 5d                 pop     ebp
  00027 c2 0c 00   ret         12           ; 0000000cH
??$_Ucopy@PBD@?$vector@DV?$allocator@D@std@@@std@@IAEPADPBD0PAD@Z ENDP ; std::vector<char,std::allocator<char> >::_Ucopy<char const *>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ??$distance@PBD@std@@YAHPBD0@Z
_TEXT   SEGMENT
__Off$ = -8                                   ; size = 4
$T1 = -1                                                ; size = 1
__First$ = 8                                            ; size = 4
__Last$ = 12                                            ; size = 4
??$distance@PBD@std@@YAHPBD0@Z PROC           ; std::distance<char const *>, COMDAT

; 1064 :        {     // return distance between iterators

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8

; 1065 :        typename iterator_traits<_InIt>::difference_type _Off = 0;

  00006 c7 45 f8 00 00
        00 00          mov         DWORD PTR __Off$[ebp], 0

; 1066 :        _Distance2(_First, _Last, _Off, _Iter_cat(_First));

  0000d 8d 45 08   lea         eax, DWORD PTR __First$[ebp]
  00010 50                 push    eax
  00011 8d 4d ff   lea         ecx, DWORD PTR $T1[ebp]
  00014 51                 push    ecx
  00015 e8 00 00 00 00     call    ??$_Iter_cat@PBD@std@@YA?AUrandom_access_iterator_tag@0@ABQBD@Z ; std::_Iter_cat<char const *>
  0001a 83 c4 08   add         esp, 8
  0001d 8a 10        mov         dl, BYTE PTR [eax]
  0001f 0f b6 c2   movzx       eax, dl
  00022 50                 push    eax
  00023 8d 4d f8   lea         ecx, DWORD PTR __Off$[ebp]
  00026 51                 push    ecx
  00027 8b 55 0c   mov         edx, DWORD PTR __Last$[ebp]
  0002a 52                 push    edx
  0002b 8b 45 08   mov         eax, DWORD PTR __First$[ebp]
  0002e 50                 push    eax
  0002f e8 00 00 00 00     call    ??$_Distance2@PBDH@std@@YAXPBD0AAHUrandom_access_iterator_tag@0@@Z ; std::_Distance2<char const *,int>
  00034 83 c4 10   add         esp, 16                        ; 00000010H

; 1067 :        return (_Off);

  00037 8b 45 f8   mov         eax, DWORD PTR __Off$[ebp]

; 1068 :        }

  0003a 8b e5        mov         esp, ebp
  0003c 5d                 pop     ebp
  0003d c3                 ret     0
??$distance@PBD@std@@YAHPBD0@Z ENDP           ; std::distance<char const *>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;       COMDAT ??$destroy@D@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAD@Z
_TEXT   SEGMENT
__Al$ = 8                                         ; size = 4
__Ptr$ = 12                                   ; size = 4
??$destroy@D@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char>, COMDAT

; 761  :              {   // destroy object at _Ptr

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 762  :              _Al.destroy(_Ptr);

  00003 8b 45 0c   mov         eax, DWORD PTR __Ptr$[ebp]
  00006 50                 push    eax
  00007 8b 4d 08   mov         ecx, DWORD PTR __Al$[ebp]
  0000a e8 00 00 00 00     call    ??$destroy@D@?$allocator@D@std@@QAEXPAD@Z ; std::allocator<char>::destroy<char>

; 763  :              }

  0000f 5d                 pop     ebp
  00010 c3                 ret     0
??$destroy@D@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??$_Construct@PAD@?$vector@DV?$allocator@D@std@@@std@@QAEXPAD0Uforward_iterator_tag@1@@Z
_TEXT   SEGMENT
_this$ = -20                                            ; size = 4
__$EHRec$ = -16                               ; size = 16
__First$ = 8                                            ; size = 4
__Last$ = 12                                            ; size = 4
___formal$ = 16                               ; size = 1
??$_Construct@PAD@?$vector@DV?$allocator@D@std@@@std@@QAEXPAD0Uforward_iterator_tag@1@@Z PROC ; std::vector<char,std::allocator<char> >::_Construct<char *>, COMDAT
; _this$ = ecx

; 817  :              {   // initialize with [_First, _Last), forward iterators

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 6a ff        push        -1
  00005 68 00 00 00 00     push    __ehhandler$??$_Construct@PAD@?$vector@DV?$allocator@D@std@@@std@@QAEXPAD0Uforward_iterator_tag@1@@Z
  0000a 64 a1 00 00 00
        00           mov     eax, DWORD PTR fs:0
  00010 50                 push    eax
  00011 51                 push    ecx
  00012 51                 push    ecx
  00013 53                 push    ebx
  00014 56                 push    esi
  00015 57                 push    edi
  00016 a1 00 00 00 00     mov     eax, DWORD PTR ___security_cookie
  0001b 33 c5        xor         eax, ebp
  0001d 50                 push    eax
  0001e 8d 45 f4   lea         eax, DWORD PTR __$EHRec$[ebp+4]
  00021 64 a3 00 00 00
        00           mov     DWORD PTR fs:0, eax
  00027 89 65 f0   mov         DWORD PTR __$EHRec$[ebp], esp
  0002a 89 4d ec   mov         DWORD PTR _this$[ebp], ecx

; 818  :              if (_Buy(_STD distance(_First, _Last)))

  0002d 8b 45 0c   mov         eax, DWORD PTR __Last$[ebp]
  00030 50                 push    eax
  00031 8b 4d 08   mov         ecx, DWORD PTR __First$[ebp]
  00034 51                 push    ecx
  00035 e8 00 00 00 00     call    ??$distance@PAD@std@@YAHPAD0@Z ; std::distance<char *>
  0003a 83 c4 08   add         esp, 8
  0003d 50                 push    eax
  0003e 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  00041 e8 00 00 00 00     call    ?_Buy@?$vector@DV?$allocator@D@std@@@std@@IAE_NI@Z ; std::vector<char,std::allocator<char> >::_Buy
  00046 0f b6 d0   movzx       edx, al
  00049 85 d2        test        edx, edx
  0004b 74 57        je  SHORT $LN4@Construct

; 819  :                  {       // nonzero, fill it
; 820  :                  _TRY_BEGIN

  0004d c7 45 fc 00 00
        00 00          mov         DWORD PTR __$EHRec$[ebp+12], 0

; 821  :                  this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());

  00054 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  00057 e8 00 00 00 00     call    ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPADXZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Myfirst
  0005c 8b 00        mov         eax, DWORD PTR [eax]
  0005e 50                 push    eax
  0005f 8b 4d 0c   mov         ecx, DWORD PTR __Last$[ebp]
  00062 51                 push    ecx
  00063 8b 55 08   mov         edx, DWORD PTR __First$[ebp]
  00066 52                 push    edx
  00067 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  0006a e8 00 00 00 00     call    ??$_Ucopy@PAD@?$vector@DV?$allocator@D@std@@@std@@IAEPADPAD00@Z ; std::vector<char,std::allocator<char> >::_Ucopy<char *>
  0006f 8b f0        mov         esi, eax
  00071 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  00074 e8 00 00 00 00     call    ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPADXZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Mylast
  00079 89 30        mov         DWORD PTR [eax], esi
  0007b eb 17        jmp         SHORT $LN5@Construct
__catch$??$_Construct@PAD@?$vector@DV?$allocator@D@std@@@std@@QAEXPAD0Uforward_iterator_tag@1@@Z$0:

; 822  :                  _CATCH_ALL
; 823  :                  _Tidy();

  0007d 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  00080 e8 00 00 00 00     call    ?_Tidy@?$vector@DV?$allocator@D@std@@@std@@IAEXXZ ; std::vector<char,std::allocator<char> >::_Tidy

; 824  :                  _RERAISE;

  00085 6a 00        push        0
  00087 6a 00        push        0
  00089 e8 00 00 00 00     call    __CxxThrowException@8

; 825  :                  _CATCH_END

  0008e b8 00 00 00 00     mov     eax, $LN8@Construct
  00093 c3                 ret     0
$LN5@Construct:
  00094 c7 45 fc ff ff
        ff ff          mov         DWORD PTR __$EHRec$[ebp+12], -1
  0009b eb 07        jmp         SHORT $LN4@Construct
$LN8@Construct:
  0009d c7 45 fc ff ff
        ff ff          mov         DWORD PTR __$EHRec$[ebp+12], -1
$LN4@Construct:

; 826  :                  }
; 827  :              }

  000a4 8b 4d f4   mov         ecx, DWORD PTR __$EHRec$[ebp+4]
  000a7 64 89 0d 00 00
        00 00          mov         DWORD PTR fs:0, ecx
  000ae 59                 pop     ecx
  000af 5f                 pop     edi
  000b0 5e                 pop     esi
  000b1 5b                 pop     ebx
  000b2 8b e5        mov         esp, ebp
  000b4 5d                 pop     ebp
  000b5 c2 0c 00   ret         12           ; 0000000cH
_TEXT   ENDS
;       COMDAT text$x
text$x  SEGMENT
__ehhandler$??$_Construct@PAD@?$vector@DV?$allocator@D@std@@@std@@QAEXPAD0Uforward_iterator_tag@1@@Z:
  00000 8b 54 24 08        mov   edx, DWORD PTR [esp+8]
  00004 8d 42 0c   lea         eax, DWORD PTR [edx+12]
  00007 8b 4a e8   mov         ecx, DWORD PTR [edx-24]
  0000a 33 c8        xor         ecx, eax
  0000c e8 00 00 00 00     call    @__security_check_cookie@4
  00011 b8 00 00 00 00     mov     eax, OFFSET __ehfuncinfo$??$_Construct@PAD@?$vector@DV?$allocator@D@std@@@std@@QAEXPAD0Uforward_iterator_tag@1@@Z
  00016 e9 00 00 00 00     jmp     ___CxxFrameHandler3
text$x  ENDS
??$_Construct@PAD@?$vector@DV?$allocator@D@std@@@std@@QAEXPAD0Uforward_iterator_tag@1@@Z ENDP ; std::vector<char,std::allocator<char> >::_Construct<char *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??$_Construct@PBD@?$vector@DV?$allocator@D@std@@@std@@QAEXPBD0Uforward_iterator_tag@1@@Z
_TEXT   SEGMENT
_this$ = -20                                            ; size = 4
__$EHRec$ = -16                               ; size = 16
__First$ = 8                                            ; size = 4
__Last$ = 12                                            ; size = 4
___formal$ = 16                               ; size = 1
??$_Construct@PBD@?$vector@DV?$allocator@D@std@@@std@@QAEXPBD0Uforward_iterator_tag@1@@Z PROC ; std::vector<char,std::allocator<char> >::_Construct<char const *>, COMDAT
; _this$ = ecx

; 817  :              {   // initialize with [_First, _Last), forward iterators

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 6a ff        push        -1
  00005 68 00 00 00 00     push    __ehhandler$??$_Construct@PBD@?$vector@DV?$allocator@D@std@@@std@@QAEXPBD0Uforward_iterator_tag@1@@Z
  0000a 64 a1 00 00 00
        00           mov     eax, DWORD PTR fs:0
  00010 50                 push    eax
  00011 51                 push    ecx
  00012 51                 push    ecx
  00013 53                 push    ebx
  00014 56                 push    esi
  00015 57                 push    edi
  00016 a1 00 00 00 00     mov     eax, DWORD PTR ___security_cookie
  0001b 33 c5        xor         eax, ebp
  0001d 50                 push    eax
  0001e 8d 45 f4   lea         eax, DWORD PTR __$EHRec$[ebp+4]
  00021 64 a3 00 00 00
        00           mov     DWORD PTR fs:0, eax
  00027 89 65 f0   mov         DWORD PTR __$EHRec$[ebp], esp
  0002a 89 4d ec   mov         DWORD PTR _this$[ebp], ecx

; 818  :              if (_Buy(_STD distance(_First, _Last)))

  0002d 8b 45 0c   mov         eax, DWORD PTR __Last$[ebp]
  00030 50                 push    eax
  00031 8b 4d 08   mov         ecx, DWORD PTR __First$[ebp]
  00034 51                 push    ecx
  00035 e8 00 00 00 00     call    ??$distance@PBD@std@@YAHPBD0@Z ; std::distance<char const *>
  0003a 83 c4 08   add         esp, 8
  0003d 50                 push    eax
  0003e 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  00041 e8 00 00 00 00     call    ?_Buy@?$vector@DV?$allocator@D@std@@@std@@IAE_NI@Z ; std::vector<char,std::allocator<char> >::_Buy
  00046 0f b6 d0   movzx       edx, al
  00049 85 d2        test        edx, edx
  0004b 74 57        je  SHORT $LN4@Construct

; 819  :                  {       // nonzero, fill it
; 820  :                  _TRY_BEGIN

  0004d c7 45 fc 00 00
        00 00          mov         DWORD PTR __$EHRec$[ebp+12], 0

; 821  :                  this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());

  00054 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  00057 e8 00 00 00 00     call    ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPADXZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Myfirst
  0005c 8b 00        mov         eax, DWORD PTR [eax]
  0005e 50                 push    eax
  0005f 8b 4d 0c   mov         ecx, DWORD PTR __Last$[ebp]
  00062 51                 push    ecx
  00063 8b 55 08   mov         edx, DWORD PTR __First$[ebp]
  00066 52                 push    edx
  00067 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  0006a e8 00 00 00 00     call    ??$_Ucopy@PBD@?$vector@DV?$allocator@D@std@@@std@@IAEPADPBD0PAD@Z ; std::vector<char,std::allocator<char> >::_Ucopy<char const *>
  0006f 8b f0        mov         esi, eax
  00071 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  00074 e8 00 00 00 00     call    ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPADXZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Mylast
  00079 89 30        mov         DWORD PTR [eax], esi
  0007b eb 17        jmp         SHORT $LN5@Construct
__catch$??$_Construct@PBD@?$vector@DV?$allocator@D@std@@@std@@QAEXPBD0Uforward_iterator_tag@1@@Z$0:

; 822  :                  _CATCH_ALL
; 823  :                  _Tidy();

  0007d 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  00080 e8 00 00 00 00     call    ?_Tidy@?$vector@DV?$allocator@D@std@@@std@@IAEXXZ ; std::vector<char,std::allocator<char> >::_Tidy

; 824  :                  _RERAISE;

  00085 6a 00        push        0
  00087 6a 00        push        0
  00089 e8 00 00 00 00     call    __CxxThrowException@8

; 825  :                  _CATCH_END

  0008e b8 00 00 00 00     mov     eax, $LN8@Construct
  00093 c3                 ret     0
$LN5@Construct:
  00094 c7 45 fc ff ff
        ff ff          mov         DWORD PTR __$EHRec$[ebp+12], -1
  0009b eb 07        jmp         SHORT $LN4@Construct
$LN8@Construct:
  0009d c7 45 fc ff ff
        ff ff          mov         DWORD PTR __$EHRec$[ebp+12], -1
$LN4@Construct:

; 826  :                  }
; 827  :              }

  000a4 8b 4d f4   mov         ecx, DWORD PTR __$EHRec$[ebp+4]
  000a7 64 89 0d 00 00
        00 00          mov         DWORD PTR fs:0, ecx
  000ae 59                 pop     ecx
  000af 5f                 pop     edi
  000b0 5e                 pop     esi
  000b1 5b                 pop     ebx
  000b2 8b e5        mov         esp, ebp
  000b4 5d                 pop     ebp
  000b5 c2 0c 00   ret         12           ; 0000000cH
_TEXT   ENDS
;       COMDAT text$x
text$x  SEGMENT
__ehhandler$??$_Construct@PBD@?$vector@DV?$allocator@D@std@@@std@@QAEXPBD0Uforward_iterator_tag@1@@Z:
  00000 8b 54 24 08        mov   edx, DWORD PTR [esp+8]
  00004 8d 42 0c   lea         eax, DWORD PTR [edx+12]
  00007 8b 4a e8   mov         ecx, DWORD PTR [edx-24]
  0000a 33 c8        xor         ecx, eax
  0000c e8 00 00 00 00     call    @__security_check_cookie@4
  00011 b8 00 00 00 00     mov     eax, OFFSET __ehfuncinfo$??$_Construct@PBD@?$vector@DV?$allocator@D@std@@@std@@QAEXPBD0Uforward_iterator_tag@1@@Z
  00016 e9 00 00 00 00     jmp     ___CxxFrameHandler3
text$x  ENDS
??$_Construct@PBD@?$vector@DV?$allocator@D@std@@@std@@QAEXPBD0Uforward_iterator_tag@1@@Z ENDP ; std::vector<char,std::allocator<char> >::_Construct<char const *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
___formal$ = 8                                      ; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_Vector_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_Vector_val<std::_Simple_types<char> >,1><>, COMDAT
; _this$ = ecx

; 279  :              {   // construct from forwarded values

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 278  :              : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
  0000f 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00012 e8 00 00 00 00     call    ??0?$_Vector_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<char> >::_Vector_val<std::_Simple_types<char> >

; 280  :              }

  00017 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0001a 8b e5        mov         esp, ebp
  0001c 5d                 pop     ebp
  0001d c2 04 00   ret         4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_Vector_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_Vector_val<std::_Simple_types<char> >,1><>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;       COMDAT ??$destroy@D@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAD@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Ptr$ = 8                                          ; size = 4
??$destroy@D@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char>, COMDAT
; _this$ = ecx

; 900  :              {   // destroy object at _Ptr

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 901  :              _Mytraits::destroy(*this, _Ptr);

  00007 8b 45 08   mov         eax, DWORD PTR __Ptr$[ebp]
  0000a 50                 push    eax
  0000b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000e 51                 push    ecx
  0000f e8 00 00 00 00     call    ??$destroy@D@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char>
  00014 83 c4 08   add         esp, 8

; 902  :              }

  00017 8b e5        mov         esp, ebp
  00019 5d                 pop     ebp
  0001a c2 04 00   ret         4
??$destroy@D@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;       COMDAT ??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U?$integral_constant@_N$00@0@@Z
_TEXT   SEGMENT
__Left$ = 8                                   ; size = 4
__Right$ = 12                                     ; size = 4
___formal$ = 16                               ; size = 1
??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U?$integral_constant@_N$00@0@@Z PROC ; std::_Pocma<std::_Wrap_alloc<std::allocator<char> > >, COMDAT

; 949  :        {     // propagate on container move assignment

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 950  :        _Left = _STD move(_Right);

  00003 8b 45 0c   mov         eax, DWORD PTR __Right$[ebp]
  00006 50                 push    eax
  00007 e8 00 00 00 00     call    ??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ; std::move<std::_Wrap_alloc<std::allocator<char> > &>
  0000c 83 c4 04   add         esp, 4
  0000f 50                 push    eax
  00010 8b 4d 08   mov         ecx, DWORD PTR __Left$[ebp]
  00013 e8 00 00 00 00     call    ??4?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEAAU01@$$QAU01@@Z ; std::_Wrap_alloc<std::allocator<char> >::operator=

; 951  :        }

  00018 5d                 pop     ebp
  00019 c3                 ret     0
??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U?$integral_constant@_N$00@0@@Z ENDP ; std::_Pocma<std::_Wrap_alloc<std::allocator<char> > >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??$_Construct@PAD@?$vector@DV?$allocator@D@std@@@std@@QAEXPAD0@Z
_TEXT   SEGMENT
_this$ = -8                                   ; size = 4
$T1 = -2                                                ; size = 1
$T2 = -1                                                ; size = 1
__First$ = 8                                            ; size = 4
__Last$ = 12                                            ; size = 4
??$_Construct@PAD@?$vector@DV?$allocator@D@std@@@std@@QAEXPAD0@Z PROC ; std::vector<char,std::allocator<char> >::_Construct<char *>, COMDAT
; _this$ = ecx

; 795  :              {   // initialize with [_First, _Last)

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d f8   mov         DWORD PTR _this$[ebp], ecx

; 796  :              _Construct(_First, _Last, _Iter_cat(_First));

  00009 8d 45 08   lea         eax, DWORD PTR __First$[ebp]
  0000c 50                 push    eax
  0000d 8d 4d fe   lea         ecx, DWORD PTR $T1[ebp]
  00010 51                 push    ecx
  00011 e8 00 00 00 00     call    ??$_Iter_cat@PAD@std@@YA?AUrandom_access_iterator_tag@0@ABQAD@Z ; std::_Iter_cat<char *>
  00016 83 c4 08   add         esp, 8
  00019 8a 10        mov         dl, BYTE PTR [eax]
  0001b 88 55 ff   mov         BYTE PTR $T2[ebp], dl
  0001e 0f b6 45 ff        movzx         eax, BYTE PTR $T2[ebp]
  00022 50                 push    eax
  00023 8b 4d 0c   mov         ecx, DWORD PTR __Last$[ebp]
  00026 51                 push    ecx
  00027 8b 55 08   mov         edx, DWORD PTR __First$[ebp]
  0002a 52                 push    edx
  0002b 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  0002e e8 00 00 00 00     call    ??$_Construct@PAD@?$vector@DV?$allocator@D@std@@@std@@QAEXPAD0Uforward_iterator_tag@1@@Z ; std::vector<char,std::allocator<char> >::_Construct<char *>

; 797  :              }

  00033 8b e5        mov         esp, ebp
  00035 5d                 pop     ebp
  00036 c2 08 00   ret         8
??$_Construct@PAD@?$vector@DV?$allocator@D@std@@@std@@QAEXPAD0@Z ENDP ; std::vector<char,std::allocator<char> >::_Construct<char *>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??$_Construct@PBD@?$vector@DV?$allocator@D@std@@@std@@QAEXPBD0@Z
_TEXT   SEGMENT
_this$ = -8                                   ; size = 4
$T1 = -2                                                ; size = 1
$T2 = -1                                                ; size = 1
__First$ = 8                                            ; size = 4
__Last$ = 12                                            ; size = 4
??$_Construct@PBD@?$vector@DV?$allocator@D@std@@@std@@QAEXPBD0@Z PROC ; std::vector<char,std::allocator<char> >::_Construct<char const *>, COMDAT
; _this$ = ecx

; 795  :              {   // initialize with [_First, _Last)

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d f8   mov         DWORD PTR _this$[ebp], ecx

; 796  :              _Construct(_First, _Last, _Iter_cat(_First));

  00009 8d 45 08   lea         eax, DWORD PTR __First$[ebp]
  0000c 50                 push    eax
  0000d 8d 4d fe   lea         ecx, DWORD PTR $T1[ebp]
  00010 51                 push    ecx
  00011 e8 00 00 00 00     call    ??$_Iter_cat@PBD@std@@YA?AUrandom_access_iterator_tag@0@ABQBD@Z ; std::_Iter_cat<char const *>
  00016 83 c4 08   add         esp, 8
  00019 8a 10        mov         dl, BYTE PTR [eax]
  0001b 88 55 ff   mov         BYTE PTR $T2[ebp], dl
  0001e 0f b6 45 ff        movzx         eax, BYTE PTR $T2[ebp]
  00022 50                 push    eax
  00023 8b 4d 0c   mov         ecx, DWORD PTR __Last$[ebp]
  00026 51                 push    ecx
  00027 8b 55 08   mov         edx, DWORD PTR __First$[ebp]
  0002a 52                 push    edx
  0002b 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  0002e e8 00 00 00 00     call    ??$_Construct@PBD@?$vector@DV?$allocator@D@std@@@std@@QAEXPBD0Uforward_iterator_tag@1@@Z ; std::vector<char,std::allocator<char> >::_Construct<char const *>

; 797  :              }

  00033 8b e5        mov         esp, ebp
  00035 5d                 pop     ebp
  00036 c2 08 00   ret         8
??$_Construct@PBD@?$vector@DV?$allocator@D@std@@@std@@QAEXPBD0@Z ENDP ; std::vector<char,std::allocator<char> >::_Construct<char const *>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;       COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXPAD0AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z
_TEXT   SEGMENT
__First$ = 8                                            ; size = 4
__Last$ = 12                                            ; size = 4
__Al$ = 16                                          ; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXPAD0AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<char> > >, COMDAT

; 163  :        {     // destroy [_First, _Last)

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 164  :        for (; _First != _Last; ++_First)

  00003 eb 09        jmp         SHORT $LN4@Destroy_ra
$LN2@Destroy_ra:
  00005 8b 45 08   mov         eax, DWORD PTR __First$[ebp]
  00008 83 c0 01   add         eax, 1
  0000b 89 45 08   mov         DWORD PTR __First$[ebp], eax
$LN4@Destroy_ra:
  0000e 8b 4d 08   mov         ecx, DWORD PTR __First$[ebp]
  00011 3b 4d 0c   cmp         ecx, DWORD PTR __Last$[ebp]
  00014 74 17        je  SHORT $LN1@Destroy_ra

; 165  :              _Al.destroy(_STD addressof(*_First));

  00016 8b 55 08   mov         edx, DWORD PTR __First$[ebp]
  00019 52                 push    edx
  0001a e8 00 00 00 00     call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>
  0001f 83 c4 04   add         esp, 4
  00022 50                 push    eax
  00023 8b 4d 10   mov         ecx, DWORD PTR __Al$[ebp]
  00026 e8 00 00 00 00     call    ??$destroy@D@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char>
  0002b eb d8        jmp         SHORT $LN2@Destroy_ra
$LN1@Destroy_ra:

; 166  :        }

  0002d 5d                 pop     ebp
  0002e c3                 ret     0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXPAD0AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<char> > >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;       COMDAT ??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z
_TEXT   SEGMENT
__Tag$ = -1                                   ; size = 1
__Left$ = 8                                   ; size = 4
__Right$ = 12                                     ; size = 4
??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z PROC ; std::_Pocma<std::_Wrap_alloc<std::allocator<char> > >, COMDAT

; 960  :        {     // (maybe) propagate on container move assignment

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx

; 961  :        typename _Alty::propagate_on_container_move_assignment _Tag;
; 962  :        _Pocma(_Left, _Right, _Tag);

  00004 0f b6 45 ff        movzx         eax, BYTE PTR __Tag$[ebp]
  00008 50                 push    eax
  00009 8b 4d 0c   mov         ecx, DWORD PTR __Right$[ebp]
  0000c 51                 push    ecx
  0000d 8b 55 08   mov         edx, DWORD PTR __Left$[ebp]
  00010 52                 push    edx
  00011 e8 00 00 00 00     call    ??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U?$integral_constant@_N$00@0@@Z ; std::_Pocma<std::_Wrap_alloc<std::allocator<char> > >
  00016 83 c4 0c   add         esp, 12                        ; 0000000cH

; 963  :        }

  00019 8b e5        mov         esp, ebp
  0001b 5d                 pop     ebp
  0001c c3                 ret     0
??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ENDP ; std::_Pocma<std::_Wrap_alloc<std::allocator<char> > >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z
_TEXT   SEGMENT
$T1 = -20                                         ; size = 4
$T2 = -16                                         ; size = 4
$T3 = -12                                         ; size = 4
$T4 = -8                                                ; size = 4
_this$ = -4                                   ; size = 4
__First$ = 8                                            ; size = 4
__Last$ = 12                                            ; size = 4
??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > >, COMDAT
; _this$ = ecx

; 1197 :              {   // assign [_First, _Last), input iterators

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 14   sub         esp, 20                        ; 00000014H
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1198 :              return (replace(begin(), end(), _First, _Last));

  00009 8d 45 f0   lea         eax, DWORD PTR $T2[ebp]
  0000c 50                 push    eax
  0000d 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00010 e8 00 00 00 00     call    ?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end
  00015 8b 08        mov         ecx, DWORD PTR [eax]
  00017 89 4d f8   mov         DWORD PTR $T4[ebp], ecx
  0001a 8d 55 ec   lea         edx, DWORD PTR $T1[ebp]
  0001d 52                 push    edx
  0001e 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00021 e8 00 00 00 00     call    ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
  00026 8b 00        mov         eax, DWORD PTR [eax]
  00028 89 45 f4   mov         DWORD PTR $T3[ebp], eax
  0002b 8b 4d 0c   mov         ecx, DWORD PTR __Last$[ebp]
  0002e 51                 push    ecx
  0002f 8b 55 08   mov         edx, DWORD PTR __First$[ebp]
  00032 52                 push    edx
  00033 8b 45 f8   mov         eax, DWORD PTR $T4[ebp]
  00036 50                 push    eax
  00037 8b 4d f4   mov         ecx, DWORD PTR $T3[ebp]
  0003a 51                 push    ecx
  0003b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0003e e8 00 00 00 00     call    ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace

; 1199 :              }

  00043 8b e5        mov         esp, ebp
  00045 5d                 pop     ebp
  00046 c2 08 00   ret         8
??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ??$_Copy_unchecked1@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z
_TEXT   SEGMENT
$T1 = -16                                         ; size = 8
$T2 = -8                                                ; size = 8
___$ReturnUdt$ = 8                                  ; size = 4
__First$ = 12                                     ; size = 8
__Last$ = 20                                            ; size = 8
__Dest$ = 28                                            ; size = 8
___formal$ = 36                               ; size = 1
??$_Copy_unchecked1@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z PROC ; std::_Copy_unchecked1<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >, COMDAT

; 2264 :        {     // copy [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 10   sub         esp, 16                        ; 00000010H

; 2265 :        for (; _First != _Last; ++_Dest, (void)++_First)

  00006 eb 10        jmp         SHORT $LN4@Copy_unche
$LN2@Copy_unche:
  00008 8d 4d 1c   lea         ecx, DWORD PTR __Dest$[ebp]
  0000b e8 00 00 00 00     call    ??E?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator++
  00010 8d 4d 0c   lea         ecx, DWORD PTR __First$[ebp]
  00013 e8 00 00 00 00     call    ??E?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator++
$LN4@Copy_unche:
  00018 8d 45 14   lea         eax, DWORD PTR __Last$[ebp]
  0001b 50                 push    eax
  0001c 8d 4d 0c   lea         ecx, DWORD PTR __First$[ebp]
  0001f e8 00 00 00 00     call    ??9?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator!=
  00024 0f b6 c8   movzx       ecx, al
  00027 85 c9        test        ecx, ecx
  00029 74 22        je  SHORT $LN3@Copy_unche

; 2266 :              *_Dest = *_First;

  0002b 8d 55 f8   lea         edx, DWORD PTR $T2[ebp]
  0002e 52                 push    edx
  0002f 8d 4d 0c   lea         ecx, DWORD PTR __First$[ebp]
  00032 e8 00 00 00 00     call    ??D?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@XZ ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator*
  00037 50                 push    eax
  00038 8d 45 f0   lea         eax, DWORD PTR $T1[ebp]
  0003b 50                 push    eax
  0003c 8d 4d 1c   lea         ecx, DWORD PTR __Dest$[ebp]
  0003f e8 00 00 00 00     call    ??D?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@XZ ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator*
  00044 8b c8        mov         ecx, eax
  00046 e8 00 00 00 00     call    ??4?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator=
  0004b eb bb        jmp         SHORT $LN2@Copy_unche
$LN3@Copy_unche:

; 2267 :        return (_Dest);

  0004d 8b 4d 08   mov         ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00050 8b 55 1c   mov         edx, DWORD PTR __Dest$[ebp]
  00053 89 11        mov         DWORD PTR [ecx], edx
  00055 8b 45 20   mov         eax, DWORD PTR __Dest$[ebp+4]
  00058 89 41 04   mov         DWORD PTR [ecx+4], eax
  0005b 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2268 :        }

  0005e 8b e5        mov         esp, ebp
  00060 5d                 pop     ebp
  00061 c3                 ret     0
??$_Copy_unchecked1@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_unchecked1<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??$?0PADX@?$vector@DV?$allocator@D@std@@@std@@QAE@PAD0@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__First$ = 8                                            ; size = 4
__Last$ = 12                                            ; size = 4
??$?0PADX@?$vector@DV?$allocator@D@std@@@std@@QAE@PAD0@Z PROC ; std::vector<char,std::allocator<char> >::vector<char,std::allocator<char> ><char *,void>, COMDAT
; _this$ = ecx

; 780  :              {   // construct from [_First, _Last)

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 779  :              : _Mybase()

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ??0?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >

; 781  :              _Construct(_First, _Last);

  0000f 8b 45 0c   mov         eax, DWORD PTR __Last$[ebp]
  00012 50                 push    eax
  00013 8b 4d 08   mov         ecx, DWORD PTR __First$[ebp]
  00016 51                 push    ecx
  00017 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001a e8 00 00 00 00     call    ??$_Construct@PAD@?$vector@DV?$allocator@D@std@@@std@@QAEXPAD0@Z ; std::vector<char,std::allocator<char> >::_Construct<char *>

; 782  :              }

  0001f 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00022 8b e5        mov         esp, ebp
  00024 5d                 pop     ebp
  00025 c2 08 00   ret         8
??$?0PADX@?$vector@DV?$allocator@D@std@@@std@@QAE@PAD0@Z ENDP ; std::vector<char,std::allocator<char> >::vector<char,std::allocator<char> ><char *,void>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<char> > >::operator*, COMDAT
; _this$ = ecx

; 324  :              {   // return designated object

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 325  :              return ((reference)**(_Mybase *)this);

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<char> > >::operator*

; 326  :              }

  0000f 8b e5        mov         esp, ebp
  00011 5d                 pop     ebp
  00012 c3                 ret     0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<char> > >::operator*
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Parg$ = 8                                   ; size = 4
__Pvector$ = 12                               ; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<char> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<char> > >, COMDAT
; _this$ = ecx

; 307  :              {   // construct with pointer _Parg

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 306  :              : _Mybase(_Parg, _Pvector)

  00007 8b 45 0c   mov         eax, DWORD PTR __Pvector$[ebp]
  0000a 50                 push    eax
  0000b 8b 4d 08   mov         ecx, DWORD PTR __Parg$[ebp]
  0000e 51                 push    ecx
  0000f 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00012 e8 00 00 00 00     call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<char> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<char> > >

; 308  :              }

  00017 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0001a 8b e5        mov         esp, ebp
  0001c 5d                 pop     ebp
  0001d c2 08 00   ret         8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<char> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<char> > >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<char> > >::operator*, COMDAT
; _this$ = ecx

; 65   :              {   // return designated object

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   :              if (this->_Getcont() == 0
; 68   :                  || _Ptr == 0
; 69   :                  || _Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   :                  || ((_Myvec *)this->_Getcont())->_Mylast <= _Ptr)
; 71   :                  {       // report error
; 72   :                  _DEBUG_ERROR("vector iterator not dereferencable");
; 73   :                  _SCL_SECURE_OUT_OF_RANGE;
; 74   :                  }
; 75   :
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   :              _SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   :              _SCL_SECURE_VALIDATE_RANGE(
; 79   :                  _Ptr != _Tptr()
; 80   :                  && ((_Myvec *)this->_Getcont())->_Myfirst <= _Ptr
; 81   :                  && _Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   :
; 84   :              _Analysis_assume_(_Ptr != _Tptr());
; 85   :
; 86   :              return (*_Ptr);

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a 8b 00        mov         eax, DWORD PTR [eax]

; 87   :              }

  0000c 8b e5        mov         esp, ebp
  0000e 5d                 pop     ebp
  0000f c3                 ret     0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<char> > >::operator*
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Parg$ = 8                                   ; size = 4
__Pvector$ = 12                               ; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<char> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<char> > >, COMDAT
; _this$ = ecx

; 47   :              {   // construct with pointer _Parg

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 46   :              : _Ptr(_Parg)

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a 8b 4d 08   mov         ecx, DWORD PTR __Parg$[ebp]
  0000d 89 08        mov         DWORD PTR [eax], ecx

; 48   :              this->_Adopt(_Pvector);

  0000f 8b 55 0c   mov         edx, DWORD PTR __Pvector$[ebp]
  00012 52                 push    edx
  00013 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00016 e8 00 00 00 00     call    ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 49   :              }

  0001b 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0001e 8b e5        mov         esp, ebp
  00020 5d                 pop     ebp
  00021 c2 08 00   ret         8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<char> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<char> > >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??$?0PBDX@?$vector@DV?$allocator@D@std@@@std@@QAE@PBD0@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__First$ = 8                                            ; size = 4
__Last$ = 12                                            ; size = 4
??$?0PBDX@?$vector@DV?$allocator@D@std@@@std@@QAE@PBD0@Z PROC ; std::vector<char,std::allocator<char> >::vector<char,std::allocator<char> ><char const *,void>, COMDAT
; _this$ = ecx

; 780  :              {   // construct from [_First, _Last)

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 779  :              : _Mybase()

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ??0?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >

; 781  :              _Construct(_First, _Last);

  0000f 8b 45 0c   mov         eax, DWORD PTR __Last$[ebp]
  00012 50                 push    eax
  00013 8b 4d 08   mov         ecx, DWORD PTR __First$[ebp]
  00016 51                 push    ecx
  00017 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001a e8 00 00 00 00     call    ??$_Construct@PBD@?$vector@DV?$allocator@D@std@@@std@@QAEXPBD0@Z ; std::vector<char,std::allocator<char> >::_Construct<char const *>

; 782  :              }

  0001f 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00022 8b e5        mov         esp, ebp
  00024 5d                 pop     ebp
  00025 c2 08 00   ret         8
??$?0PBDX@?$vector@DV?$allocator@D@std@@@std@@QAE@PBD0@Z ENDP ; std::vector<char,std::allocator<char> >::vector<char,std::allocator<char> ><char const *,void>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Xlen@?$vector@DV?$allocator@D@std@@@std@@IBEXXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Xlen@?$vector@DV?$allocator@D@std@@@std@@IBEXXZ PROC  ; std::vector<char,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 1787 :              {   // report a length_error

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1788 :              _Xlength_error("vector<T> too long");

  00007 68 00 00 00 00     push    OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0000c e8 00 00 00 00     call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen:

; 1789 :              }

  00011 8b e5        mov         esp, ebp
  00013 5d                 pop     ebp
  00014 c3                 ret     0
?_Xlen@?$vector@DV?$allocator@D@std@@@std@@IBEXXZ ENDP  ; std::vector<char,std::allocator<char> >::_Xlen
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Tidy@?$vector@DV?$allocator@D@std@@@std@@IAEXXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Tidy@?$vector@DV?$allocator@D@std@@@std@@IAEXXZ PROC  ; std::vector<char,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 1659 :              {   // free all storage

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 56                 push    esi
  00005 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1660 :              if (this->_Myfirst() != pointer())

  00008 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000b e8 00 00 00 00     call    ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPADXZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Myfirst
  00010 83 38 00   cmp         DWORD PTR [eax], 0
  00013 0f 84 81 00 00
        00           je      $LN1@Tidy

; 1661 :                  {       // something to free, destroy and deallocate it
; 1662 :                  this->_Orphan_all();

  00019 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001c e8 00 00 00 00     call    ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Orphan_all

; 1663 :                  _Destroy(this->_Myfirst(), this->_Mylast());

  00021 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00024 e8 00 00 00 00     call    ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPADXZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Mylast
  00029 8b 00        mov         eax, DWORD PTR [eax]
  0002b 50                 push    eax
  0002c 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0002f e8 00 00 00 00     call    ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPADXZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Myfirst
  00034 8b 08        mov         ecx, DWORD PTR [eax]
  00036 51                 push    ecx
  00037 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0003a e8 00 00 00 00     call    ?_Destroy@?$vector@DV?$allocator@D@std@@@std@@IAEXPAD0@Z ; std::vector<char,std::allocator<char> >::_Destroy

; 1664 :                  this->_Getal().deallocate(this->_Myfirst(),

  0003f 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00042 e8 00 00 00 00     call    ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPADXZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Myend
  00047 8b f0        mov         esi, eax
  00049 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0004c e8 00 00 00 00     call    ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPADXZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Myfirst
  00051 8b 16        mov         edx, DWORD PTR [esi]
  00053 2b 10        sub         edx, DWORD PTR [eax]
  00055 52                 push    edx
  00056 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00059 e8 00 00 00 00     call    ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPADXZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Myfirst
  0005e 8b 00        mov         eax, DWORD PTR [eax]
  00060 50                 push    eax
  00061 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00064 e8 00 00 00 00     call    ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Getal
  00069 8b c8        mov         ecx, eax
  0006b e8 00 00 00 00     call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate

; 1665 :                          this->_Myend() - this->_Myfirst());
; 1666 :                  this->_Myfirst() = pointer();

  00070 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00073 e8 00 00 00 00     call    ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPADXZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Myfirst
  00078 c7 00 00 00 00
        00           mov     DWORD PTR [eax], 0

; 1667 :                  this->_Mylast() = pointer();

  0007e 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00081 e8 00 00 00 00     call    ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPADXZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Mylast
  00086 c7 00 00 00 00
        00           mov     DWORD PTR [eax], 0

; 1668 :                  this->_Myend() = pointer();

  0008c 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0008f e8 00 00 00 00     call    ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPADXZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Myend
  00094 c7 00 00 00 00
        00           mov     DWORD PTR [eax], 0
$LN1@Tidy:

; 1669 :                  }
; 1670 :              }

  0009a 5e                 pop     esi
  0009b 8b e5        mov         esp, ebp
  0009d 5d                 pop     ebp
  0009e c3                 ret     0
?_Tidy@?$vector@DV?$allocator@D@std@@@std@@IAEXXZ ENDP  ; std::vector<char,std::allocator<char> >::_Tidy
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Destroy@?$vector@DV?$allocator@D@std@@@std@@IAEXPAD0@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__First$ = 8                                            ; size = 4
__Last$ = 12                                            ; size = 4
?_Destroy@?$vector@DV?$allocator@D@std@@@std@@IAEXPAD0@Z PROC ; std::vector<char,std::allocator<char> >::_Destroy, COMDAT
; _this$ = ecx

; 1603 :              {   // destroy [_First, _Last) using allocator

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1604 :              _Destroy_range(_First, _Last, this->_Getal());

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Getal
  0000f 50                 push    eax
  00010 8b 45 0c   mov         eax, DWORD PTR __Last$[ebp]
  00013 50                 push    eax
  00014 8b 4d 08   mov         ecx, DWORD PTR __First$[ebp]
  00017 51                 push    ecx
  00018 e8 00 00 00 00     call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXPAD0AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<char> > >
  0001d 83 c4 0c   add         esp, 12                        ; 0000000cH

; 1605 :              }

  00020 8b e5        mov         esp, ebp
  00022 5d                 pop     ebp
  00023 c2 08 00   ret         8
?_Destroy@?$vector@DV?$allocator@D@std@@@std@@IAEXPAD0@Z ENDP ; std::vector<char,std::allocator<char> >::_Destroy
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Buy@?$vector@DV?$allocator@D@std@@@std@@IAE_NI@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Capacity$ = 8                               ; size = 4
?_Buy@?$vector@DV?$allocator@D@std@@@std@@IAE_NI@Z PROC ; std::vector<char,std::allocator<char> >::_Buy, COMDAT
; _this$ = ecx

; 1584 :              {   // allocate array with _Capacity elements

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 56                 push    esi
  00005 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1585 :              this->_Myfirst() = pointer();

  00008 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000b e8 00 00 00 00     call    ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPADXZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Myfirst
  00010 c7 00 00 00 00
        00           mov     DWORD PTR [eax], 0

; 1586 :              this->_Mylast() = pointer();

  00016 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00019 e8 00 00 00 00     call    ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPADXZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Mylast
  0001e c7 00 00 00 00
        00           mov     DWORD PTR [eax], 0

; 1587 :              this->_Myend() = pointer();

  00024 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00027 e8 00 00 00 00     call    ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPADXZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Myend
  0002c c7 00 00 00 00
        00           mov     DWORD PTR [eax], 0

; 1588 :
; 1589 :              if (_Capacity == 0)

  00032 83 7d 08 00        cmp   DWORD PTR __Capacity$[ebp], 0
  00036 75 06        jne         SHORT $LN2@Buy

; 1590 :                  return (false);

  00038 32 c0        xor         al, al
  0003a eb 67        jmp         SHORT $LN6@Buy
  0003c eb 63        jmp         SHORT $LN3@Buy
$LN2@Buy:

; 1591 :              else if (max_size() < _Capacity)

  0003e 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00041 e8 00 00 00 00     call    ?max_size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::max_size
  00046 3b 45 08   cmp         eax, DWORD PTR __Capacity$[ebp]
  00049 73 0a        jae         SHORT $LN4@Buy

; 1592 :                  _Xlen();        // result too long

  0004b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0004e e8 00 00 00 00     call    ?_Xlen@?$vector@DV?$allocator@D@std@@@std@@IBEXXZ ; std::vector<char,std::allocator<char> >::_Xlen

; 1593 :              else

  00053 eb 4c        jmp         SHORT $LN3@Buy
$LN4@Buy:

; 1594 :                  {       // nonempty array, allocate storage
; 1595 :                  this->_Myfirst() = this->_Getal().allocate(_Capacity);

  00055 8b 45 08   mov         eax, DWORD PTR __Capacity$[ebp]
  00058 50                 push    eax
  00059 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0005c e8 00 00 00 00     call    ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Getal
  00061 8b c8        mov         ecx, eax
  00063 e8 00 00 00 00     call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
  00068 8b f0        mov         esi, eax
  0006a 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0006d e8 00 00 00 00     call    ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPADXZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Myfirst
  00072 89 30        mov         DWORD PTR [eax], esi

; 1596 :                  this->_Mylast() = this->_Myfirst();

  00074 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00077 e8 00 00 00 00     call    ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPADXZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Myfirst
  0007c 8b f0        mov         esi, eax
  0007e 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00081 e8 00 00 00 00     call    ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPADXZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Mylast
  00086 8b 0e        mov         ecx, DWORD PTR [esi]
  00088 89 08        mov         DWORD PTR [eax], ecx

; 1597 :                  this->_Myend() = this->_Myfirst() + _Capacity;

  0008a 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0008d e8 00 00 00 00     call    ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPADXZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Myfirst
  00092 8b 30        mov         esi, DWORD PTR [eax]
  00094 03 75 08   add         esi, DWORD PTR __Capacity$[ebp]
  00097 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0009a e8 00 00 00 00     call    ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPADXZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Myend
  0009f 89 30        mov         DWORD PTR [eax], esi
$LN3@Buy:

; 1598 :                  }
; 1599 :              return (true);

  000a1 b0 01        mov         al, 1
$LN6@Buy:

; 1600 :              }

  000a3 5e                 pop     esi
  000a4 8b e5        mov         esp, ebp
  000a6 5d                 pop     ebp
  000a7 c2 04 00   ret         4
?_Buy@?$vector@DV?$allocator@D@std@@@std@@IAE_NI@Z ENDP ; std::vector<char,std::allocator<char> >::_Buy
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?max_size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ
_TEXT   SEGMENT
_this$ = -8                                   ; size = 4
$T1 = -1                                                ; size = 1
?max_size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ PROC ; std::vector<char,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1187 :              {   // return maximum possible length of sequence

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d f8   mov         DWORD PTR _this$[ebp], ecx

; 1188 :              return (this->_Getal().max_size());

  00009 0f b6 45 ff        movzx         eax, BYTE PTR $T1[ebp]
  0000d 50                 push    eax
  0000e 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00011 e8 00 00 00 00     call    ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Getal
  00016 8b c8        mov         ecx, eax
  00018 e8 00 00 00 00     call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<char> >::max_size

; 1189 :              }

  0001d 8b e5        mov         esp, ebp
  0001f 5d                 pop     ebp
  00020 c3                 ret     0
?max_size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::vector<char,std::allocator<char> >::max_size
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ PROC   ; std::vector<char,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1182 :              {   // return length of sequence

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 56                 push    esi
  00005 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1183 :              return (this->_Mylast() - this->_Myfirst());

  00008 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000b e8 00 00 00 00     call    ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABQADXZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Mylast
  00010 8b f0        mov         esi, eax
  00012 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00015 e8 00 00 00 00     call    ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABQADXZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Myfirst
  0001a 8b 0e        mov         ecx, DWORD PTR [esi]
  0001c 2b 08        sub         ecx, DWORD PTR [eax]
  0001e 8b c1        mov         eax, ecx

; 1184 :              }

  00020 5e                 pop     esi
  00021 8b e5        mov         esp, ebp
  00023 5d                 pop     ebp
  00024 c3                 ret     0
?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ENDP   ; std::vector<char,std::allocator<char> >::size
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?begin@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@2@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
___$ReturnUdt$ = 8                                  ; size = 4
?begin@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@2@XZ PROC ; std::vector<char,std::allocator<char> >::begin, COMDAT
; _this$ = ecx

; 1060 :              {   // return iterator for beginning of mutable sequence

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1061 :              return (iterator(this->_Myfirst(), &this->_Get_data()));

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Get_data
  0000f 50                 push    eax
  00010 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00013 e8 00 00 00 00     call    ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPADXZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Myfirst
  00018 8b 00        mov         eax, DWORD PTR [eax]
  0001a 50                 push    eax
  0001b 8b 4d 08   mov         ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001e e8 00 00 00 00     call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<char> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<char> > >
  00023 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1062 :              }

  00026 8b e5        mov         esp, ebp
  00028 5d                 pop     ebp
  00029 c2 04 00   ret         4
?begin@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@2@XZ ENDP ; std::vector<char,std::allocator<char> >::begin
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ PROC      ; std::vector<char,std::allocator<char> >::~vector<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 978  :              {   // destroy the object

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 979  :              _Tidy();

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Tidy@?$vector@DV?$allocator@D@std@@@std@@IAEXXZ ; std::vector<char,std::allocator<char> >::_Tidy

; 980  :              }

  0000f 8b e5        mov         esp, ebp
  00011 5d                 pop     ebp
  00012 c3                 ret     0
??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ ENDP      ; std::vector<char,std::allocator<char> >::~vector<char,std::allocator<char> >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_Vector_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 318  :              {   // return const reference to second

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 319  :              return (_Myval2);

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]

; 320  :              }

  0000a 8b e5        mov         esp, ebp
  0000c 5d                 pop     ebp
  0000d c3                 ret     0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_Vector_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_Vector_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 313  :              {   // return reference to second

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 314  :              return (_Myval2);

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]

; 315  :              }

  0000a 8b e5        mov         esp, ebp
  0000c 5d                 pop     ebp
  0000d c3                 ret     0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_Vector_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_Vector_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 298  :              {   // return const reference to first

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 299  :              return (*this);

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]

; 300  :              }

  0000a 8b e5        mov         esp, ebp
  0000c 5d                 pop     ebp
  0000d c3                 ret     0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_Vector_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_Vector_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 293  :              {   // return reference to first

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 294  :              return (*this);

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]

; 295  :              }

  0000a 8b e5        mov         esp, ebp
  0000c 5d                 pop     ebp
  0000d c3                 ret     0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_Vector_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??0?$_Vector_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??0?$_Vector_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<char> >::_Vector_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 478  :        _Vector_val()

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 479  :              {   // initialize values
; 480  :              _Myfirst = pointer();

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a c7 00 00 00 00
        00           mov     DWORD PTR [eax], 0

; 481  :              _Mylast = pointer();

  00010 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00013 c7 41 04 00 00
        00 00          mov         DWORD PTR [ecx+4], 0

; 482  :              _Myend = pointer();

  0001a 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  0001d c7 42 08 00 00
        00 00          mov         DWORD PTR [edx+8], 0

; 483  :              }

  00024 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00027 8b e5        mov         esp, ebp
  00029 5d                 pop     ebp
  0002a c3                 ret     0
??0?$_Vector_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<char> >::_Vector_val<std::_Simple_types<char> >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPADXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPADXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Myend, COMDAT
; _this$ = ecx

; 665  :              {   // return reference to _Myend

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 666  :              return (_Get_data()._Myend);

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Get_data
  0000f 83 c0 08   add         eax, 8

; 667  :              }

  00012 8b e5        mov         esp, ebp
  00014 5d                 pop     ebp
  00015 c3                 ret     0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPADXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Myend
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABQADXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABQADXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Mylast, COMDAT
; _this$ = ecx

; 660  :              {   // return const reference to _Mylast

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 661  :              return (_Get_data()._Mylast);

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Get_data
  0000f 83 c0 04   add         eax, 4

; 662  :              }

  00012 8b e5        mov         esp, ebp
  00014 5d                 pop     ebp
  00015 c3                 ret     0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABQADXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Mylast
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPADXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPADXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Mylast, COMDAT
; _this$ = ecx

; 655  :              {   // return reference to _Mylast

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 656  :              return (_Get_data()._Mylast);

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Get_data
  0000f 83 c0 04   add         eax, 4

; 657  :              }

  00012 8b e5        mov         esp, ebp
  00014 5d                 pop     ebp
  00015 c3                 ret     0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPADXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Mylast
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABQADXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABQADXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Myfirst, COMDAT
; _this$ = ecx

; 650  :              {   // return const reference to _Myfirst

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 651  :              return (_Get_data()._Myfirst);

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Get_data

; 652  :              }

  0000f 8b e5        mov         esp, ebp
  00011 5d                 pop     ebp
  00012 c3                 ret     0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABQADXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Myfirst
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPADXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPADXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Myfirst, COMDAT
; _this$ = ecx

; 645  :              {   // return reference to _Myfirst

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 646  :              return (_Get_data()._Myfirst);

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Get_data

; 647  :              }

  0000f 8b e5        mov         esp, ebp
  00011 5d                 pop     ebp
  00012 c3                 ret     0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPADXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Myfirst
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 640  :              {   // return const reference to _Vector_val

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 641  :              return (_Mypair._Get_second());

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_Vector_val<std::_Simple_types<char> >,1>::_Get_second

; 642  :              }

  0000f 8b e5        mov         esp, ebp
  00011 5d                 pop     ebp
  00012 c3                 ret     0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Get_data
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 635  :              {   // return reference to _Vector_val

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 636  :              return (_Mypair._Get_second());

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_Vector_val<std::_Simple_types<char> >,1>::_Get_second

; 637  :              }

  0000f 8b e5        mov         esp, ebp
  00011 5d                 pop     ebp
  00012 c3                 ret     0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Get_data
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 630  :              {   // return const reference to allocator

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 631  :              return (_Mypair._Get_first());

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_Vector_val<std::_Simple_types<char> >,1>::_Get_first

; 632  :              }

  0000f 8b e5        mov         esp, ebp
  00011 5d                 pop     ebp
  00012 c3                 ret     0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Getal
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 625  :              {   // return reference to allocator

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 626  :              return (_Mypair._Get_first());

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_Vector_val<std::_Simple_types<char> >,1>::_Get_first

; 627  :              }

  0000f 8b e5        mov         esp, ebp
  00011 5d                 pop     ebp
  00012 c3                 ret     0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Getal
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 615  :              {   // orphan all iterators

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 616  :              _Get_data()._Orphan_all();

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Get_data
  0000f 8b c8        mov         ecx, eax
  00011 e8 00 00 00 00     call    ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 617  :              }

  00016 8b e5        mov         esp, ebp
  00018 5d                 pop     ebp
  00019 c3                 ret     0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Orphan_all
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT   SEGMENT
_this$ = -8                                   ; size = 4
$T1 = -1                                                ; size = 1
??0?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 514  :              {   // default construct allocator

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d f8   mov         DWORD PTR _this$[ebp], ecx

; 513  :              : _Mypair(_Zero_then_variadic_args_t())

  00009 0f b6 45 ff        movzx         eax, BYTE PTR $T1[ebp]
  0000d 50                 push    eax
  0000e 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00011 e8 00 00 00 00     call    ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_Vector_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_Vector_val<std::_Simple_types<char> >,1><>

; 515  :              }

  00016 8b 45 f8   mov         eax, DWORD PTR _this$[ebp]
  00019 8b e5        mov         esp, ebp
  0001b 5d                 pop     ebp
  0001c c3                 ret     0
??0?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ??$_Insert@PBD@?$_Buf@D@std@@QAEXPBD0@Z
_TEXT   SEGMENT
_this$ = -8                                   ; size = 4
tv67 = -1                                         ; size = 1
__First$ = 8                                            ; size = 4
__Last$ = 12                                            ; size = 4
??$_Insert@PBD@?$_Buf@D@std@@QAEXPBD0@Z PROC            ; std::_Buf<char>::_Insert<char const *>, COMDAT
; _this$ = ecx

; 1668 :              {   // append multiple characters

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d f8   mov         DWORD PTR _this$[ebp], ecx
$LN2@Insert:

; 1669 :              while (_First != _Last)

  00009 8b 45 08   mov         eax, DWORD PTR __First$[ebp]
  0000c 3b 45 0c   cmp         eax, DWORD PTR __Last$[ebp]
  0000f 74 20        je  SHORT $LN1@Insert

; 1670 :                  _Insert(*_First++);

  00011 8b 4d 08   mov         ecx, DWORD PTR __First$[ebp]
  00014 8a 11        mov         dl, BYTE PTR [ecx]
  00016 88 55 ff   mov         BYTE PTR tv67[ebp], dl
  00019 0f b6 45 ff        movzx         eax, BYTE PTR tv67[ebp]
  0001d 50                 push    eax
  0001e 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00021 e8 00 00 00 00     call    ?_Insert@?$_Buf@D@std@@QAEXD@Z ; std::_Buf<char>::_Insert
  00026 8b 4d 08   mov         ecx, DWORD PTR __First$[ebp]
  00029 83 c1 01   add         ecx, 1
  0002c 89 4d 08   mov         DWORD PTR __First$[ebp], ecx
  0002f eb d8        jmp         SHORT $LN2@Insert
$LN1@Insert:

; 1671 :              }

  00031 8b e5        mov         esp, ebp
  00033 5d                 pop     ebp
  00034 c2 08 00   ret         8
??$_Insert@PBD@?$_Buf@D@std@@QAEXPBD0@Z ENDP            ; std::_Buf<char>::_Insert<char const *>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;       COMDAT ??$_Uninitialized_move_al_unchecked1@II@std@@YAPAIPAI00AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U_Really_trivial_ptr_iterator_tag@0@@Z
_TEXT   SEGMENT
__First$ = 8                                            ; size = 4
__Last$ = 12                                            ; size = 4
__Dest$ = 16                                            ; size = 4
___formal$ = 20                               ; size = 4
___formal$ = 24                               ; size = 1
??$_Uninitialized_move_al_unchecked1@II@std@@YAPAIPAI00AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U_Really_trivial_ptr_iterator_tag@0@@Z PROC ; std::_Uninitialized_move_al_unchecked1<unsigned int,unsigned int>, COMDAT

; 336  :        {     // move [_First, _Last) to raw _Dest, using std::allocator, memmove optimization

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 337  :        return (_Copy_memmove(_First, _Last, _Dest));

  00003 8b 45 10   mov         eax, DWORD PTR __Dest$[ebp]
  00006 50                 push    eax
  00007 8b 4d 0c   mov         ecx, DWORD PTR __Last$[ebp]
  0000a 51                 push    ecx
  0000b 8b 55 08   mov         edx, DWORD PTR __First$[ebp]
  0000e 52                 push    edx
  0000f e8 00 00 00 00     call    ??$_Copy_memmove@PAIPAI@std@@YAPAIPAI00@Z ; std::_Copy_memmove<unsigned int *,unsigned int *>
  00014 83 c4 0c   add         esp, 12                        ; 0000000cH

; 338  :        }

  00017 5d                 pop     ebp
  00018 c3                 ret     0
??$_Uninitialized_move_al_unchecked1@II@std@@YAPAIPAI00AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U_Really_trivial_ptr_iterator_tag@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked1<unsigned int,unsigned int>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ??$_Copy_backward_unchecked1@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z
_TEXT   SEGMENT
$T1 = -16                                         ; size = 8
$T2 = -8                                                ; size = 8
___$ReturnUdt$ = 8                                  ; size = 4
__First$ = 12                                     ; size = 8
__Last$ = 20                                            ; size = 8
__Dest$ = 28                                            ; size = 8
___formal$ = 36                               ; size = 1
??$_Copy_backward_unchecked1@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z PROC ; std::_Copy_backward_unchecked1<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >, COMDAT

; 2510 :        {     // copy [_First, _Last) backwards to [..., _Dest), no special optimization

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 10   sub         esp, 16                        ; 00000010H
$LN2@Copy_backw:

; 2511 :        while (_First != _Last)

  00006 8d 45 14   lea         eax, DWORD PTR __Last$[ebp]
  00009 50                 push    eax
  0000a 8d 4d 0c   lea         ecx, DWORD PTR __First$[ebp]
  0000d e8 00 00 00 00     call    ??9?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator!=
  00012 0f b6 c8   movzx       ecx, al
  00015 85 c9        test        ecx, ecx
  00017 74 30        je  SHORT $LN3@Copy_backw

; 2512 :              *--_Dest = *--_Last;

  00019 8d 55 f8   lea         edx, DWORD PTR $T2[ebp]
  0001c 52                 push    edx
  0001d 8d 4d 14   lea         ecx, DWORD PTR __Last$[ebp]
  00020 e8 00 00 00 00     call    ??F?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator--
  00025 8b c8        mov         ecx, eax
  00027 e8 00 00 00 00     call    ??D?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@XZ ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator*
  0002c 50                 push    eax
  0002d 8d 45 f0   lea         eax, DWORD PTR $T1[ebp]
  00030 50                 push    eax
  00031 8d 4d 1c   lea         ecx, DWORD PTR __Dest$[ebp]
  00034 e8 00 00 00 00     call    ??F?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator--
  00039 8b c8        mov         ecx, eax
  0003b e8 00 00 00 00     call    ??D?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@XZ ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator*
  00040 8b c8        mov         ecx, eax
  00042 e8 00 00 00 00     call    ??4?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator=
  00047 eb bd        jmp         SHORT $LN2@Copy_backw
$LN3@Copy_backw:

; 2513 :        return (_Dest);

  00049 8b 4d 08   mov         ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0004c 8b 55 1c   mov         edx, DWORD PTR __Dest$[ebp]
  0004f 89 11        mov         DWORD PTR [ecx], edx
  00051 8b 45 20   mov         eax, DWORD PTR __Dest$[ebp+4]
  00054 89 41 04   mov         DWORD PTR [ecx+4], eax
  00057 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2514 :        }

  0005a 8b e5        mov         esp, ebp
  0005c 5d                 pop     ebp
  0005d c3                 ret     0
??$_Copy_backward_unchecked1@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward_unchecked1<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ??$_Ptr_copy_cat@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@0@Z
_TEXT   SEGMENT
$T1 = -1                                                ; size = 1
___formal$ = 8                                      ; size = 4
___formal$ = 12                               ; size = 4
??$_Ptr_copy_cat@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@0@Z PROC ; std::_Ptr_copy_cat<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >, COMDAT

; 698  :        {     // return pointer copy optimization category for arbitrary iterators

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx

; 699  :        return {};

  00004 33 c0        xor         eax, eax
  00006 88 45 ff   mov         BYTE PTR $T1[ebp], al
  00009 8a 45 ff   mov         al, BYTE PTR $T1[ebp]

; 700  :        }

  0000c 8b e5        mov         esp, ebp
  0000e 5d                 pop     ebp
  0000f c3                 ret     0
??$_Ptr_copy_cat@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@0@Z ENDP ; std::_Ptr_copy_cat<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ??$_Copy_unchecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00@Z
_TEXT   SEGMENT
$T1 = -1                                                ; size = 1
___$ReturnUdt$ = 8                                  ; size = 4
__First$ = 12                                     ; size = 8
__Last$ = 20                                            ; size = 8
__Dest$ = 28                                            ; size = 8
??$_Copy_unchecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00@Z PROC ; std::_Copy_unchecked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >, COMDAT

; 2282 :        {     // copy [_First, _Last) to [_Dest, ...)

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx

; 2283 :              // note: _Copy_unchecked is called directly elsewhere in the STL
; 2284 :        return (_Copy_unchecked1(_First, _Last,

  00004 8d 45 1c   lea         eax, DWORD PTR __Dest$[ebp]
  00007 50                 push    eax
  00008 8d 4d 0c   lea         ecx, DWORD PTR __First$[ebp]
  0000b 51                 push    ecx
  0000c e8 00 00 00 00     call    ??$_Ptr_copy_cat@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@0@Z ; std::_Ptr_copy_cat<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
  00011 83 c4 08   add         esp, 8
  00014 88 45 ff   mov         BYTE PTR $T1[ebp], al
  00017 0f b6 55 ff        movzx         edx, BYTE PTR $T1[ebp]
  0001b 52                 push    edx
  0001c 8b 45 20   mov         eax, DWORD PTR __Dest$[ebp+4]
  0001f 50                 push    eax
  00020 8b 4d 1c   mov         ecx, DWORD PTR __Dest$[ebp]
  00023 51                 push    ecx
  00024 8b 55 18   mov         edx, DWORD PTR __Last$[ebp+4]
  00027 52                 push    edx
  00028 8b 45 14   mov         eax, DWORD PTR __Last$[ebp]
  0002b 50                 push    eax
  0002c 8b 4d 10   mov         ecx, DWORD PTR __First$[ebp+4]
  0002f 51                 push    ecx
  00030 8b 55 0c   mov         edx, DWORD PTR __First$[ebp]
  00033 52                 push    edx
  00034 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]
  00037 50                 push    eax
  00038 e8 00 00 00 00     call    ??$_Copy_unchecked1@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z ; std::_Copy_unchecked1<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
  0003d 83 c4 20   add         esp, 32                        ; 00000020H
  00040 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2285 :              _Dest, _Ptr_copy_cat(_First, _Dest)));
; 2286 :        }

  00043 8b e5        mov         esp, ebp
  00045 5d                 pop     ebp
  00046 c3                 ret     0
??$_Copy_unchecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00@Z ENDP ; std::_Copy_unchecked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ??$_Equal@PBDPBDU?$_Cmp_icase@V?$_Regex_traits@D@std@@@std@@@std@@YA_NPBD00U?$_Cmp_icase@V?$_Regex_traits@D@std@@@0@@Z
_TEXT   SEGMENT
__First1$ = 8                                     ; size = 4
__Last1$ = 12                                     ; size = 4
__First2$ = 16                                      ; size = 4
__Pred$ = 20                                            ; size = 4
??$_Equal@PBDPBDU?$_Cmp_icase@V?$_Regex_traits@D@std@@@std@@@std@@YA_NPBD00U?$_Cmp_icase@V?$_Regex_traits@D@std@@@0@@Z PROC ; std::_Equal<char const *,char const *,std::_Cmp_icase<std::_Regex_traits<char> > >, COMDAT

; 2845 :        {     // compare [_First1, _Last1) to [_First2, ...) using _Pred

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 2846 :        for (; _First1 != _Last1; ++_First1, (void)++_First2)

  00003 eb 12        jmp         SHORT $LN4@Equal
$LN2@Equal:
  00005 8b 45 08   mov         eax, DWORD PTR __First1$[ebp]
  00008 83 c0 01   add         eax, 1
  0000b 89 45 08   mov         DWORD PTR __First1$[ebp], eax
  0000e 8b 4d 10   mov         ecx, DWORD PTR __First2$[ebp]
  00011 83 c1 01   add         ecx, 1
  00014 89 4d 10   mov         DWORD PTR __First2$[ebp], ecx
$LN4@Equal:
  00017 8b 55 08   mov         edx, DWORD PTR __First1$[ebp]
  0001a 3b 55 0c   cmp         edx, DWORD PTR __Last1$[ebp]
  0001d 74 23        je  SHORT $LN3@Equal

; 2847 :              if (!_Pred(*_First1, *_First2))

  0001f 8b 45 10   mov         eax, DWORD PTR __First2$[ebp]
  00022 0f b6 08   movzx       ecx, BYTE PTR [eax]
  00025 51                 push    ecx
  00026 8b 55 08   mov         edx, DWORD PTR __First1$[ebp]
  00029 0f b6 02   movzx       eax, BYTE PTR [edx]
  0002c 50                 push    eax
  0002d 8d 4d 14   lea         ecx, DWORD PTR __Pred$[ebp]
  00030 e8 00 00 00 00     call    ??R?$_Cmp_icase@V?$_Regex_traits@D@std@@@std@@QAE_NDD@Z ; std::_Cmp_icase<std::_Regex_traits<char> >::operator()
  00035 0f b6 c8   movzx       ecx, al
  00038 85 c9        test        ecx, ecx
  0003a 75 04        jne         SHORT $LN5@Equal

; 2848 :                  return (false);

  0003c 32 c0        xor         al, al
  0003e eb 04        jmp         SHORT $LN1@Equal
$LN5@Equal:

; 2849 :        return (true);

  00040 eb c3        jmp         SHORT $LN2@Equal
$LN3@Equal:
  00042 b0 01        mov         al, 1
$LN1@Equal:

; 2850 :        }

  00044 5d                 pop     ebp
  00045 c3                 ret     0
??$_Equal@PBDPBDU?$_Cmp_icase@V?$_Regex_traits@D@std@@@std@@@std@@YA_NPBD00U?$_Cmp_icase@V?$_Regex_traits@D@std@@@0@@Z ENDP ; std::_Equal<char const *,char const *,std::_Cmp_icase<std::_Regex_traits<char> > >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT   SEGMENT
tv68 = -4                                         ; size = 4
__Left$ = 8                                   ; size = 4
__Right$ = 12                                     ; size = 4
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z PROC ; std::operator==<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2454 :        {     // test for string equality

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx

; 2455 :        return (_Left.compare(_Right) == 0);

  00004 8b 45 0c   mov         eax, DWORD PTR __Right$[ebp]
  00007 50                 push    eax
  00008 8b 4d 08   mov         ecx, DWORD PTR __Left$[ebp]
  0000b e8 00 00 00 00     call    ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
  00010 85 c0        test        eax, eax
  00012 75 09        jne         SHORT $LN3@operator
  00014 c7 45 fc 01 00
        00 00          mov         DWORD PTR tv68[ebp], 1
  0001b eb 07        jmp         SHORT $LN4@operator
$LN3@operator:
  0001d c7 45 fc 00 00
        00 00          mov         DWORD PTR tv68[ebp], 0
$LN4@operator:
  00024 8a 45 fc   mov         al, BYTE PTR tv68[ebp]

; 2456 :        }

  00027 8b e5        mov         esp, ebp
  00029 5d                 pop     ebp
  0002a c3                 ret     0
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ENDP ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ??$transform_primary@PAD@?$_Regex_traits@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAD0@Z
_TEXT   SEGMENT
$T1 = -84                                         ; size = 4
$T2 = -80                                         ; size = 4
$T3 = -76                                         ; size = 4
$T4 = -72                                         ; size = 4
__Temp$5 = -68                                      ; size = 12
_this$ = -56                                            ; size = 4
$T6 = -52                                         ; size = 24
__Res$ = -28                                            ; size = 24
__$ArrayPad$ = -4                                 ; size = 4
___$ReturnUdt$ = 8                                  ; size = 4
__First$ = 12                                     ; size = 4
__Last$ = 16                                            ; size = 4
??$transform_primary@PAD@?$_Regex_traits@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAD0@Z PROC ; std::_Regex_traits<char>::transform_primary<char *>, COMDAT
; _this$ = ecx

; 320  :              {   // apply locale-specific case-insensitive transformation

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 54   sub         esp, 84                        ; 00000054H
  00006 a1 00 00 00 00     mov     eax, DWORD PTR ___security_cookie
  0000b 33 c5        xor         eax, ebp
  0000d 89 45 fc   mov         DWORD PTR __$ArrayPad$[ebp], eax
  00010 56                 push    esi
  00011 89 4d c8   mov         DWORD PTR _this$[ebp], ecx

; 321  :              string_type _Res;

  00014 8d 4d e4   lea         ecx, DWORD PTR __Res$[ebp]
  00017 e8 00 00 00 00     call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 322  :
; 323  :              if (_First != _Last)

  0001c 8b 45 0c   mov         eax, DWORD PTR __First$[ebp]
  0001f 3b 45 10   cmp         eax, DWORD PTR __Last$[ebp]
  00022 0f 84 b3 00 00
        00           je      $LN2@transform_

; 324  :                  {       // non-empty string, transform it
; 325  :                  vector<_Elem> _Temp(_First, _Last);

  00028 8b 4d 10   mov         ecx, DWORD PTR __Last$[ebp]
  0002b 51                 push    ecx
  0002c 8b 55 0c   mov         edx, DWORD PTR __First$[ebp]
  0002f 52                 push    edx
  00030 8d 4d bc   lea         ecx, DWORD PTR __Temp$5[ebp]
  00033 e8 00 00 00 00     call    ??$?0PADX@?$vector@DV?$allocator@D@std@@@std@@QAE@PAD0@Z ; std::vector<char,std::allocator<char> >::vector<char,std::allocator<char> ><char *,void>

; 326  :
; 327  :                  _Getctype()->tolower(&*_Temp.begin(),

  00038 8d 45 b8   lea         eax, DWORD PTR $T4[ebp]
  0003b 50                 push    eax
  0003c 8d 4d bc   lea         ecx, DWORD PTR __Temp$5[ebp]
  0003f e8 00 00 00 00     call    ?begin@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::vector<char,std::allocator<char> >::begin
  00044 8b c8        mov         ecx, eax
  00046 e8 00 00 00 00     call    ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<char> > >::operator*
  0004b 8b f0        mov         esi, eax
  0004d 8d 4d bc   lea         ecx, DWORD PTR __Temp$5[ebp]
  00050 e8 00 00 00 00     call    ?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
  00055 03 f0        add         esi, eax
  00057 56                 push    esi
  00058 8d 4d b4   lea         ecx, DWORD PTR $T3[ebp]
  0005b 51                 push    ecx
  0005c 8d 4d bc   lea         ecx, DWORD PTR __Temp$5[ebp]
  0005f e8 00 00 00 00     call    ?begin@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::vector<char,std::allocator<char> >::begin
  00064 8b c8        mov         ecx, eax
  00066 e8 00 00 00 00     call    ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<char> > >::operator*
  0006b 50                 push    eax
  0006c 8b 4d c8   mov         ecx, DWORD PTR _this$[ebp]
  0006f e8 00 00 00 00     call    ?_Getctype@?$_Regex_traits@D@std@@QBEPBV?$ctype@D@2@XZ ; std::_Regex_traits<char>::_Getctype
  00074 8b c8        mov         ecx, eax
  00076 e8 00 00 00 00     call    ?tolower@?$ctype@D@std@@QBEPBDPADPBD@Z ; std::ctype<char>::tolower

; 328  :                          &*_Temp.begin() + _Temp.size());
; 329  :                  _Res = _Getcoll()->transform(&*_Temp.begin(),

  0007b 8d 55 b0   lea         edx, DWORD PTR $T2[ebp]
  0007e 52                 push    edx
  0007f 8d 4d bc   lea         ecx, DWORD PTR __Temp$5[ebp]
  00082 e8 00 00 00 00     call    ?begin@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::vector<char,std::allocator<char> >::begin
  00087 8b c8        mov         ecx, eax
  00089 e8 00 00 00 00     call    ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<char> > >::operator*
  0008e 8b f0        mov         esi, eax
  00090 8d 4d bc   lea         ecx, DWORD PTR __Temp$5[ebp]
  00093 e8 00 00 00 00     call    ?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
  00098 03 f0        add         esi, eax
  0009a 56                 push    esi
  0009b 8d 45 ac   lea         eax, DWORD PTR $T1[ebp]
  0009e 50                 push    eax
  0009f 8d 4d bc   lea         ecx, DWORD PTR __Temp$5[ebp]
  000a2 e8 00 00 00 00     call    ?begin@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::vector<char,std::allocator<char> >::begin
  000a7 8b c8        mov         ecx, eax
  000a9 e8 00 00 00 00     call    ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<char> > >::operator*
  000ae 50                 push    eax
  000af 8d 4d cc   lea         ecx, DWORD PTR $T6[ebp]
  000b2 51                 push    ecx
  000b3 8b 4d c8   mov         ecx, DWORD PTR _this$[ebp]
  000b6 e8 00 00 00 00     call    ?_Getcoll@?$_Regex_traits@D@std@@QBEPBV?$collate@D@2@XZ ; std::_Regex_traits<char>::_Getcoll
  000bb 8b c8        mov         ecx, eax
  000bd e8 00 00 00 00     call    ?transform@?$collate@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PBD0@Z ; std::collate<char>::transform
  000c2 50                 push    eax
  000c3 8d 4d e4   lea         ecx, DWORD PTR __Res$[ebp]
  000c6 e8 00 00 00 00     call    ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
  000cb 8d 4d cc   lea         ecx, DWORD PTR $T6[ebp]
  000ce e8 00 00 00 00     call    ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 330  :                          &*_Temp.begin() + _Temp.size());
; 331  :                  }

  000d3 8d 4d bc   lea         ecx, DWORD PTR __Temp$5[ebp]
  000d6 e8 00 00 00 00     call    ??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ ; std::vector<char,std::allocator<char> >::~vector<char,std::allocator<char> >
$LN2@transform_:

; 332  :              return (_Res);

  000db 8d 55 e4   lea         edx, DWORD PTR __Res$[ebp]
  000de 52                 push    edx
  000df 8b 4d 08   mov         ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000e2 e8 00 00 00 00     call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  000e7 8d 4d e4   lea         ecx, DWORD PTR __Res$[ebp]
  000ea e8 00 00 00 00     call    ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  000ef 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]

; 333  :              }

  000f2 5e                 pop     esi
  000f3 8b 4d fc   mov         ecx, DWORD PTR __$ArrayPad$[ebp]
  000f6 33 cd        xor         ecx, ebp
  000f8 e8 00 00 00 00     call    @__security_check_cookie@4
  000fd 8b e5        mov         esp, ebp
  000ff 5d                 pop     ebp
  00100 c2 0c 00   ret         12           ; 0000000cH
??$transform_primary@PAD@?$_Regex_traits@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAD0@Z ENDP ; std::_Regex_traits<char>::transform_primary<char *>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ??$transform_primary@PBD@?$_Regex_traits@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PBD0@Z
_TEXT   SEGMENT
$T1 = -84                                         ; size = 4
$T2 = -80                                         ; size = 4
$T3 = -76                                         ; size = 4
$T4 = -72                                         ; size = 4
__Temp$5 = -68                                      ; size = 12
_this$ = -56                                            ; size = 4
$T6 = -52                                         ; size = 24
__Res$ = -28                                            ; size = 24
__$ArrayPad$ = -4                                 ; size = 4
___$ReturnUdt$ = 8                                  ; size = 4
__First$ = 12                                     ; size = 4
__Last$ = 16                                            ; size = 4
??$transform_primary@PBD@?$_Regex_traits@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PBD0@Z PROC ; std::_Regex_traits<char>::transform_primary<char const *>, COMDAT
; _this$ = ecx

; 320  :              {   // apply locale-specific case-insensitive transformation

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 54   sub         esp, 84                        ; 00000054H
  00006 a1 00 00 00 00     mov     eax, DWORD PTR ___security_cookie
  0000b 33 c5        xor         eax, ebp
  0000d 89 45 fc   mov         DWORD PTR __$ArrayPad$[ebp], eax
  00010 56                 push    esi
  00011 89 4d c8   mov         DWORD PTR _this$[ebp], ecx

; 321  :              string_type _Res;

  00014 8d 4d e4   lea         ecx, DWORD PTR __Res$[ebp]
  00017 e8 00 00 00 00     call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 322  :
; 323  :              if (_First != _Last)

  0001c 8b 45 0c   mov         eax, DWORD PTR __First$[ebp]
  0001f 3b 45 10   cmp         eax, DWORD PTR __Last$[ebp]
  00022 0f 84 b3 00 00
        00           je      $LN2@transform_

; 324  :                  {       // non-empty string, transform it
; 325  :                  vector<_Elem> _Temp(_First, _Last);

  00028 8b 4d 10   mov         ecx, DWORD PTR __Last$[ebp]
  0002b 51                 push    ecx
  0002c 8b 55 0c   mov         edx, DWORD PTR __First$[ebp]
  0002f 52                 push    edx
  00030 8d 4d bc   lea         ecx, DWORD PTR __Temp$5[ebp]
  00033 e8 00 00 00 00     call    ??$?0PBDX@?$vector@DV?$allocator@D@std@@@std@@QAE@PBD0@Z ; std::vector<char,std::allocator<char> >::vector<char,std::allocator<char> ><char const *,void>

; 326  :
; 327  :                  _Getctype()->tolower(&*_Temp.begin(),

  00038 8d 45 b8   lea         eax, DWORD PTR $T4[ebp]
  0003b 50                 push    eax
  0003c 8d 4d bc   lea         ecx, DWORD PTR __Temp$5[ebp]
  0003f e8 00 00 00 00     call    ?begin@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::vector<char,std::allocator<char> >::begin
  00044 8b c8        mov         ecx, eax
  00046 e8 00 00 00 00     call    ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<char> > >::operator*
  0004b 8b f0        mov         esi, eax
  0004d 8d 4d bc   lea         ecx, DWORD PTR __Temp$5[ebp]
  00050 e8 00 00 00 00     call    ?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
  00055 03 f0        add         esi, eax
  00057 56                 push    esi
  00058 8d 4d b4   lea         ecx, DWORD PTR $T3[ebp]
  0005b 51                 push    ecx
  0005c 8d 4d bc   lea         ecx, DWORD PTR __Temp$5[ebp]
  0005f e8 00 00 00 00     call    ?begin@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::vector<char,std::allocator<char> >::begin
  00064 8b c8        mov         ecx, eax
  00066 e8 00 00 00 00     call    ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<char> > >::operator*
  0006b 50                 push    eax
  0006c 8b 4d c8   mov         ecx, DWORD PTR _this$[ebp]
  0006f e8 00 00 00 00     call    ?_Getctype@?$_Regex_traits@D@std@@QBEPBV?$ctype@D@2@XZ ; std::_Regex_traits<char>::_Getctype
  00074 8b c8        mov         ecx, eax
  00076 e8 00 00 00 00     call    ?tolower@?$ctype@D@std@@QBEPBDPADPBD@Z ; std::ctype<char>::tolower

; 328  :                          &*_Temp.begin() + _Temp.size());
; 329  :                  _Res = _Getcoll()->transform(&*_Temp.begin(),

  0007b 8d 55 b0   lea         edx, DWORD PTR $T2[ebp]
  0007e 52                 push    edx
  0007f 8d 4d bc   lea         ecx, DWORD PTR __Temp$5[ebp]
  00082 e8 00 00 00 00     call    ?begin@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::vector<char,std::allocator<char> >::begin
  00087 8b c8        mov         ecx, eax
  00089 e8 00 00 00 00     call    ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<char> > >::operator*
  0008e 8b f0        mov         esi, eax
  00090 8d 4d bc   lea         ecx, DWORD PTR __Temp$5[ebp]
  00093 e8 00 00 00 00     call    ?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
  00098 03 f0        add         esi, eax
  0009a 56                 push    esi
  0009b 8d 45 ac   lea         eax, DWORD PTR $T1[ebp]
  0009e 50                 push    eax
  0009f 8d 4d bc   lea         ecx, DWORD PTR __Temp$5[ebp]
  000a2 e8 00 00 00 00     call    ?begin@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::vector<char,std::allocator<char> >::begin
  000a7 8b c8        mov         ecx, eax
  000a9 e8 00 00 00 00     call    ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<char> > >::operator*
  000ae 50                 push    eax
  000af 8d 4d cc   lea         ecx, DWORD PTR $T6[ebp]
  000b2 51                 push    ecx
  000b3 8b 4d c8   mov         ecx, DWORD PTR _this$[ebp]
  000b6 e8 00 00 00 00     call    ?_Getcoll@?$_Regex_traits@D@std@@QBEPBV?$collate@D@2@XZ ; std::_Regex_traits<char>::_Getcoll
  000bb 8b c8        mov         ecx, eax
  000bd e8 00 00 00 00     call    ?transform@?$collate@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PBD0@Z ; std::collate<char>::transform
  000c2 50                 push    eax
  000c3 8d 4d e4   lea         ecx, DWORD PTR __Res$[ebp]
  000c6 e8 00 00 00 00     call    ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
  000cb 8d 4d cc   lea         ecx, DWORD PTR $T6[ebp]
  000ce e8 00 00 00 00     call    ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 330  :                          &*_Temp.begin() + _Temp.size());
; 331  :                  }

  000d3 8d 4d bc   lea         ecx, DWORD PTR __Temp$5[ebp]
  000d6 e8 00 00 00 00     call    ??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ ; std::vector<char,std::allocator<char> >::~vector<char,std::allocator<char> >
$LN2@transform_:

; 332  :              return (_Res);

  000db 8d 55 e4   lea         edx, DWORD PTR __Res$[ebp]
  000de 52                 push    edx
  000df 8b 4d 08   mov         ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000e2 e8 00 00 00 00     call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  000e7 8d 4d e4   lea         ecx, DWORD PTR __Res$[ebp]
  000ea e8 00 00 00 00     call    ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  000ef 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]

; 333  :              }

  000f2 5e                 pop     esi
  000f3 8b 4d fc   mov         ecx, DWORD PTR __$ArrayPad$[ebp]
  000f6 33 cd        xor         ecx, ebp
  000f8 e8 00 00 00 00     call    @__security_check_cookie@4
  000fd 8b e5        mov         esp, ebp
  000ff 5d                 pop     ebp
  00100 c2 0c 00   ret         12           ; 0000000cH
??$transform_primary@PBD@?$_Regex_traits@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PBD0@Z ENDP ; std::_Regex_traits<char>::transform_primary<char const *>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ??$_Rechecked@PAIPAI@std@@YAAAPAIAAPAIPAI@Z
_TEXT   SEGMENT
__Dest$ = 8                                   ; size = 4
__Src$ = 12                                   ; size = 4
??$_Rechecked@PAIPAI@std@@YAAAPAIAAPAIPAI@Z PROC        ; std::_Rechecked<unsigned int *,unsigned int *>, COMDAT

; 465  :        {     // reset checked from unchecked, generic

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 466  :        _Dest = _Src;

  00003 8b 45 08   mov         eax, DWORD PTR __Dest$[ebp]
  00006 8b 4d 0c   mov         ecx, DWORD PTR __Src$[ebp]
  00009 89 08        mov         DWORD PTR [eax], ecx

; 467  :        return (_Dest);

  0000b 8b 45 08   mov         eax, DWORD PTR __Dest$[ebp]

; 468  :        }

  0000e 5d                 pop     ebp
  0000f c3                 ret     0
??$_Rechecked@PAIPAI@std@@YAAAPAIAAPAIPAI@Z ENDP        ; std::_Rechecked<unsigned int *,unsigned int *>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;       COMDAT ??$_Uninitialized_move_al_unchecked@PAIPAIU?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAPAIPAI00AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z
_TEXT   SEGMENT
$T1 = -1                                                ; size = 1
__First$ = 8                                            ; size = 4
__Last$ = 12                                            ; size = 4
__Dest$ = 16                                            ; size = 4
__Al$ = 20                                          ; size = 4
??$_Uninitialized_move_al_unchecked@PAIPAIU?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAPAIPAI00AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z PROC ; std::_Uninitialized_move_al_unchecked<unsigned int *,unsigned int *,std::_Wrap_alloc<std::allocator<unsigned int> > >, COMDAT

; 345  :        {     // move [_First, _Last) to raw _Dest, using _Al, choose optimization

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx

; 346  :        return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

  00004 8d 45 10   lea         eax, DWORD PTR __Dest$[ebp]
  00007 50                 push    eax
  00008 8d 4d 08   lea         ecx, DWORD PTR __First$[ebp]
  0000b 51                 push    ecx
  0000c 8d 55 ff   lea         edx, DWORD PTR $T1[ebp]
  0000f 52                 push    edx
  00010 e8 00 00 00 00     call    ??$_Ptr_move_cat@II@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAI0@Z ; std::_Ptr_move_cat<unsigned int,unsigned int>
  00015 83 c4 0c   add         esp, 12                        ; 0000000cH
  00018 8a 00        mov         al, BYTE PTR [eax]
  0001a 0f b6 c8   movzx       ecx, al
  0001d 51                 push    ecx
  0001e 8b 55 14   mov         edx, DWORD PTR __Al$[ebp]
  00021 52                 push    edx
  00022 8b 45 10   mov         eax, DWORD PTR __Dest$[ebp]
  00025 50                 push    eax
  00026 8b 4d 0c   mov         ecx, DWORD PTR __Last$[ebp]
  00029 51                 push    ecx
  0002a 8b 55 08   mov         edx, DWORD PTR __First$[ebp]
  0002d 52                 push    edx
  0002e e8 00 00 00 00     call    ??$_Uninitialized_move_al_unchecked1@II@std@@YAPAIPAI00AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U_Really_trivial_ptr_iterator_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<unsigned int,unsigned int>
  00033 83 c4 14   add         esp, 20                        ; 00000014H

; 347  :              _Ptr_move_cat(_First, _Dest)));
; 348  :        }

  00036 8b e5        mov         esp, ebp
  00038 5d                 pop     ebp
  00039 c3                 ret     0
??$_Uninitialized_move_al_unchecked@PAIPAIU?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAPAIPAI00AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked<unsigned int *,unsigned int *,std::_Wrap_alloc<std::allocator<unsigned int> > >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ??$_Unchecked@PAI@std@@YAPAIPAI@Z
_TEXT   SEGMENT
__Src$ = 8                                          ; size = 4
??$_Unchecked@PAI@std@@YAPAIPAI@Z PROC              ; std::_Unchecked<unsigned int *>, COMDAT

; 438  :        {     // construct unchecked from checked, generic

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 439  :        return (_Src);

  00003 8b 45 08   mov         eax, DWORD PTR __Src$[ebp]

; 440  :        }

  00006 5d                 pop     ebp
  00007 c3                 ret     0
??$_Unchecked@PAI@std@@YAPAIPAI@Z ENDP              ; std::_Unchecked<unsigned int *>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ??$_Rechecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YAAAV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@AAV10@V10@@Z
_TEXT   SEGMENT
__Dest$ = 8                                   ; size = 4
__Src$ = 12                                   ; size = 8
??$_Rechecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YAAAV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@AAV10@V10@@Z PROC ; std::_Rechecked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >, COMDAT

; 465  :        {     // reset checked from unchecked, generic

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 466  :        _Dest = _Src;

  00003 8b 45 08   mov         eax, DWORD PTR __Dest$[ebp]
  00006 8b 4d 0c   mov         ecx, DWORD PTR __Src$[ebp]
  00009 89 08        mov         DWORD PTR [eax], ecx
  0000b 8b 55 10   mov         edx, DWORD PTR __Src$[ebp+4]
  0000e 89 50 04   mov         DWORD PTR [eax+4], edx

; 467  :        return (_Dest);

  00011 8b 45 08   mov         eax, DWORD PTR __Dest$[ebp]

; 468  :        }

  00014 5d                 pop     ebp
  00015 c3                 ret     0
??$_Rechecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YAAAV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@AAV10@V10@@Z ENDP ; std::_Rechecked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ??$_Copy_backward_unchecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00@Z
_TEXT   SEGMENT
$T1 = -1                                                ; size = 1
___$ReturnUdt$ = 8                                  ; size = 4
__First$ = 12                                     ; size = 8
__Last$ = 20                                            ; size = 8
__Dest$ = 28                                            ; size = 8
??$_Copy_backward_unchecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00@Z PROC ; std::_Copy_backward_unchecked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >, COMDAT

; 2528 :        {     // copy [_First, _Last) backwards to [..., _Dest), choose optimization

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx

; 2529 :        return (_Copy_backward_unchecked1(_First, _Last,

  00004 8d 45 1c   lea         eax, DWORD PTR __Dest$[ebp]
  00007 50                 push    eax
  00008 8d 4d 0c   lea         ecx, DWORD PTR __First$[ebp]
  0000b 51                 push    ecx
  0000c e8 00 00 00 00     call    ??$_Ptr_copy_cat@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@0@Z ; std::_Ptr_copy_cat<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
  00011 83 c4 08   add         esp, 8
  00014 88 45 ff   mov         BYTE PTR $T1[ebp], al
  00017 0f b6 55 ff        movzx         edx, BYTE PTR $T1[ebp]
  0001b 52                 push    edx
  0001c 8b 45 20   mov         eax, DWORD PTR __Dest$[ebp+4]
  0001f 50                 push    eax
  00020 8b 4d 1c   mov         ecx, DWORD PTR __Dest$[ebp]
  00023 51                 push    ecx
  00024 8b 55 18   mov         edx, DWORD PTR __Last$[ebp+4]
  00027 52                 push    edx
  00028 8b 45 14   mov         eax, DWORD PTR __Last$[ebp]
  0002b 50                 push    eax
  0002c 8b 4d 10   mov         ecx, DWORD PTR __First$[ebp+4]
  0002f 51                 push    ecx
  00030 8b 55 0c   mov         edx, DWORD PTR __First$[ebp]
  00033 52                 push    edx
  00034 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]
  00037 50                 push    eax
  00038 e8 00 00 00 00     call    ??$_Copy_backward_unchecked1@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z ; std::_Copy_backward_unchecked1<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
  0003d 83 c4 20   add         esp, 32                        ; 00000020H
  00040 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2530 :              _Dest, _Ptr_copy_cat(_First, _Dest)));
; 2531 :        }

  00043 8b e5        mov         esp, ebp
  00045 5d                 pop     ebp
  00046 c3                 ret     0
??$_Copy_backward_unchecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00@Z ENDP ; std::_Copy_backward_unchecked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ??$_Copy_no_deprecate1@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@1@Z
_TEXT   SEGMENT
$T1 = -24                                         ; size = 8
$T2 = -16                                         ; size = 8
$T3 = -8                                                ; size = 8
___$ReturnUdt$ = 8                                  ; size = 4
__First$ = 12                                     ; size = 8
__Last$ = 20                                            ; size = 8
__Dest$ = 28                                            ; size = 8
___formal$ = 36                               ; size = 1
___formal$ = 40                               ; size = 1
??$_Copy_no_deprecate1@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@1@Z PROC ; std::_Copy_no_deprecate1<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >, COMDAT

; 2301 :        {     // copy [_First, _Last) to [_Dest, ...), random-access iterators

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 18   sub         esp, 24                        ; 00000018H

; 2302 :        static_cast<void>(_Dest + (_Last - _First));  // checks range

  00006 8d 45 0c   lea         eax, DWORD PTR __First$[ebp]
  00009 50                 push    eax
  0000a 8d 4d 14   lea         ecx, DWORD PTR __Last$[ebp]
  0000d e8 00 00 00 00     call    ??G?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEHABV?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@@Z ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator-
  00012 50                 push    eax
  00013 8d 4d f8   lea         ecx, DWORD PTR $T3[ebp]
  00016 51                 push    ecx
  00017 8d 4d 1c   lea         ecx, DWORD PTR __Dest$[ebp]
  0001a e8 00 00 00 00     call    ??H?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator+

; 2303 :        return (_Rechecked(_Dest,

  0001f 8b 55 20   mov         edx, DWORD PTR __Dest$[ebp+4]
  00022 52                 push    edx
  00023 8b 45 1c   mov         eax, DWORD PTR __Dest$[ebp]
  00026 50                 push    eax
  00027 8d 4d f0   lea         ecx, DWORD PTR $T2[ebp]
  0002a 51                 push    ecx
  0002b e8 00 00 00 00     call    ??$_Unchecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@@Z ; std::_Unchecked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
  00030 83 c4 0c   add         esp, 12                        ; 0000000cH
  00033 8b 50 04   mov         edx, DWORD PTR [eax+4]
  00036 52                 push    edx
  00037 8b 00        mov         eax, DWORD PTR [eax]
  00039 50                 push    eax
  0003a 8b 4d 18   mov         ecx, DWORD PTR __Last$[ebp+4]
  0003d 51                 push    ecx
  0003e 8b 55 14   mov         edx, DWORD PTR __Last$[ebp]
  00041 52                 push    edx
  00042 8b 45 10   mov         eax, DWORD PTR __First$[ebp+4]
  00045 50                 push    eax
  00046 8b 4d 0c   mov         ecx, DWORD PTR __First$[ebp]
  00049 51                 push    ecx
  0004a 8d 55 e8   lea         edx, DWORD PTR $T1[ebp]
  0004d 52                 push    edx
  0004e e8 00 00 00 00     call    ??$_Copy_unchecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00@Z ; std::_Copy_unchecked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
  00053 83 c4 1c   add         esp, 28                        ; 0000001cH
  00056 8b 48 04   mov         ecx, DWORD PTR [eax+4]
  00059 51                 push    ecx
  0005a 8b 10        mov         edx, DWORD PTR [eax]
  0005c 52                 push    edx
  0005d 8d 45 1c   lea         eax, DWORD PTR __Dest$[ebp]
  00060 50                 push    eax
  00061 e8 00 00 00 00     call    ??$_Rechecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YAAAV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@AAV10@V10@@Z ; std::_Rechecked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
  00066 83 c4 0c   add         esp, 12                        ; 0000000cH
  00069 8b 08        mov         ecx, DWORD PTR [eax]
  0006b 8b 50 04   mov         edx, DWORD PTR [eax+4]
  0006e 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]
  00071 89 08        mov         DWORD PTR [eax], ecx
  00073 89 50 04   mov         DWORD PTR [eax+4], edx
  00076 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2304 :              _Copy_unchecked(_First, _Last, _Unchecked(_Dest))));
; 2305 :        }

  00079 8b e5        mov         esp, ebp
  0007b 5d                 pop     ebp
  0007c c3                 ret     0
??$_Copy_no_deprecate1@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@1@Z ENDP ; std::_Copy_no_deprecate1<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ??$_Fill_unchecked1@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@0AB_NU?$integral_constant@_N$0A@@0@@Z
_TEXT   SEGMENT
$T1 = -8                                                ; size = 8
__First$ = 8                                            ; size = 8
__Last$ = 16                                            ; size = 8
__Val$ = 24                                   ; size = 4
___formal$ = 28                               ; size = 1
??$_Fill_unchecked1@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@0AB_NU?$integral_constant@_N$0A@@0@@Z PROC ; std::_Fill_unchecked1<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,bool>, COMDAT

; 2753 :        {     // copy _Val through [_First, _Last), no special optimization

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8

; 2754 :        for (; _First != _Last; ++_First)

  00006 eb 08        jmp         SHORT $LN4@Fill_unche
$LN2@Fill_unche:
  00008 8d 4d 08   lea         ecx, DWORD PTR __First$[ebp]
  0000b e8 00 00 00 00     call    ??E?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator++
$LN4@Fill_unche:
  00010 8d 45 10   lea         eax, DWORD PTR __Last$[ebp]
  00013 50                 push    eax
  00014 8d 4d 08   lea         ecx, DWORD PTR __First$[ebp]
  00017 e8 00 00 00 00     call    ??9?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator!=
  0001c 0f b6 c8   movzx       ecx, al
  0001f 85 c9        test        ecx, ecx
  00021 74 1c        je  SHORT $LN1@Fill_unche

; 2755 :              *_First = _Val;

  00023 8b 55 18   mov         edx, DWORD PTR __Val$[ebp]
  00026 0f b6 02   movzx       eax, BYTE PTR [edx]
  00029 50                 push    eax
  0002a 8d 4d f8   lea         ecx, DWORD PTR $T1[ebp]
  0002d 51                 push    ecx
  0002e 8d 4d 08   lea         ecx, DWORD PTR __First$[ebp]
  00031 e8 00 00 00 00     call    ??D?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@XZ ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator*
  00036 8b c8        mov         ecx, eax
  00038 e8 00 00 00 00     call    ??4?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@_N@Z ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator=
  0003d eb c9        jmp         SHORT $LN2@Fill_unche
$LN1@Fill_unche:

; 2756 :        }

  0003f 8b e5        mov         esp, ebp
  00041 5d                 pop     ebp
  00042 c3                 ret     0
??$_Fill_unchecked1@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@0AB_NU?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Fill_unchecked1<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,bool>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ??$_Fill_memset_is_safe@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@_N@std@@YA?AU?$integral_constant@_N$0A@@0@ABV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@AB_N@Z
_TEXT   SEGMENT
$T1 = -1                                                ; size = 1
___formal$ = 8                                      ; size = 4
___formal$ = 12                               ; size = 4
??$_Fill_memset_is_safe@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@_N@std@@YA?AU?$integral_constant@_N$0A@@0@ABV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@AB_N@Z PROC ; std::_Fill_memset_is_safe<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,bool>, COMDAT

; 2746 :        {     // type deduction for _Fill_memset_is_safe_helper

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx

; 2747 :        return {};

  00004 33 c0        xor         eax, eax
  00006 88 45 ff   mov         BYTE PTR $T1[ebp], al
  00009 8a 45 ff   mov         al, BYTE PTR $T1[ebp]

; 2748 :        }

  0000c 8b e5        mov         esp, ebp
  0000e 5d                 pop     ebp
  0000f c3                 ret     0
??$_Fill_memset_is_safe@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@_N@std@@YA?AU?$integral_constant@_N$0A@@0@ABV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@AB_N@Z ENDP ; std::_Fill_memset_is_safe<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,bool>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ??$_Equal@PBDPBDU?$_Cmp_icase@V?$_Regex_traits@D@std@@@std@@@std@@YA_NPBD000U?$_Cmp_icase@V?$_Regex_traits@D@std@@@0@Urandom_access_iterator_tag@0@2@Z
_TEXT   SEGMENT
__First1$ = 8                                     ; size = 4
__Last1$ = 12                                     ; size = 4
__First2$ = 16                                      ; size = 4
__Last2$ = 20                                     ; size = 4
__Pred$ = 24                                            ; size = 4
___formal$ = 28                               ; size = 1
___formal$ = 32                               ; size = 1
??$_Equal@PBDPBDU?$_Cmp_icase@V?$_Regex_traits@D@std@@@std@@@std@@YA_NPBD000U?$_Cmp_icase@V?$_Regex_traits@D@std@@@0@Urandom_access_iterator_tag@0@2@Z PROC ; std::_Equal<char const *,char const *,std::_Cmp_icase<std::_Regex_traits<char> > >, COMDAT

; 2979 :        {     // compare [_First1, _Last1) to [_First2, _Last2)

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 2980 :              // using _Pred, random-access iterators
; 2981 :        if (_Last1 - _First1 != _Last2 - _First2)

  00003 8b 45 0c   mov         eax, DWORD PTR __Last1$[ebp]
  00006 2b 45 08   sub         eax, DWORD PTR __First1$[ebp]
  00009 8b 4d 14   mov         ecx, DWORD PTR __Last2$[ebp]
  0000c 2b 4d 10   sub         ecx, DWORD PTR __First2$[ebp]
  0000f 3b c1        cmp         eax, ecx
  00011 74 04        je  SHORT $LN2@Equal

; 2982 :              return (false);

  00013 32 c0        xor         al, al
  00015 eb 18        jmp         SHORT $LN1@Equal
$LN2@Equal:

; 2983 :        _DEBUG_POINTER_IF(_First1 != _Last1, _Pred);
; 2984 :        return (_Equal(_First1, _Last1, _First2, _Pred));

  00017 8b 55 18   mov         edx, DWORD PTR __Pred$[ebp]
  0001a 52                 push    edx
  0001b 8b 45 10   mov         eax, DWORD PTR __First2$[ebp]
  0001e 50                 push    eax
  0001f 8b 4d 0c   mov         ecx, DWORD PTR __Last1$[ebp]
  00022 51                 push    ecx
  00023 8b 55 08   mov         edx, DWORD PTR __First1$[ebp]
  00026 52                 push    edx
  00027 e8 00 00 00 00     call    ??$_Equal@PBDPBDU?$_Cmp_icase@V?$_Regex_traits@D@std@@@std@@@std@@YA_NPBD00U?$_Cmp_icase@V?$_Regex_traits@D@std@@@0@@Z ; std::_Equal<char const *,char const *,std::_Cmp_icase<std::_Regex_traits<char> > >
  0002c 83 c4 10   add         esp, 16                        ; 00000010H
$LN1@Equal:

; 2985 :        }

  0002f 5d                 pop     ebp
  00030 c3                 ret     0
??$_Equal@PBDPBDU?$_Cmp_icase@V?$_Regex_traits@D@std@@@std@@@std@@YA_NPBD000U?$_Cmp_icase@V?$_Regex_traits@D@std@@@0@Urandom_access_iterator_tag@0@2@Z ENDP ; std::_Equal<char const *,char const *,std::_Cmp_icase<std::_Regex_traits<char> > >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ??$_Iter_cat@PBD@std@@YA?AUrandom_access_iterator_tag@0@ABQBD@Z
_TEXT   SEGMENT
___$ReturnUdt$ = 8                                  ; size = 4
___formal$ = 12                               ; size = 4
??$_Iter_cat@PBD@std@@YA?AUrandom_access_iterator_tag@0@ABQBD@Z PROC ; std::_Iter_cat<char const *>, COMDAT

; 639  :        {     // return category from iterator argument

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 640  :        return {};

  00003 33 c0        xor         eax, eax
  00005 8b 4d 08   mov         ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00008 88 01        mov         BYTE PTR [ecx], al
  0000a 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]

; 641  :        }

  0000d 5d                 pop     ebp
  0000e c3                 ret     0
??$_Iter_cat@PBD@std@@YA?AUrandom_access_iterator_tag@0@ABQBD@Z ENDP ; std::_Iter_cat<char const *>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ??$_Unchecked@PBD@std@@YAPBDPBD@Z
_TEXT   SEGMENT
__Src$ = 8                                          ; size = 4
??$_Unchecked@PBD@std@@YAPBDPBD@Z PROC              ; std::_Unchecked<char const *>, COMDAT

; 438  :        {     // construct unchecked from checked, generic

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 439  :        return (_Src);

  00003 8b 45 08   mov         eax, DWORD PTR __Src$[ebp]

; 440  :        }

  00006 5d                 pop     ebp
  00007 c3                 ret     0
??$_Unchecked@PBD@std@@YAPBDPBD@Z ENDP              ; std::_Unchecked<char const *>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;       COMDAT ??$_Uninitialized_move@PAIPAIU?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAPAIPAI00AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z
_TEXT   SEGMENT
__First$ = 8                                            ; size = 4
__Last$ = 12                                            ; size = 4
__Dest$ = 16                                            ; size = 4
__Al$ = 20                                          ; size = 4
??$_Uninitialized_move@PAIPAIU?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAPAIPAI00AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z PROC ; std::_Uninitialized_move<unsigned int *,unsigned int *,std::_Wrap_alloc<std::allocator<unsigned int> > >, COMDAT

; 355  :        {     // move [_First, _Last) to raw _Dest, using _Al

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 356  :              // note: only called internally from elsewhere in the STL, debug checks
; 357  :              // and deprecation warnings omitted
; 358  :        return (_Rechecked(_Dest,

  00003 8b 45 14   mov         eax, DWORD PTR __Al$[ebp]
  00006 50                 push    eax
  00007 8b 4d 10   mov         ecx, DWORD PTR __Dest$[ebp]
  0000a 51                 push    ecx
  0000b e8 00 00 00 00     call    ??$_Unchecked@PAI@std@@YAPAIPAI@Z ; std::_Unchecked<unsigned int *>
  00010 83 c4 04   add         esp, 4
  00013 50                 push    eax
  00014 8b 55 0c   mov         edx, DWORD PTR __Last$[ebp]
  00017 52                 push    edx
  00018 e8 00 00 00 00     call    ??$_Unchecked@PAI@std@@YAPAIPAI@Z ; std::_Unchecked<unsigned int *>
  0001d 83 c4 04   add         esp, 4
  00020 50                 push    eax
  00021 8b 45 08   mov         eax, DWORD PTR __First$[ebp]
  00024 50                 push    eax
  00025 e8 00 00 00 00     call    ??$_Unchecked@PAI@std@@YAPAIPAI@Z ; std::_Unchecked<unsigned int *>
  0002a 83 c4 04   add         esp, 4
  0002d 50                 push    eax
  0002e e8 00 00 00 00     call    ??$_Uninitialized_move_al_unchecked@PAIPAIU?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAPAIPAI00AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z ; std::_Uninitialized_move_al_unchecked<unsigned int *,unsigned int *,std::_Wrap_alloc<std::allocator<unsigned int> > >
  00033 83 c4 10   add         esp, 16                        ; 00000010H
  00036 50                 push    eax
  00037 8d 4d 10   lea         ecx, DWORD PTR __Dest$[ebp]
  0003a 51                 push    ecx
  0003b e8 00 00 00 00     call    ??$_Rechecked@PAIPAI@std@@YAAAPAIAAPAIPAI@Z ; std::_Rechecked<unsigned int *,unsigned int *>
  00040 83 c4 08   add         esp, 8
  00043 8b 00        mov         eax, DWORD PTR [eax]

; 359  :              _Uninitialized_move_al_unchecked(_Unchecked(_First), _Unchecked(_Last),
; 360  :                  _Unchecked(_Dest), _Al)));
; 361  :        }

  00045 5d                 pop     ebp
  00046 c3                 ret     0
??$_Uninitialized_move@PAIPAIU?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAPAIPAI00AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z ENDP ; std::_Uninitialized_move<unsigned int *,unsigned int *,std::_Wrap_alloc<std::allocator<unsigned int> > >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ??$_Copy_backward1@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@1@Z
_TEXT   SEGMENT
$T1 = -24                                         ; size = 8
$T2 = -16                                         ; size = 8
$T3 = -8                                                ; size = 8
___$ReturnUdt$ = 8                                  ; size = 4
__First$ = 12                                     ; size = 8
__Last$ = 20                                            ; size = 8
__Dest$ = 28                                            ; size = 8
___formal$ = 36                               ; size = 1
___formal$ = 40                               ; size = 1
??$_Copy_backward1@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@1@Z PROC ; std::_Copy_backward1<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >, COMDAT

; 2546 :        {     // copy [_First, _Last) backwards to [..., _Dest), random-access iterators

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 18   sub         esp, 24                        ; 00000018H

; 2547 :        static_cast<void>(_Dest - (_Last - _First));  // checks range

  00006 8d 45 0c   lea         eax, DWORD PTR __First$[ebp]
  00009 50                 push    eax
  0000a 8d 4d 14   lea         ecx, DWORD PTR __Last$[ebp]
  0000d e8 00 00 00 00     call    ??G?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEHABV?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@@Z ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator-
  00012 50                 push    eax
  00013 8d 4d f8   lea         ecx, DWORD PTR $T3[ebp]
  00016 51                 push    ecx
  00017 8d 4d 1c   lea         ecx, DWORD PTR __Dest$[ebp]
  0001a e8 00 00 00 00     call    ??G?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator-

; 2548 :        return (_Rechecked(_Dest,

  0001f 8b 55 20   mov         edx, DWORD PTR __Dest$[ebp+4]
  00022 52                 push    edx
  00023 8b 45 1c   mov         eax, DWORD PTR __Dest$[ebp]
  00026 50                 push    eax
  00027 8d 4d f0   lea         ecx, DWORD PTR $T2[ebp]
  0002a 51                 push    ecx
  0002b e8 00 00 00 00     call    ??$_Unchecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@@Z ; std::_Unchecked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
  00030 83 c4 0c   add         esp, 12                        ; 0000000cH
  00033 8b 50 04   mov         edx, DWORD PTR [eax+4]
  00036 52                 push    edx
  00037 8b 00        mov         eax, DWORD PTR [eax]
  00039 50                 push    eax
  0003a 8b 4d 18   mov         ecx, DWORD PTR __Last$[ebp+4]
  0003d 51                 push    ecx
  0003e 8b 55 14   mov         edx, DWORD PTR __Last$[ebp]
  00041 52                 push    edx
  00042 8b 45 10   mov         eax, DWORD PTR __First$[ebp+4]
  00045 50                 push    eax
  00046 8b 4d 0c   mov         ecx, DWORD PTR __First$[ebp]
  00049 51                 push    ecx
  0004a 8d 55 e8   lea         edx, DWORD PTR $T1[ebp]
  0004d 52                 push    edx
  0004e e8 00 00 00 00     call    ??$_Copy_backward_unchecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00@Z ; std::_Copy_backward_unchecked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
  00053 83 c4 1c   add         esp, 28                        ; 0000001cH
  00056 8b 48 04   mov         ecx, DWORD PTR [eax+4]
  00059 51                 push    ecx
  0005a 8b 10        mov         edx, DWORD PTR [eax]
  0005c 52                 push    edx
  0005d 8d 45 1c   lea         eax, DWORD PTR __Dest$[ebp]
  00060 50                 push    eax
  00061 e8 00 00 00 00     call    ??$_Rechecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YAAAV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@AAV10@V10@@Z ; std::_Rechecked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
  00066 83 c4 0c   add         esp, 12                        ; 0000000cH
  00069 8b 08        mov         ecx, DWORD PTR [eax]
  0006b 8b 50 04   mov         edx, DWORD PTR [eax+4]
  0006e 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]
  00071 89 08        mov         DWORD PTR [eax], ecx
  00073 89 50 04   mov         DWORD PTR [eax+4], edx
  00076 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2549 :              _Copy_backward_unchecked(_First, _Last, _Unchecked(_Dest))));
; 2550 :        }

  00079 8b e5        mov         esp, ebp
  0007b 5d                 pop     ebp
  0007c c3                 ret     0
??$_Copy_backward1@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@1@Z ENDP ; std::_Copy_backward1<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ??$_Iter_cat@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@@Z
_TEXT   SEGMENT
___$ReturnUdt$ = 8                                  ; size = 4
___formal$ = 12                               ; size = 4
??$_Iter_cat@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@@Z PROC ; std::_Iter_cat<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >, COMDAT

; 639  :        {     // return category from iterator argument

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 640  :        return {};

  00003 33 c0        xor         eax, eax
  00005 8b 4d 08   mov         ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00008 88 01        mov         BYTE PTR [ecx], al
  0000a 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]

; 641  :        }

  0000d 5d                 pop     ebp
  0000e c3                 ret     0
??$_Iter_cat@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@@Z ENDP ; std::_Iter_cat<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ?_Deprecate@_Unchecked_iterators@?1???$copy_backward@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@V32@00@Z@SAXU?$integral_constant@_N$00@2@@Z
_TEXT   SEGMENT
___formal$ = 8                                      ; size = 1
?_Deprecate@_Unchecked_iterators@?1???$copy_backward@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@V32@00@Z@SAXU?$integral_constant@_N$00@2@@Z PROC ; `std::copy_backward<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >'::`2'::_Unchecked_iterators::_Deprecate, COMDAT

; 2557 :        _DEPRECATE_UNCHECKED(copy_backward, _Dest);

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 5d                 pop     ebp
  00004 c3                 ret     0
?_Deprecate@_Unchecked_iterators@?1???$copy_backward@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@V32@00@Z@SAXU?$integral_constant@_N$00@2@@Z ENDP ; `std::copy_backward<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >'::`2'::_Unchecked_iterators::_Deprecate
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ??$_Copy_no_deprecate@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00@Z
_TEXT   SEGMENT
$T1 = -20                                         ; size = 8
$T2 = -12                                         ; size = 8
$T3 = -2                                                ; size = 1
$T4 = -1                                                ; size = 1
___$ReturnUdt$ = 8                                  ; size = 4
__First$ = 12                                     ; size = 8
__Last$ = 20                                            ; size = 8
__Dest$ = 28                                            ; size = 8
??$_Copy_no_deprecate@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00@Z PROC ; std::_Copy_no_deprecate<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >, COMDAT

; 2311 :        {     // copy [_First, _Last) to [_Dest, ...), no _SCL_INSECURE_DEPRECATE warnings

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 14   sub         esp, 20                        ; 00000014H

; 2312 :        _DEBUG_RANGE_PTR(_First, _Last, _Dest);
; 2313 :        return (_Copy_no_deprecate1(_Unchecked(_First), _Unchecked(_Last),

  00006 8d 45 1c   lea         eax, DWORD PTR __Dest$[ebp]
  00009 50                 push    eax
  0000a 8d 4d ff   lea         ecx, DWORD PTR $T4[ebp]
  0000d 51                 push    ecx
  0000e e8 00 00 00 00     call    ??$_Iter_cat@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@@Z ; std::_Iter_cat<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
  00013 83 c4 08   add         esp, 8
  00016 8a 10        mov         dl, BYTE PTR [eax]
  00018 0f b6 c2   movzx       eax, dl
  0001b 50                 push    eax
  0001c 8d 4d 0c   lea         ecx, DWORD PTR __First$[ebp]
  0001f 51                 push    ecx
  00020 8d 55 fe   lea         edx, DWORD PTR $T3[ebp]
  00023 52                 push    edx
  00024 e8 00 00 00 00     call    ??$_Iter_cat@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@@Z ; std::_Iter_cat<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
  00029 83 c4 08   add         esp, 8
  0002c 8a 00        mov         al, BYTE PTR [eax]
  0002e 0f b6 c8   movzx       ecx, al
  00031 51                 push    ecx
  00032 8b 55 20   mov         edx, DWORD PTR __Dest$[ebp+4]
  00035 52                 push    edx
  00036 8b 45 1c   mov         eax, DWORD PTR __Dest$[ebp]
  00039 50                 push    eax
  0003a 8b 4d 18   mov         ecx, DWORD PTR __Last$[ebp+4]
  0003d 51                 push    ecx
  0003e 8b 55 14   mov         edx, DWORD PTR __Last$[ebp]
  00041 52                 push    edx
  00042 8d 45 f4   lea         eax, DWORD PTR $T2[ebp]
  00045 50                 push    eax
  00046 e8 00 00 00 00     call    ??$_Unchecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@@Z ; std::_Unchecked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
  0004b 83 c4 0c   add         esp, 12                        ; 0000000cH
  0004e 8b 48 04   mov         ecx, DWORD PTR [eax+4]
  00051 51                 push    ecx
  00052 8b 10        mov         edx, DWORD PTR [eax]
  00054 52                 push    edx
  00055 8b 45 10   mov         eax, DWORD PTR __First$[ebp+4]
  00058 50                 push    eax
  00059 8b 4d 0c   mov         ecx, DWORD PTR __First$[ebp]
  0005c 51                 push    ecx
  0005d 8d 55 ec   lea         edx, DWORD PTR $T1[ebp]
  00060 52                 push    edx
  00061 e8 00 00 00 00     call    ??$_Unchecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@@Z ; std::_Unchecked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
  00066 83 c4 0c   add         esp, 12                        ; 0000000cH
  00069 8b 48 04   mov         ecx, DWORD PTR [eax+4]
  0006c 51                 push    ecx
  0006d 8b 10        mov         edx, DWORD PTR [eax]
  0006f 52                 push    edx
  00070 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]
  00073 50                 push    eax
  00074 e8 00 00 00 00     call    ??$_Copy_no_deprecate1@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@1@Z ; std::_Copy_no_deprecate1<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
  00079 83 c4 24   add         esp, 36                        ; 00000024H
  0007c 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2314 :              _Dest, _Iter_cat(_First), _Iter_cat(_Dest)));
; 2315 :        }

  0007f 8b e5        mov         esp, ebp
  00081 5d                 pop     ebp
  00082 c3                 ret     0
??$_Copy_no_deprecate@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00@Z ENDP ; std::_Copy_no_deprecate<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ??$_Is_checked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@@std@@YA?AU?$integral_constant@_N$00@0@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@@Z
_TEXT   SEGMENT
$T1 = -1                                                ; size = 1
___formal$ = 8                                      ; size = 8
??$_Is_checked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@@std@@YA?AU?$integral_constant@_N$00@0@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@@Z PROC ; std::_Is_checked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >, COMDAT

; 431  :        {     // return type is true_type if iterator is checked

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx

; 432  :        return {};

  00004 33 c0        xor         eax, eax
  00006 88 45 ff   mov         BYTE PTR $T1[ebp], al
  00009 8a 45 ff   mov         al, BYTE PTR $T1[ebp]

; 433  :        }

  0000c 8b e5        mov         esp, ebp
  0000e 5d                 pop     ebp
  0000f c3                 ret     0
??$_Is_checked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@@std@@YA?AU?$integral_constant@_N$00@0@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@@Z ENDP ; std::_Is_checked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ?_Deprecate@_Unchecked_iterators@?1???$copy@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@V32@00@Z@SAXU?$integral_constant@_N$00@2@@Z
_TEXT   SEGMENT
___formal$ = 8                                      ; size = 1
?_Deprecate@_Unchecked_iterators@?1???$copy@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@V32@00@Z@SAXU?$integral_constant@_N$00@2@@Z PROC ; `std::copy<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >'::`2'::_Unchecked_iterators::_Deprecate, COMDAT

; 2322 :        _DEPRECATE_UNCHECKED(copy, _Dest);

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 5d                 pop     ebp
  00004 c3                 ret     0
?_Deprecate@_Unchecked_iterators@?1???$copy@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@V32@00@Z@SAXU?$integral_constant@_N$00@2@@Z ENDP ; `std::copy<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >'::`2'::_Unchecked_iterators::_Deprecate
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ??$_Fill_unchecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@0AB_N@Z
_TEXT   SEGMENT
$T1 = -1                                                ; size = 1
__First$ = 8                                            ; size = 8
__Last$ = 16                                            ; size = 8
__Val$ = 24                                   ; size = 4
??$_Fill_unchecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@0AB_N@Z PROC ; std::_Fill_unchecked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,bool>, COMDAT

; 2768 :        {     // copy _Val through [_First, _Last), choose optimization

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx

; 2769 :        _Fill_unchecked1(_First, _Last, _Val, _Fill_memset_is_safe(_First, _Val));

  00004 8b 45 18   mov         eax, DWORD PTR __Val$[ebp]
  00007 50                 push    eax
  00008 8d 4d 08   lea         ecx, DWORD PTR __First$[ebp]
  0000b 51                 push    ecx
  0000c e8 00 00 00 00     call    ??$_Fill_memset_is_safe@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@_N@std@@YA?AU?$integral_constant@_N$0A@@0@ABV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@AB_N@Z ; std::_Fill_memset_is_safe<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,bool>
  00011 83 c4 08   add         esp, 8
  00014 88 45 ff   mov         BYTE PTR $T1[ebp], al
  00017 0f b6 55 ff        movzx         edx, BYTE PTR $T1[ebp]
  0001b 52                 push    edx
  0001c 8b 45 18   mov         eax, DWORD PTR __Val$[ebp]
  0001f 50                 push    eax
  00020 8b 4d 14   mov         ecx, DWORD PTR __Last$[ebp+4]
  00023 51                 push    ecx
  00024 8b 55 10   mov         edx, DWORD PTR __Last$[ebp]
  00027 52                 push    edx
  00028 8b 45 0c   mov         eax, DWORD PTR __First$[ebp+4]
  0002b 50                 push    eax
  0002c 8b 4d 08   mov         ecx, DWORD PTR __First$[ebp]
  0002f 51                 push    ecx
  00030 e8 00 00 00 00     call    ??$_Fill_unchecked1@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@0AB_NU?$integral_constant@_N$0A@@0@@Z ; std::_Fill_unchecked1<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,bool>
  00035 83 c4 18   add         esp, 24                        ; 00000018H

; 2770 :        }

  00038 8b e5        mov         esp, ebp
  0003a 5d                 pop     ebp
  0003b c3                 ret     0
??$_Fill_unchecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@0AB_N@Z ENDP ; std::_Fill_unchecked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,bool>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ??$_Unchecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@@Z
_TEXT   SEGMENT
___$ReturnUdt$ = 8                                  ; size = 4
__Src$ = 12                                   ; size = 8
??$_Unchecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@@Z PROC ; std::_Unchecked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >, COMDAT

; 438  :        {     // construct unchecked from checked, generic

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 439  :        return (_Src);

  00003 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006 8b 4d 0c   mov         ecx, DWORD PTR __Src$[ebp]
  00009 89 08        mov         DWORD PTR [eax], ecx
  0000b 8b 55 10   mov         edx, DWORD PTR __Src$[ebp+4]
  0000e 89 50 04   mov         DWORD PTR [eax+4], edx
  00011 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]

; 440  :        }

  00014 5d                 pop     ebp
  00015 c3                 ret     0
??$_Unchecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@@Z ENDP ; std::_Unchecked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ??$equal@PBDPBDU?$_Cmp_icase@V?$_Regex_traits@D@std@@@std@@@std@@YA_NPBD000U?$_Cmp_icase@V?$_Regex_traits@D@std@@@0@@Z
_TEXT   SEGMENT
$T1 = -2                                                ; size = 1
$T2 = -1                                                ; size = 1
__First1$ = 8                                     ; size = 4
__Last1$ = 12                                     ; size = 4
__First2$ = 16                                      ; size = 4
__Last2$ = 20                                     ; size = 4
__Pred$ = 24                                            ; size = 4
??$equal@PBDPBDU?$_Cmp_icase@V?$_Regex_traits@D@std@@@std@@@std@@YA_NPBD000U?$_Cmp_icase@V?$_Regex_traits@D@std@@@0@@Z PROC ; std::equal<char const *,char const *,std::_Cmp_icase<std::_Regex_traits<char> > >, COMDAT

; 2992 :        {     // compare [_First1, _Last1) to [_First2, _Last2) using _Pred

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx

; 2993 :        _DEBUG_RANGE(_First1, _Last1);
; 2994 :        _DEBUG_RANGE(_First2, _Last2);
; 2995 :        return (_Equal(_Unchecked(_First1), _Unchecked(_Last1),

  00004 8d 45 10   lea         eax, DWORD PTR __First2$[ebp]
  00007 50                 push    eax
  00008 8d 4d ff   lea         ecx, DWORD PTR $T2[ebp]
  0000b 51                 push    ecx
  0000c e8 00 00 00 00     call    ??$_Iter_cat@PBD@std@@YA?AUrandom_access_iterator_tag@0@ABQBD@Z ; std::_Iter_cat<char const *>
  00011 83 c4 08   add         esp, 8
  00014 8a 10        mov         dl, BYTE PTR [eax]
  00016 0f b6 c2   movzx       eax, dl
  00019 50                 push    eax
  0001a 8d 4d 08   lea         ecx, DWORD PTR __First1$[ebp]
  0001d 51                 push    ecx
  0001e 8d 55 fe   lea         edx, DWORD PTR $T1[ebp]
  00021 52                 push    edx
  00022 e8 00 00 00 00     call    ??$_Iter_cat@PBD@std@@YA?AUrandom_access_iterator_tag@0@ABQBD@Z ; std::_Iter_cat<char const *>
  00027 83 c4 08   add         esp, 8
  0002a 8a 00        mov         al, BYTE PTR [eax]
  0002c 0f b6 c8   movzx       ecx, al
  0002f 51                 push    ecx
  00030 8b 55 18   mov         edx, DWORD PTR __Pred$[ebp]
  00033 52                 push    edx
  00034 8b 45 14   mov         eax, DWORD PTR __Last2$[ebp]
  00037 50                 push    eax
  00038 e8 00 00 00 00     call    ??$_Unchecked@PBD@std@@YAPBDPBD@Z ; std::_Unchecked<char const *>
  0003d 83 c4 04   add         esp, 4
  00040 50                 push    eax
  00041 8b 4d 10   mov         ecx, DWORD PTR __First2$[ebp]
  00044 51                 push    ecx
  00045 e8 00 00 00 00     call    ??$_Unchecked@PBD@std@@YAPBDPBD@Z ; std::_Unchecked<char const *>
  0004a 83 c4 04   add         esp, 4
  0004d 50                 push    eax
  0004e 8b 55 0c   mov         edx, DWORD PTR __Last1$[ebp]
  00051 52                 push    edx
  00052 e8 00 00 00 00     call    ??$_Unchecked@PBD@std@@YAPBDPBD@Z ; std::_Unchecked<char const *>
  00057 83 c4 04   add         esp, 4
  0005a 50                 push    eax
  0005b 8b 45 08   mov         eax, DWORD PTR __First1$[ebp]
  0005e 50                 push    eax
  0005f e8 00 00 00 00     call    ??$_Unchecked@PBD@std@@YAPBDPBD@Z ; std::_Unchecked<char const *>
  00064 83 c4 04   add         esp, 4
  00067 50                 push    eax
  00068 e8 00 00 00 00     call    ??$_Equal@PBDPBDU?$_Cmp_icase@V?$_Regex_traits@D@std@@@std@@@std@@YA_NPBD000U?$_Cmp_icase@V?$_Regex_traits@D@std@@@0@Urandom_access_iterator_tag@0@2@Z ; std::_Equal<char const *,char const *,std::_Cmp_icase<std::_Regex_traits<char> > >
  0006d 83 c4 1c   add         esp, 28                        ; 0000001cH

; 2996 :              _Unchecked(_First2), _Unchecked(_Last2), _Pred,
; 2997 :                  _Iter_cat(_First1), _Iter_cat(_First2)));
; 2998 :        }

  00070 8b e5        mov         esp, ebp
  00072 5d                 pop     ebp
  00073 c3                 ret     0
??$equal@PBDPBDU?$_Cmp_icase@V?$_Regex_traits@D@std@@@std@@@std@@YA_NPBD000U?$_Cmp_icase@V?$_Regex_traits@D@std@@@0@@Z ENDP ; std::equal<char const *,char const *,std::_Cmp_icase<std::_Regex_traits<char> > >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ??R?$_Cmp_icase@V?$_Regex_traits@D@std@@@std@@QAE_NDD@Z
_TEXT   SEGMENT
tv75 = -8                                         ; size = 4
_this$ = -4                                   ; size = 4
__E1$ = 8                                         ; size = 1
__E2$ = 12                                          ; size = 1
??R?$_Cmp_icase@V?$_Regex_traits@D@std@@@std@@QAE_NDD@Z PROC ; std::_Cmp_icase<std::_Regex_traits<char> >::operator(), COMDAT
; _this$ = ecx

; 211  :              {   // return true if equal

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 56                 push    esi
  00007 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 212  :              return (_Traits.translate_nocase(_E1)

  0000a 0f b6 45 08        movzx         eax, BYTE PTR __E1$[ebp]
  0000e 50                 push    eax
  0000f 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00012 8b 09        mov         ecx, DWORD PTR [ecx]
  00014 e8 00 00 00 00     call    ?translate_nocase@?$_Regex_traits@D@std@@QBEDD@Z ; std::_Regex_traits<char>::translate_nocase
  00019 0f be f0   movsx       esi, al
  0001c 0f b6 55 0c        movzx         edx, BYTE PTR __E2$[ebp]
  00020 52                 push    edx
  00021 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00024 8b 08        mov         ecx, DWORD PTR [eax]
  00026 e8 00 00 00 00     call    ?translate_nocase@?$_Regex_traits@D@std@@QBEDD@Z ; std::_Regex_traits<char>::translate_nocase
  0002b 0f be c8   movsx       ecx, al
  0002e 3b f1        cmp         esi, ecx
  00030 75 09        jne         SHORT $LN3@operator
  00032 c7 45 f8 01 00
        00 00          mov         DWORD PTR tv75[ebp], 1
  00039 eb 07        jmp         SHORT $LN4@operator
$LN3@operator:
  0003b c7 45 f8 00 00
        00 00          mov         DWORD PTR tv75[ebp], 0
$LN4@operator:
  00042 8a 45 f8   mov         al, BYTE PTR tv75[ebp]

; 213  :                  == _Traits.translate_nocase(_E2));
; 214  :              }

  00045 5e                 pop     esi
  00046 8b e5        mov         esp, ebp
  00048 5d                 pop     ebp
  00049 c2 08 00   ret         8
??R?$_Cmp_icase@V?$_Regex_traits@D@std@@@std@@QAE_NDD@Z ENDP ; std::_Cmp_icase<std::_Regex_traits<char> >::operator()
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ??0?$_Cmp_icase@V?$_Regex_traits@D@std@@@std@@QAE@ABV?$_Regex_traits@D@1@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Tr$ = 8                                         ; size = 4
??0?$_Cmp_icase@V?$_Regex_traits@D@std@@@std@@QAE@ABV?$_Regex_traits@D@1@@Z PROC ; std::_Cmp_icase<std::_Regex_traits<char> >::_Cmp_icase<std::_Regex_traits<char> >, COMDAT
; _this$ = ecx

; 207  :              {   // construct

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 206  :              : _Traits(_Tr)

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a 8b 4d 08   mov         ecx, DWORD PTR __Tr$[ebp]
  0000d 89 08        mov         DWORD PTR [eax], ecx

; 208  :              }

  0000f 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00012 8b e5        mov         esp, ebp
  00014 5d                 pop     ebp
  00015 c2 04 00   ret         4
??0?$_Cmp_icase@V?$_Regex_traits@D@std@@@std@@QAE@ABV?$_Regex_traits@D@1@@Z ENDP ; std::_Cmp_icase<std::_Regex_traits<char> >::_Cmp_icase<std::_Regex_traits<char> >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ??$_Mark@E@_Bitmap@std@@QAEXE@Z
_TEXT   SEGMENT
_this$ = -8                                   ; size = 4
__Wide$ = -4                                            ; size = 4
__Ch$ = 8                                         ; size = 1
??$_Mark@E@_Bitmap@std@@QAEXE@Z PROC                    ; std::_Bitmap::_Mark<unsigned char>, COMDAT
; _this$ = ecx

; 1698 :              {   // mark character _Ch

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d f8   mov         DWORD PTR _this$[ebp], ecx

; 1699 :              static_assert(is_unsigned<_Elem>::value, "_Elem must be unsigned");
; 1700 :              unsigned int _Wide = _Ch;

  00009 0f b6 45 08        movzx         eax, BYTE PTR __Ch$[ebp]
  0000d 89 45 fc   mov         DWORD PTR __Wide$[ebp], eax

; 1701 :              _Chrs[_Wide >> _Bmp_shift] |= (1 << (_Wide & _Bmp_mask));

  00010 8b 55 fc   mov         edx, DWORD PTR __Wide$[ebp]
  00013 c1 ea 03   shr         edx, 3
  00016 8b 4d fc   mov         ecx, DWORD PTR __Wide$[ebp]
  00019 83 e1 07   and         ecx, 7
  0001c b8 01 00 00 00     mov     eax, 1
  00021 d3 e0        shl         eax, cl
  00023 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00026 0f b6 14 11        movzx         edx, BYTE PTR [ecx+edx]
  0002a 0b d0        or  edx, eax
  0002c 8b 45 fc   mov         eax, DWORD PTR __Wide$[ebp]
  0002f c1 e8 03   shr         eax, 3
  00032 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00035 88 14 01   mov         BYTE PTR [ecx+eax], dl

; 1702 :              }

  00038 8b e5        mov         esp, ebp
  0003a 5d                 pop     ebp
  0003b c2 04 00   ret         4
??$_Mark@E@_Bitmap@std@@QAEXE@Z ENDP                    ; std::_Bitmap::_Mark<unsigned char>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ??$_Mark@I@_Bitmap@std@@QAEXI@Z
_TEXT   SEGMENT
_this$ = -8                                   ; size = 4
__Wide$ = -4                                            ; size = 4
__Ch$ = 8                                         ; size = 4
??$_Mark@I@_Bitmap@std@@QAEXI@Z PROC                    ; std::_Bitmap::_Mark<unsigned int>, COMDAT
; _this$ = ecx

; 1698 :              {   // mark character _Ch

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d f8   mov         DWORD PTR _this$[ebp], ecx

; 1699 :              static_assert(is_unsigned<_Elem>::value, "_Elem must be unsigned");
; 1700 :              unsigned int _Wide = _Ch;

  00009 8b 45 08   mov         eax, DWORD PTR __Ch$[ebp]
  0000c 89 45 fc   mov         DWORD PTR __Wide$[ebp], eax

; 1701 :              _Chrs[_Wide >> _Bmp_shift] |= (1 << (_Wide & _Bmp_mask));

  0000f 8b 55 fc   mov         edx, DWORD PTR __Wide$[ebp]
  00012 c1 ea 03   shr         edx, 3
  00015 8b 4d fc   mov         ecx, DWORD PTR __Wide$[ebp]
  00018 83 e1 07   and         ecx, 7
  0001b b8 01 00 00 00     mov     eax, 1
  00020 d3 e0        shl         eax, cl
  00022 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00025 0f b6 14 11        movzx         edx, BYTE PTR [ecx+edx]
  00029 0b d0        or  edx, eax
  0002b 8b 45 fc   mov         eax, DWORD PTR __Wide$[ebp]
  0002e c1 e8 03   shr         eax, 3
  00031 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00034 88 14 01   mov         BYTE PTR [ecx+eax], dl

; 1702 :              }

  00037 8b e5        mov         esp, ebp
  00039 5d                 pop     ebp
  0003a c2 04 00   ret         4
??$_Mark@I@_Bitmap@std@@QAEXI@Z ENDP                    ; std::_Bitmap::_Mark<unsigned int>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??$_Umove@PAI@?$vector@IV?$allocator@_N@std@@@std@@IAEPAIPAI00@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__First$ = 8                                            ; size = 4
__Last$ = 12                                            ; size = 4
__Ptr$ = 16                                   ; size = 4
??$_Umove@PAI@?$vector@IV?$allocator@_N@std@@@std@@IAEPAIPAI00@Z PROC ; std::vector<unsigned int,std::allocator<bool> >::_Umove<unsigned int *>, COMDAT
; _this$ = ecx

; 1681 :              {   // move initializing [_First, _Last), using allocator

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1682 :              return (_Uninitialized_move(_First, _Last,

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Getal
  0000f 50                 push    eax
  00010 8b 45 10   mov         eax, DWORD PTR __Ptr$[ebp]
  00013 50                 push    eax
  00014 8b 4d 0c   mov         ecx, DWORD PTR __Last$[ebp]
  00017 51                 push    ecx
  00018 8b 55 08   mov         edx, DWORD PTR __First$[ebp]
  0001b 52                 push    edx
  0001c e8 00 00 00 00     call    ??$_Uninitialized_move@PAIPAIU?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAPAIPAI00AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z ; std::_Uninitialized_move<unsigned int *,unsigned int *,std::_Wrap_alloc<std::allocator<unsigned int> > >
  00021 83 c4 10   add         esp, 16                        ; 00000010H

; 1683 :                  _Ptr, this->_Getal()));
; 1684 :              }

  00024 8b e5        mov         esp, ebp
  00026 5d                 pop     ebp
  00027 c2 0c 00   ret         12           ; 0000000cH
??$_Umove@PAI@?$vector@IV?$allocator@_N@std@@@std@@IAEPAIPAI00@Z ENDP ; std::vector<unsigned int,std::allocator<bool> >::_Umove<unsigned int *>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ??$copy_backward@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00@Z
_TEXT   SEGMENT
$T1 = -20                                         ; size = 8
$T2 = -12                                         ; size = 8
$T3 = -3                                                ; size = 1
$T4 = -2                                                ; size = 1
$T5 = -1                                                ; size = 1
___$ReturnUdt$ = 8                                  ; size = 4
__First$ = 12                                     ; size = 8
__Last$ = 20                                            ; size = 8
__Dest$ = 28                                            ; size = 8
??$copy_backward@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00@Z PROC ; std::copy_backward<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >, COMDAT

; 2556 :        {     // copy [_First, _Last) backwards to [..., _Dest)

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 14   sub         esp, 20                        ; 00000014H

; 2557 :        _DEPRECATE_UNCHECKED(copy_backward, _Dest);

  00006 8b 45 20   mov         eax, DWORD PTR __Dest$[ebp+4]
  00009 50                 push    eax
  0000a 8b 4d 1c   mov         ecx, DWORD PTR __Dest$[ebp]
  0000d 51                 push    ecx
  0000e e8 00 00 00 00     call    ??$_Is_checked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@@std@@YA?AU?$integral_constant@_N$00@0@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@@Z ; std::_Is_checked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
  00013 83 c4 08   add         esp, 8
  00016 88 45 ff   mov         BYTE PTR $T5[ebp], al
  00019 0f b6 55 ff        movzx         edx, BYTE PTR $T5[ebp]
  0001d 52                 push    edx
  0001e e8 00 00 00 00     call    ?_Deprecate@_Unchecked_iterators@?1???$copy_backward@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@V32@00@Z@SAXU?$integral_constant@_N$00@2@@Z ; `std::copy_backward<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >'::`2'::_Unchecked_iterators::_Deprecate
  00023 83 c4 04   add         esp, 4

; 2558 :        _DEBUG_RANGE_PTR(_First, _Last, _Dest);
; 2559 :        return (_Copy_backward1(_Unchecked(_First), _Unchecked(_Last),

  00026 8d 45 1c   lea         eax, DWORD PTR __Dest$[ebp]
  00029 50                 push    eax
  0002a 8d 4d fe   lea         ecx, DWORD PTR $T4[ebp]
  0002d 51                 push    ecx
  0002e e8 00 00 00 00     call    ??$_Iter_cat@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@@Z ; std::_Iter_cat<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
  00033 83 c4 08   add         esp, 8
  00036 8a 10        mov         dl, BYTE PTR [eax]
  00038 0f b6 c2   movzx       eax, dl
  0003b 50                 push    eax
  0003c 8d 4d 0c   lea         ecx, DWORD PTR __First$[ebp]
  0003f 51                 push    ecx
  00040 8d 55 fd   lea         edx, DWORD PTR $T3[ebp]
  00043 52                 push    edx
  00044 e8 00 00 00 00     call    ??$_Iter_cat@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@@Z ; std::_Iter_cat<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
  00049 83 c4 08   add         esp, 8
  0004c 8a 00        mov         al, BYTE PTR [eax]
  0004e 0f b6 c8   movzx       ecx, al
  00051 51                 push    ecx
  00052 8b 55 20   mov         edx, DWORD PTR __Dest$[ebp+4]
  00055 52                 push    edx
  00056 8b 45 1c   mov         eax, DWORD PTR __Dest$[ebp]
  00059 50                 push    eax
  0005a 8b 4d 18   mov         ecx, DWORD PTR __Last$[ebp+4]
  0005d 51                 push    ecx
  0005e 8b 55 14   mov         edx, DWORD PTR __Last$[ebp]
  00061 52                 push    edx
  00062 8d 45 f4   lea         eax, DWORD PTR $T2[ebp]
  00065 50                 push    eax
  00066 e8 00 00 00 00     call    ??$_Unchecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@@Z ; std::_Unchecked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
  0006b 83 c4 0c   add         esp, 12                        ; 0000000cH
  0006e 8b 48 04   mov         ecx, DWORD PTR [eax+4]
  00071 51                 push    ecx
  00072 8b 10        mov         edx, DWORD PTR [eax]
  00074 52                 push    edx
  00075 8b 45 10   mov         eax, DWORD PTR __First$[ebp+4]
  00078 50                 push    eax
  00079 8b 4d 0c   mov         ecx, DWORD PTR __First$[ebp]
  0007c 51                 push    ecx
  0007d 8d 55 ec   lea         edx, DWORD PTR $T1[ebp]
  00080 52                 push    edx
  00081 e8 00 00 00 00     call    ??$_Unchecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@@Z ; std::_Unchecked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
  00086 83 c4 0c   add         esp, 12                        ; 0000000cH
  00089 8b 48 04   mov         ecx, DWORD PTR [eax+4]
  0008c 51                 push    ecx
  0008d 8b 10        mov         edx, DWORD PTR [eax]
  0008f 52                 push    edx
  00090 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]
  00093 50                 push    eax
  00094 e8 00 00 00 00     call    ??$_Copy_backward1@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@1@Z ; std::_Copy_backward1<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
  00099 83 c4 24   add         esp, 36                        ; 00000024H
  0009c 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2560 :              _Dest, _Iter_cat(_First), _Iter_cat(_Dest)));
; 2561 :        }

  0009f 8b e5        mov         esp, ebp
  000a1 5d                 pop     ebp
  000a2 c3                 ret     0
??$copy_backward@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00@Z ENDP ; std::copy_backward<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ??$copy@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00@Z
_TEXT   SEGMENT
$T1 = -1                                                ; size = 1
___$ReturnUdt$ = 8                                  ; size = 4
__First$ = 12                                     ; size = 8
__Last$ = 20                                            ; size = 8
__Dest$ = 28                                            ; size = 8
??$copy@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00@Z PROC ; std::copy<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >, COMDAT

; 2321 :        {     // copy [_First, _Last) to [_Dest, ...)

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx

; 2322 :        _DEPRECATE_UNCHECKED(copy, _Dest);

  00004 8b 45 20   mov         eax, DWORD PTR __Dest$[ebp+4]
  00007 50                 push    eax
  00008 8b 4d 1c   mov         ecx, DWORD PTR __Dest$[ebp]
  0000b 51                 push    ecx
  0000c e8 00 00 00 00     call    ??$_Is_checked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@@std@@YA?AU?$integral_constant@_N$00@0@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@@Z ; std::_Is_checked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
  00011 83 c4 08   add         esp, 8
  00014 88 45 ff   mov         BYTE PTR $T1[ebp], al
  00017 0f b6 55 ff        movzx         edx, BYTE PTR $T1[ebp]
  0001b 52                 push    edx
  0001c e8 00 00 00 00     call    ?_Deprecate@_Unchecked_iterators@?1???$copy@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@V32@00@Z@SAXU?$integral_constant@_N$00@2@@Z ; `std::copy<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >'::`2'::_Unchecked_iterators::_Deprecate
  00021 83 c4 04   add         esp, 4

; 2323 :        return (_Copy_no_deprecate(_First, _Last, _Dest));

  00024 8b 45 20   mov         eax, DWORD PTR __Dest$[ebp+4]
  00027 50                 push    eax
  00028 8b 4d 1c   mov         ecx, DWORD PTR __Dest$[ebp]
  0002b 51                 push    ecx
  0002c 8b 55 18   mov         edx, DWORD PTR __Last$[ebp+4]
  0002f 52                 push    edx
  00030 8b 45 14   mov         eax, DWORD PTR __Last$[ebp]
  00033 50                 push    eax
  00034 8b 4d 10   mov         ecx, DWORD PTR __First$[ebp+4]
  00037 51                 push    ecx
  00038 8b 55 0c   mov         edx, DWORD PTR __First$[ebp]
  0003b 52                 push    edx
  0003c 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]
  0003f 50                 push    eax
  00040 e8 00 00 00 00     call    ??$_Copy_no_deprecate@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00@Z ; std::_Copy_no_deprecate<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
  00045 83 c4 1c   add         esp, 28                        ; 0000001cH
  00048 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2324 :        }

  0004b 8b e5        mov         esp, ebp
  0004d 5d                 pop     ebp
  0004e c3                 ret     0
??$copy@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00@Z ENDP ; std::copy<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ??$fill@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@0AB_N@Z
_TEXT   SEGMENT
$T1 = -16                                         ; size = 8
$T2 = -8                                                ; size = 8
__First$ = 8                                            ; size = 8
__Last$ = 16                                            ; size = 8
__Val$ = 24                                   ; size = 4
??$fill@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@0AB_N@Z PROC ; std::fill<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,bool>, COMDAT

; 2775 :        {     // copy _Val through [_First, _Last)

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 10   sub         esp, 16                        ; 00000010H

; 2776 :        _DEBUG_RANGE(_First, _Last);
; 2777 :        _Fill_unchecked(_Unchecked(_First), _Unchecked(_Last), _Val);

  00006 8b 45 18   mov         eax, DWORD PTR __Val$[ebp]
  00009 50                 push    eax
  0000a 8b 4d 14   mov         ecx, DWORD PTR __Last$[ebp+4]
  0000d 51                 push    ecx
  0000e 8b 55 10   mov         edx, DWORD PTR __Last$[ebp]
  00011 52                 push    edx
  00012 8d 45 f8   lea         eax, DWORD PTR $T2[ebp]
  00015 50                 push    eax
  00016 e8 00 00 00 00     call    ??$_Unchecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@@Z ; std::_Unchecked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
  0001b 83 c4 0c   add         esp, 12                        ; 0000000cH
  0001e 8b 48 04   mov         ecx, DWORD PTR [eax+4]
  00021 51                 push    ecx
  00022 8b 10        mov         edx, DWORD PTR [eax]
  00024 52                 push    edx
  00025 8b 45 0c   mov         eax, DWORD PTR __First$[ebp+4]
  00028 50                 push    eax
  00029 8b 4d 08   mov         ecx, DWORD PTR __First$[ebp]
  0002c 51                 push    ecx
  0002d 8d 55 f0   lea         edx, DWORD PTR $T1[ebp]
  00030 52                 push    edx
  00031 e8 00 00 00 00     call    ??$_Unchecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@@Z ; std::_Unchecked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
  00036 83 c4 0c   add         esp, 12                        ; 0000000cH
  00039 8b 48 04   mov         ecx, DWORD PTR [eax+4]
  0003c 51                 push    ecx
  0003d 8b 10        mov         edx, DWORD PTR [eax]
  0003f 52                 push    edx
  00040 e8 00 00 00 00     call    ??$_Fill_unchecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@0AB_N@Z ; std::_Fill_unchecked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,bool>
  00045 83 c4 14   add         esp, 20                        ; 00000014H

; 2778 :        }

  00048 8b e5        mov         esp, ebp
  0004a 5d                 pop     ebp
  0004b c3                 ret     0
??$fill@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@0AB_N@Z ENDP ; std::fill<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,bool>
_TEXT   ENDS
; Function compile flags: /Odtp
;       COMDAT ??_G?$_Sequence@D@std@@QAEPAXI@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
___flags$ = 8                                     ; size = 4
??_G?$_Sequence@D@std@@QAEPAXI@Z PROC             ; std::_Sequence<char>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ??1?$_Sequence@D@std@@QAE@XZ
  0000f 8b 45 08   mov         eax, DWORD PTR ___flags$[ebp]
  00012 83 e0 01   and         eax, 1
  00015 74 0e        je  SHORT $LN2@scalar
  00017 6a 14        push        20             ; 00000014H
  00019 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001c 51                 push    ecx
  0001d e8 00 00 00 00     call    ??3@YAXPAXI@Z                ; operator delete
  00022 83 c4 08   add         esp, 8
$LN2@scalar:
  00025 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00028 8b e5        mov         esp, ebp
  0002a 5d                 pop     ebp
  0002b c2 04 00   ret         4
??_G?$_Sequence@D@std@@QAEPAXI@Z ENDP             ; std::_Sequence<char>::`scalar deleting destructor'
_TEXT   ENDS
; Function compile flags: /Odtp
;       COMDAT ??1?$_Sequence@D@std@@QAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??1?$_Sequence@D@std@@QAE@XZ PROC                 ; std::_Sequence<char>::~_Sequence<char>, COMDAT
; _this$ = ecx
  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a 83 c1 04   add         ecx, 4
  0000d e8 00 00 00 00     call    ??1?$_Buf@D@std@@QAE@XZ      ; std::_Buf<char>::~_Buf<char>
  00012 8b e5        mov         esp, ebp
  00014 5d                 pop     ebp
  00015 c3                 ret     0
??1?$_Sequence@D@std@@QAE@XZ ENDP                 ; std::_Sequence<char>::~_Sequence<char>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ??0?$_Sequence@D@std@@QAE@I@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Len$ = 8                                          ; size = 4
??0?$_Sequence@D@std@@QAE@I@Z PROC                  ; std::_Sequence<char>::_Sequence<char>, COMDAT
; _this$ = ecx

; 1722 :              {   // construct

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1721 :              : _Sz(_Len)

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a 8b 4d 08   mov         ecx, DWORD PTR __Len$[ebp]
  0000d 89 08        mov         DWORD PTR [eax], ecx

; 1722 :              {   // construct

  0000f 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00012 83 c1 04   add         ecx, 4
  00015 e8 00 00 00 00     call    ??0?$_Buf@D@std@@QAE@XZ      ; std::_Buf<char>::_Buf<char>

; 1723 :              }

  0001a 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0001d 8b e5        mov         esp, ebp
  0001f 5d                 pop     ebp
  00020 c2 04 00   ret         4
??0?$_Sequence@D@std@@QAE@I@Z ENDP                  ; std::_Sequence<char>::_Sequence<char>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;       COMDAT ??$construct@IABI@?$allocator@I@std@@QAEXPAIABI@Z
_TEXT   SEGMENT
_this$ = -12                                            ; size = 4
tv73 = -8                                         ; size = 4
$T1 = -4                                                ; size = 4
__Ptr$ = 8                                          ; size = 4
_<_Args_0>$ = 12                                        ; size = 4
??$construct@IABI@?$allocator@I@std@@QAEXPAIABI@Z PROC  ; std::allocator<unsigned int>::construct<unsigned int,unsigned int const &>, COMDAT
; _this$ = ecx

; 636  :              {   // construct _Objty(_Types...) at _Ptr

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 0c   sub         esp, 12                        ; 0000000cH
  00006 89 4d f4   mov         DWORD PTR _this$[ebp], ecx

; 637  :              ::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00009 8b 45 08   mov         eax, DWORD PTR __Ptr$[ebp]
  0000c 50                 push    eax
  0000d 6a 04        push        4
  0000f e8 00 00 00 00     call    ??2@YAPAXIPAX@Z          ; operator new
  00014 83 c4 08   add         esp, 8
  00017 89 45 fc   mov         DWORD PTR $T1[ebp], eax
  0001a 83 7d fc 00        cmp   DWORD PTR $T1[ebp], 0
  0001e 74 1b        je  SHORT $LN3@construct
  00020 8b 4d 0c   mov         ecx, DWORD PTR _<_Args_0>$[ebp]
  00023 51                 push    ecx
  00024 e8 00 00 00 00     call    ??$forward@ABI@std@@YAABIABI@Z ; std::forward<unsigned int const &>
  00029 83 c4 04   add         esp, 4
  0002c 8b 55 fc   mov         edx, DWORD PTR $T1[ebp]
  0002f 8b 00        mov         eax, DWORD PTR [eax]
  00031 89 02        mov         DWORD PTR [edx], eax
  00033 8b 4d fc   mov         ecx, DWORD PTR $T1[ebp]
  00036 89 4d f8   mov         DWORD PTR tv73[ebp], ecx
  00039 eb 07        jmp         SHORT $LN1@construct
$LN3@construct:
  0003b c7 45 f8 00 00
        00 00          mov         DWORD PTR tv73[ebp], 0
$LN1@construct:

; 638  :              }

  00042 8b e5        mov         esp, ebp
  00044 5d                 pop     ebp
  00045 c2 08 00   ret         8
??$construct@IABI@?$allocator@I@std@@QAEXPAIABI@Z ENDP  ; std::allocator<unsigned int>::construct<unsigned int,unsigned int const &>
_TEXT   ENDS
; Function compile flags: /Odtp
;       COMDAT ??_G?$_Node_class@DV?$regex_traits@D@std@@@std@@UAEPAXI@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
___flags$ = 8                                     ; size = 4
??_G?$_Node_class@DV?$regex_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::_Node_class<char,std::regex_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ??1?$_Node_class@DV?$regex_traits@D@std@@@std@@UAE@XZ ; std::_Node_class<char,std::regex_traits<char> >::~_Node_class<char,std::regex_traits<char> >
  0000f 8b 45 08   mov         eax, DWORD PTR ___flags$[ebp]
  00012 83 e0 01   and         eax, 1
  00015 74 0e        je  SHORT $LN2@scalar
  00017 6a 2c        push        44             ; 0000002cH
  00019 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001c 51                 push    ecx
  0001d e8 00 00 00 00     call    ??3@YAXPAXI@Z                ; operator delete
  00022 83 c4 08   add         esp, 8
$LN2@scalar:
  00025 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00028 8b e5        mov         esp, ebp
  0002a 5d                 pop     ebp
  0002b c2 04 00   ret         4
??_G?$_Node_class@DV?$regex_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::_Node_class<char,std::regex_traits<char> >::`scalar deleting destructor'
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Tidy@?$_Node_class@DV?$regex_traits@D@std@@@std@@QAEXPAU?$_Sequence@D@2@@Z
_TEXT   SEGMENT
_this$ = -20                                            ; size = 4
tv70 = -16                                          ; size = 4
$T1 = -12                                         ; size = 4
__Temp$2 = -8                                     ; size = 4
$T3 = -4                                                ; size = 4
__Head$ = 8                                   ; size = 4
?_Tidy@?$_Node_class@DV?$regex_traits@D@std@@@std@@QAEXPAU?$_Sequence@D@2@@Z PROC ; std::_Node_class<char,std::regex_traits<char> >::_Tidy, COMDAT
; _this$ = ecx

; 1874 :              {   // clean up a list of sequences

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 14   sub         esp, 20                        ; 00000014H
  00006 89 4d ec   mov         DWORD PTR _this$[ebp], ecx
$LN2@Tidy:

; 1875 :              while (_Head)

  00009 83 7d 08 00        cmp   DWORD PTR __Head$[ebp], 0
  0000d 74 39        je  SHORT $LN1@Tidy

; 1876 :                  {       // delete the head of the list
; 1877 :                  _Sequence<_Elem> *_Temp = _Head;

  0000f 8b 45 08   mov         eax, DWORD PTR __Head$[ebp]
  00012 89 45 f8   mov         DWORD PTR __Temp$2[ebp], eax

; 1878 :                  _Head = _Head->_Next;

  00015 8b 4d 08   mov         ecx, DWORD PTR __Head$[ebp]
  00018 8b 51 10   mov         edx, DWORD PTR [ecx+16]
  0001b 89 55 08   mov         DWORD PTR __Head$[ebp], edx

; 1879 :                  delete _Temp;

  0001e 8b 45 f8   mov         eax, DWORD PTR __Temp$2[ebp]
  00021 89 45 f4   mov         DWORD PTR $T1[ebp], eax
  00024 8b 4d f4   mov         ecx, DWORD PTR $T1[ebp]
  00027 89 4d fc   mov         DWORD PTR $T3[ebp], ecx
  0002a 83 7d fc 00        cmp   DWORD PTR $T3[ebp], 0
  0002e 74 0f        je  SHORT $LN5@Tidy
  00030 6a 01        push        1
  00032 8b 4d fc   mov         ecx, DWORD PTR $T3[ebp]
  00035 e8 00 00 00 00     call    ??_G?$_Sequence@D@std@@QAEPAXI@Z
  0003a 89 45 f0   mov         DWORD PTR tv70[ebp], eax
  0003d eb 07        jmp         SHORT $LN6@Tidy
$LN5@Tidy:
  0003f c7 45 f0 00 00
        00 00          mov         DWORD PTR tv70[ebp], 0
$LN6@Tidy:

; 1880 :                  }

  00046 eb c1        jmp         SHORT $LN2@Tidy
$LN1@Tidy:

; 1881 :              }

  00048 8b e5        mov         esp, ebp
  0004a 5d                 pop     ebp
  0004b c2 04 00   ret         4
?_Tidy@?$_Node_class@DV?$regex_traits@D@std@@@std@@QAEXPAU?$_Sequence@D@2@@Z ENDP ; std::_Node_class<char,std::regex_traits<char> >::_Tidy
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ??1?$_Node_class@DV?$regex_traits@D@std@@@std@@UAE@XZ
_TEXT   SEGMENT
tv91 = -32                                          ; size = 4
$T1 = -28                                         ; size = 4
tv85 = -24                                          ; size = 4
$T2 = -20                                         ; size = 4
$T3 = -16                                         ; size = 4
$T4 = -12                                         ; size = 4
$T5 = -8                                                ; size = 4
_this$ = -4                                   ; size = 4
??1?$_Node_class@DV?$regex_traits@D@std@@@std@@UAE@XZ PROC ; std::_Node_class<char,std::regex_traits<char> >::~_Node_class<char,std::regex_traits<char> >, COMDAT
; _this$ = ecx

; 1865 :              {   // destroy

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 20   sub         esp, 32                        ; 00000020H
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00009 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000c c7 00 00 00 00
        00           mov     DWORD PTR [eax], OFFSET ??_7?$_Node_class@DV?$regex_traits@D@std@@@std@@6B@

; 1866 :              _Tidy(_Coll);

  00012 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00015 8b 51 14   mov         edx, DWORD PTR [ecx+20]
  00018 52                 push    edx
  00019 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001c e8 00 00 00 00     call    ?_Tidy@?$_Node_class@DV?$regex_traits@D@std@@@std@@QAEXPAU?$_Sequence@D@2@@Z ; std::_Node_class<char,std::regex_traits<char> >::_Tidy

; 1867 :              delete _Small;

  00021 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00024 8b 48 18   mov         ecx, DWORD PTR [eax+24]
  00027 89 4d f0   mov         DWORD PTR $T3[ebp], ecx
  0002a 6a 20        push        32             ; 00000020H
  0002c 8b 55 f0   mov         edx, DWORD PTR $T3[ebp]
  0002f 52                 push    edx
  00030 e8 00 00 00 00     call    ??3@YAXPAXI@Z                ; operator delete
  00035 83 c4 08   add         esp, 8

; 1868 :              delete _Large;

  00038 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0003b 8b 48 1c   mov         ecx, DWORD PTR [eax+28]
  0003e 89 4d ec   mov         DWORD PTR $T2[ebp], ecx
  00041 8b 55 ec   mov         edx, DWORD PTR $T2[ebp]
  00044 89 55 f8   mov         DWORD PTR $T5[ebp], edx
  00047 83 7d f8 00        cmp   DWORD PTR $T5[ebp], 0
  0004b 74 0f        je  SHORT $LN3@Node_class
  0004d 6a 01        push        1
  0004f 8b 4d f8   mov         ecx, DWORD PTR $T5[ebp]
  00052 e8 00 00 00 00     call    ??_G?$_Buf@D@std@@QAEPAXI@Z
  00057 89 45 e8   mov         DWORD PTR tv85[ebp], eax
  0005a eb 07        jmp         SHORT $LN4@Node_class
$LN3@Node_class:
  0005c c7 45 e8 00 00
        00 00          mov         DWORD PTR tv85[ebp], 0
$LN4@Node_class:

; 1869 :              delete _Ranges;

  00063 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00066 8b 48 20   mov         ecx, DWORD PTR [eax+32]
  00069 89 4d e4   mov         DWORD PTR $T1[ebp], ecx
  0006c 8b 55 e4   mov         edx, DWORD PTR $T1[ebp]
  0006f 89 55 f4   mov         DWORD PTR $T4[ebp], edx
  00072 83 7d f4 00        cmp   DWORD PTR $T4[ebp], 0
  00076 74 0f        je  SHORT $LN5@Node_class
  00078 6a 01        push        1
  0007a 8b 4d f4   mov         ecx, DWORD PTR $T4[ebp]
  0007d e8 00 00 00 00     call    ??_G?$_Buf@D@std@@QAEPAXI@Z
  00082 89 45 e0   mov         DWORD PTR tv91[ebp], eax
  00085 eb 07        jmp         SHORT $LN6@Node_class
$LN5@Node_class:
  00087 c7 45 e0 00 00
        00 00          mov         DWORD PTR tv91[ebp], 0
$LN6@Node_class:

; 1870 :              _Tidy(_Equiv);

  0008e 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00091 8b 48 28   mov         ecx, DWORD PTR [eax+40]
  00094 51                 push    ecx
  00095 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00098 e8 00 00 00 00     call    ?_Tidy@?$_Node_class@DV?$regex_traits@D@std@@@std@@QAEXPAU?$_Sequence@D@2@@Z ; std::_Node_class<char,std::regex_traits<char> >::_Tidy

; 1871 :              }

  0009d 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000a0 e8 00 00 00 00     call    ??1_Node_base@std@@UAE@XZ ; std::_Node_base::~_Node_base
  000a5 8b e5        mov         esp, ebp
  000a7 5d                 pop     ebp
  000a8 c3                 ret     0
??1?$_Node_class@DV?$regex_traits@D@std@@@std@@UAE@XZ ENDP ; std::_Node_class<char,std::regex_traits<char> >::~_Node_class<char,std::regex_traits<char> >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ??0?$_Node_class@DV?$regex_traits@D@std@@@std@@QAE@W4_Node_type@1@W4_Node_flags@1@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Ty$ = 8                                         ; size = 4
__Fl$ = 12                                          ; size = 4
??0?$_Node_class@DV?$regex_traits@D@std@@@std@@QAE@W4_Node_type@1@W4_Node_flags@1@@Z PROC ; std::_Node_class<char,std::regex_traits<char> >::_Node_class<char,std::regex_traits<char> >, COMDAT
; _this$ = ecx

; 1861 :              {   // construct

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1859 :              : _Node_base(_Ty, _Fl), _Coll(0), _Small(0), _Large(0), _Ranges(0),

  00007 8b 45 0c   mov         eax, DWORD PTR __Fl$[ebp]
  0000a 50                 push    eax
  0000b 8b 4d 08   mov         ecx, DWORD PTR __Ty$[ebp]
  0000e 51                 push    ecx
  0000f 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00012 e8 00 00 00 00     call    ??0_Node_base@std@@QAE@W4_Node_type@1@W4_Node_flags@1@@Z ; std::_Node_base::_Node_base

; 1861 :              {   // construct

  00017 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  0001a c7 02 00 00 00
        00           mov     DWORD PTR [edx], OFFSET ??_7?$_Node_class@DV?$regex_traits@D@std@@@std@@6B@

; 1859 :              : _Node_base(_Ty, _Fl), _Coll(0), _Small(0), _Large(0), _Ranges(0),

  00020 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00023 c7 40 14 00 00
        00 00          mov         DWORD PTR [eax+20], 0
  0002a 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0002d c7 41 18 00 00
        00 00          mov         DWORD PTR [ecx+24], 0
  00034 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  00037 c7 42 1c 00 00
        00 00          mov         DWORD PTR [edx+28], 0
  0003e 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00041 c7 40 20 00 00
        00 00          mov         DWORD PTR [eax+32], 0

; 1860 :              _Classes((typename _RxTraits::char_class_type)0), _Equiv(0)

  00048 33 c9        xor         ecx, ecx
  0004a 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  0004d 66 89 4a 24        mov   WORD PTR [edx+36], cx
  00051 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00054 c7 40 28 00 00
        00 00          mov         DWORD PTR [eax+40], 0

; 1862 :              }

  0005b 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0005e 8b e5        mov         esp, ebp
  00060 5d                 pop     ebp
  00061 c2 08 00   ret         8
??0?$_Node_class@DV?$regex_traits@D@std@@@std@@QAE@W4_Node_type@1@W4_Node_flags@1@@Z ENDP ; std::_Node_class<char,std::regex_traits<char> >::_Node_class<char,std::regex_traits<char> >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ??$lookup_classname@PBD@?$_Regex_traits@D@std@@QBEFPBD0_N@Z
_TEXT   SEGMENT
$T1 = -276                                          ; size = 4
_this$ = -272                                     ; size = 4
__Ix$ = -268                                            ; size = 4
__Mask$ = -264                                      ; size = 2
__Names$ = -260                               ; size = 256
__$ArrayPad$ = -4                                 ; size = 4
__First$ = 8                                            ; size = 4
__Last$ = 12                                            ; size = 4
__Icase$ = 16                                     ; size = 1
??$lookup_classname@PBD@?$_Regex_traits@D@std@@QBEFPBD0_N@Z PROC ; std::_Regex_traits<char>::lookup_classname<char const *>, COMDAT
; _this$ = ecx

; 347  :              {   // map [_First, _Last) to character class mask value

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 81 ec 14 01 00
        00           sub     esp, 276             ; 00000114H
  00009 a1 00 00 00 00     mov     eax, DWORD PTR ___security_cookie
  0000e 33 c5        xor         eax, ebp
  00010 89 45 fc   mov         DWORD PTR __$ArrayPad$[ebp], eax
  00013 89 8d f0 fe ff
        ff           mov     DWORD PTR _this$[ebp], ecx

; 348  :   #define _REGEX_CHAR_CLASS_NAME(n, c) \
; 349  :        {n, L ## n, sizeof (n) / sizeof (n[0]) - 1, c}
; 350  :              const _Cl_names _Names[] =
; 351  :                  {       // map class names to numeric constants
; 352  :                  _REGEX_CHAR_CLASS_NAME("alnum", _Ch_alnum),

  00019 c7 85 fc fe ff
        ff 00 00 00 00   mov         DWORD PTR __Names$[ebp], OFFSET ??_C@_05IIMHCHIO@alnum?$AA@
  00023 c7 85 00 ff ff
        ff 00 00 00 00   mov         DWORD PTR __Names$[ebp+4], OFFSET ??_C@_1M@KLMEPMCM@?$AAa?$AAl?$AAn?$AAu?$AAm?$AA?$AA@
  0002d c7 85 04 ff ff
        ff 05 00 00 00   mov         DWORD PTR __Names$[ebp+8], 5
  00037 b8 07 01 00 00     mov     eax, 263             ; 00000107H
  0003c 66 89 85 08 ff
        ff ff          mov         WORD PTR __Names$[ebp+12], ax

; 353  :                  _REGEX_CHAR_CLASS_NAME("alpha", _Ch_alpha),

  00043 c7 85 0c ff ff
        ff 00 00 00 00   mov         DWORD PTR __Names$[ebp+16], OFFSET ??_C@_05IAEKHIAN@alpha?$AA@
  0004d c7 85 10 ff ff
        ff 00 00 00 00   mov         DWORD PTR __Names$[ebp+20], OFFSET ??_C@_1M@DHGLHBMI@?$AAa?$AAl?$AAp?$AAh?$AAa?$AA?$AA@
  00057 c7 85 14 ff ff
        ff 05 00 00 00   mov         DWORD PTR __Names$[ebp+24], 5
  00061 b9 03 01 00 00     mov     ecx, 259             ; 00000103H
  00066 66 89 8d 18 ff
        ff ff          mov         WORD PTR __Names$[ebp+28], cx

; 354  :                  _REGEX_CHAR_CLASS_NAME("blank", _Ch_blank),

  0006d c7 85 1c ff ff
        ff 00 00 00 00   mov         DWORD PTR __Names$[ebp+32], OFFSET ??_C@_05BABJKOGB@blank?$AA@
  00077 c7 85 20 ff ff
        ff 00 00 00 00   mov         DWORD PTR __Names$[ebp+36], OFFSET ??_C@_1M@EJAAJBPE@?$AAb?$AAl?$AAa?$AAn?$AAk?$AA?$AA@
  00081 c7 85 24 ff ff
        ff 05 00 00 00   mov         DWORD PTR __Names$[ebp+40], 5
  0008b ba 48 00 00 00     mov     edx, 72                        ; 00000048H
  00090 66 89 95 28 ff
        ff ff          mov         WORD PTR __Names$[ebp+44], dx

; 355  :                  _REGEX_CHAR_CLASS_NAME("cntrl", _Ch_cntrl),

  00097 c7 85 2c ff ff
        ff 00 00 00 00   mov         DWORD PTR __Names$[ebp+48], OFFSET ??_C@_05JMDPEFNK@cntrl?$AA@
  000a1 c7 85 30 ff ff
        ff 00 00 00 00   mov         DWORD PTR __Names$[ebp+52], OFFSET ??_C@_1M@LMIMILA@?$AAc?$AAn?$AAt?$AAr?$AAl?$AA?$AA@
  000ab c7 85 34 ff ff
        ff 05 00 00 00   mov         DWORD PTR __Names$[ebp+56], 5
  000b5 b8 20 00 00 00     mov     eax, 32                        ; 00000020H
  000ba 66 89 85 38 ff
        ff ff          mov         WORD PTR __Names$[ebp+60], ax

; 356  :                  _REGEX_CHAR_CLASS_NAME("d", _Ch_digit),

  000c1 c7 85 3c ff ff
        ff 00 00 00 00   mov         DWORD PTR __Names$[ebp+64], OFFSET ??_C@_01LPLHEDKD@d?$AA@
  000cb c7 85 40 ff ff
        ff 00 00 00 00   mov         DWORD PTR __Names$[ebp+68], OFFSET ??_C@_13GKPPEALH@?$AAd?$AA?$AA@
  000d5 c7 85 44 ff ff
        ff 01 00 00 00   mov         DWORD PTR __Names$[ebp+72], 1
  000df b9 04 00 00 00     mov     ecx, 4
  000e4 66 89 8d 48 ff
        ff ff          mov         WORD PTR __Names$[ebp+76], cx

; 357  :                  _REGEX_CHAR_CLASS_NAME("digit", _Ch_digit),

  000eb c7 85 4c ff ff
        ff 00 00 00 00   mov         DWORD PTR __Names$[ebp+80], OFFSET ??_C@_05ODNOIFML@digit?$AA@
  000f5 c7 85 50 ff ff
        ff 00 00 00 00   mov         DWORD PTR __Names$[ebp+84], OFFSET ??_C@_1M@JDAEIBKG@?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?$AA@
  000ff c7 85 54 ff ff
        ff 05 00 00 00   mov         DWORD PTR __Names$[ebp+88], 5
  00109 ba 04 00 00 00     mov     edx, 4
  0010e 66 89 95 58 ff
        ff ff          mov         WORD PTR __Names$[ebp+92], dx

; 358  :                  _REGEX_CHAR_CLASS_NAME("graph", _Ch_graph),

  00115 c7 85 5c ff ff
        ff 00 00 00 00   mov         DWORD PTR __Names$[ebp+96], OFFSET ??_C@_05KCJBMLII@graph?$AA@
  0011f c7 85 60 ff ff
        ff 00 00 00 00   mov         DWORD PTR __Names$[ebp+100], OFFSET ??_C@_1M@MDKNJLLK@?$AAg?$AAr?$AAa?$AAp?$AAh?$AA?$AA@
  00129 c7 85 64 ff ff
        ff 05 00 00 00   mov         DWORD PTR __Names$[ebp+104], 5
  00133 b8 17 01 00 00     mov     eax, 279             ; 00000117H
  00138 66 89 85 68 ff
        ff ff          mov         WORD PTR __Names$[ebp+108], ax

; 359  :                  _REGEX_CHAR_CLASS_NAME("lower", _Ch_lower),

  0013f c7 85 6c ff ff
        ff 00 00 00 00   mov         DWORD PTR __Names$[ebp+112], OFFSET ??_C@_05IPJEPLHL@lower?$AA@
  00149 c7 85 70 ff ff
        ff 00 00 00 00   mov         DWORD PTR __Names$[ebp+116], OFFSET ??_C@_1M@LGAECJJD@?$AAl?$AAo?$AAw?$AAe?$AAr?$AA?$AA@
  00153 c7 85 74 ff ff
        ff 05 00 00 00   mov         DWORD PTR __Names$[ebp+120], 5
  0015d b9 02 00 00 00     mov     ecx, 2
  00162 66 89 8d 78 ff
        ff ff          mov         WORD PTR __Names$[ebp+124], cx

; 360  :                  _REGEX_CHAR_CLASS_NAME("print", _Ch_print),

  00169 c7 85 7c ff ff
        ff 00 00 00 00   mov         DWORD PTR __Names$[ebp+128], OFFSET ??_C@_05IJDJACGD@print?$AA@
  00173 c7 45 80 00 00
        00 00          mov         DWORD PTR __Names$[ebp+132], OFFSET ??_C@_1M@ELNLAPLA@?$AAp?$AAr?$AAi?$AAn?$AAt?$AA?$AA@
  0017a c7 45 84 05 00
        00 00          mov         DWORD PTR __Names$[ebp+136], 5
  00181 ba d7 01 00 00     mov     edx, 471             ; 000001d7H
  00186 66 89 55 88        mov   WORD PTR __Names$[ebp+140], dx

; 361  :                  _REGEX_CHAR_CLASS_NAME("punct", _Ch_punct),

  0018a c7 45 8c 00 00
        00 00          mov         DWORD PTR __Names$[ebp+144], OFFSET ??_C@_05KOBGHFJJ@punct?$AA@
  00191 c7 45 90 00 00
        00 00          mov         DWORD PTR __Names$[ebp+148], OFFSET ??_C@_1M@BPFMAOAO@?$AAp?$AAu?$AAn?$AAc?$AAt?$AA?$AA@
  00198 c7 45 94 05 00
        00 00          mov         DWORD PTR __Names$[ebp+152], 5
  0019f b8 10 00 00 00     mov     eax, 16                        ; 00000010H
  001a4 66 89 45 98        mov   WORD PTR __Names$[ebp+156], ax

; 362  :                  _REGEX_CHAR_CLASS_NAME("space", _Ch_space),

  001a8 c7 45 9c 00 00
        00 00          mov         DWORD PTR __Names$[ebp+160], OFFSET ??_C@_05OLNILLAB@space?$AA@
  001af c7 45 a0 00 00
        00 00          mov         DWORD PTR __Names$[ebp+164], OFFSET ??_C@_1M@LPGODFOM@?$AAs?$AAp?$AAa?$AAc?$AAe?$AA?$AA@
  001b6 c7 45 a4 05 00
        00 00          mov         DWORD PTR __Names$[ebp+168], 5
  001bd b9 48 00 00 00     mov     ecx, 72                        ; 00000048H
  001c2 66 89 4d a8        mov   WORD PTR __Names$[ebp+172], cx

; 363  :                  _REGEX_CHAR_CLASS_NAME("s", _Ch_space),

  001c6 c7 45 ac 00 00
        00 00          mov         DWORD PTR __Names$[ebp+176], OFFSET ??_C@_01LKDEMHDF@s?$AA@
  001cd c7 45 b0 00 00
        00 00          mov         DWORD PTR __Names$[ebp+180], OFFSET ??_C@_13KHDBCPJB@?$AAs?$AA?$AA@
  001d4 c7 45 b4 01 00
        00 00          mov         DWORD PTR __Names$[ebp+184], 1
  001db ba 48 00 00 00     mov     edx, 72                        ; 00000048H
  001e0 66 89 55 b8        mov   WORD PTR __Names$[ebp+188], dx

; 364  :                  _REGEX_CHAR_CLASS_NAME("upper", _Ch_upper),

  001e4 c7 45 bc 00 00
        00 00          mov         DWORD PTR __Names$[ebp+192], OFFSET ??_C@_05NECKJAMC@upper?$AA@
  001eb c7 45 c0 00 00
        00 00          mov         DWORD PTR __Names$[ebp+196], OFFSET ??_C@_1M@PLNFCNIC@?$AAu?$AAp?$AAp?$AAe?$AAr?$AA?$AA@
  001f2 c7 45 c4 05 00
        00 00          mov         DWORD PTR __Names$[ebp+200], 5
  001f9 b8 01 00 00 00     mov     eax, 1
  001fe 66 89 45 c8        mov   WORD PTR __Names$[ebp+204], ax

; 365  :                  _REGEX_CHAR_CLASS_NAME("w", (ctype_base::mask)(-1)),

  00202 c7 45 cc 00 00
        00 00          mov         DWORD PTR __Names$[ebp+208], OFFSET ??_C@_01NOFIACDB@w?$AA@
  00209 c7 45 d0 00 00
        00 00          mov         DWORD PTR __Names$[ebp+212], OFFSET ??_C@_13CIFDLIMG@?$AAw?$AA?$AA@
  00210 c7 45 d4 01 00
        00 00          mov         DWORD PTR __Names$[ebp+216], 1
  00217 83 c9 ff   or  ecx, -1
  0021a 66 89 4d d8        mov   WORD PTR __Names$[ebp+220], cx

; 366  :                  _REGEX_CHAR_CLASS_NAME("xdigit", _Ch_xdigit),

  0021e c7 45 dc 00 00
        00 00          mov         DWORD PTR __Names$[ebp+224], OFFSET ??_C@_06BAPHGFFK@xdigit?$AA@
  00225 c7 45 e0 00 00
        00 00          mov         DWORD PTR __Names$[ebp+228], OFFSET ??_C@_1O@OAFMJDHN@?$AAx?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?$AA@
  0022c c7 45 e4 06 00
        00 00          mov         DWORD PTR __Names$[ebp+232], 6
  00233 ba 80 00 00 00     mov     edx, 128             ; 00000080H
  00238 66 89 55 e8        mov   WORD PTR __Names$[ebp+236], dx

; 367  :                  {0, 0, 0},

  0023c c7 45 ec 00 00
        00 00          mov         DWORD PTR __Names$[ebp+240], 0
  00243 c7 45 f0 00 00
        00 00          mov         DWORD PTR __Names$[ebp+244], 0
  0024a c7 45 f4 00 00
        00 00          mov         DWORD PTR __Names$[ebp+248], 0
  00251 33 c0        xor         eax, eax
  00253 89 45 f8   mov         DWORD PTR __Names$[ebp+252], eax

; 368  :                  };
; 369  :   #undef _REGEX_CHAR_CLASS_NAME
; 370  :
; 371  :              _DEBUG_RANGE(_First, _Last);
; 372  :              unsigned int _Ix = 0;

  00256 c7 85 f4 fe ff
        ff 00 00 00 00   mov         DWORD PTR __Ix$[ebp], 0

; 373  :              for (; _Names[_Ix]._Get<_Elem>(); ++_Ix)

  00260 eb 0f        jmp         SHORT $LN4@lookup_cla
$LN2@lookup_cla:
  00262 8b 8d f4 fe ff
        ff           mov     ecx, DWORD PTR __Ix$[ebp]
  00268 83 c1 01   add         ecx, 1
  0026b 89 8d f4 fe ff
        ff           mov     DWORD PTR __Ix$[ebp], ecx
$LN4@lookup_cla:
  00271 8b 95 f4 fe ff
        ff           mov     edx, DWORD PTR __Ix$[ebp]
  00277 c1 e2 04   shl         edx, 4
  0027a 8d 8c 15 fc fe
        ff ff          lea         ecx, DWORD PTR __Names$[ebp+edx]
  00281 e8 00 00 00 00     call    ??$_Get@D@_Cl_names@std@@QBEPBDXZ ; std::_Cl_names::_Get<char>
  00286 85 c0        test        eax, eax
  00288 74 6f        je  SHORT $LN3@lookup_cla

; 374  :                  if (_STD equal(_First, _Last,

  0028a 8b 85 f0 fe ff
        ff           mov     eax, DWORD PTR _this$[ebp]
  00290 50                 push    eax
  00291 8d 8d ec fe ff
        ff           lea     ecx, DWORD PTR $T1[ebp]
  00297 e8 00 00 00 00     call    ??0?$_Cmp_icase@V?$_Regex_traits@D@std@@@std@@QAE@ABV?$_Regex_traits@D@1@@Z ; std::_Cmp_icase<std::_Regex_traits<char> >::_Cmp_icase<std::_Regex_traits<char> >
  0029c 8b 08        mov         ecx, DWORD PTR [eax]
  0029e 51                 push    ecx
  0029f 8b 95 f4 fe ff
        ff           mov     edx, DWORD PTR __Ix$[ebp]
  002a5 c1 e2 04   shl         edx, 4
  002a8 8d 8c 15 fc fe
        ff ff          lea         ecx, DWORD PTR __Names$[ebp+edx]
  002af e8 00 00 00 00     call    ??$_Get@D@_Cl_names@std@@QBEPBDXZ ; std::_Cl_names::_Get<char>
  002b4 8b 8d f4 fe ff
        ff           mov     ecx, DWORD PTR __Ix$[ebp]
  002ba c1 e1 04   shl         ecx, 4
  002bd 03 84 0d 04 ff
        ff ff          add         eax, DWORD PTR __Names$[ebp+ecx+8]
  002c4 50                 push    eax
  002c5 8b 95 f4 fe ff
        ff           mov     edx, DWORD PTR __Ix$[ebp]
  002cb c1 e2 04   shl         edx, 4
  002ce 8d 8c 15 fc fe
        ff ff          lea         ecx, DWORD PTR __Names$[ebp+edx]
  002d5 e8 00 00 00 00     call    ??$_Get@D@_Cl_names@std@@QBEPBDXZ ; std::_Cl_names::_Get<char>
  002da 50                 push    eax
  002db 8b 45 0c   mov         eax, DWORD PTR __Last$[ebp]
  002de 50                 push    eax
  002df 8b 4d 08   mov         ecx, DWORD PTR __First$[ebp]
  002e2 51                 push    ecx
  002e3 e8 00 00 00 00     call    ??$equal@PBDPBDU?$_Cmp_icase@V?$_Regex_traits@D@std@@@std@@@std@@YA_NPBD000U?$_Cmp_icase@V?$_Regex_traits@D@std@@@0@@Z ; std::equal<char const *,char const *,std::_Cmp_icase<std::_Regex_traits<char> > >
  002e8 83 c4 14   add         esp, 20                        ; 00000014H
  002eb 0f b6 d0   movzx       edx, al
  002ee 85 d2        test        edx, edx
  002f0 74 02        je  SHORT $LN5@lookup_cla

; 375  :                          _Names[_Ix]._Get<_Elem>(),
; 376  :                          _Names[_Ix]._Get<_Elem>() + _Names[_Ix]._Len,
; 377  :                          _Cmp_icase<_Regex_traits<_Elem> >(*this)))
; 378  :                          break;

  002f2 eb 05        jmp         SHORT $LN3@lookup_cla
$LN5@lookup_cla:

; 379  :
; 380  :              char_class_type _Mask = (char_class_type)0;

  002f4 e9 69 ff ff ff     jmp     $LN2@lookup_cla
$LN3@lookup_cla:
  002f9 33 c0        xor         eax, eax
  002fb 66 89 85 f8 fe
        ff ff          mov         WORD PTR __Mask$[ebp], ax

; 381  :              if (_Names[_Ix]._Get<_Elem>() != 0)

  00302 8b 8d f4 fe ff
        ff           mov     ecx, DWORD PTR __Ix$[ebp]
  00308 c1 e1 04   shl         ecx, 4
  0030b 8d 8c 0d fc fe
        ff ff          lea         ecx, DWORD PTR __Names$[ebp+ecx]
  00312 e8 00 00 00 00     call    ??$_Get@D@_Cl_names@std@@QBEPBDXZ ; std::_Cl_names::_Get<char>
  00317 85 c0        test        eax, eax
  00319 74 18        je  SHORT $LN6@lookup_cla

; 382  :                  _Mask = _Names[_Ix]._Ctype;

  0031b 8b 95 f4 fe ff
        ff           mov     edx, DWORD PTR __Ix$[ebp]
  00321 c1 e2 04   shl         edx, 4
  00324 66 8b 84 15 08
        ff ff ff         mov     ax, WORD PTR __Names$[ebp+edx+12]
  0032c 66 89 85 f8 fe
        ff ff          mov         WORD PTR __Mask$[ebp], ax
$LN6@lookup_cla:

; 383  :              if (_Icase && _Mask & (_Ch_lower | _Ch_upper))

  00333 0f b6 4d 10        movzx         ecx, BYTE PTR __Icase$[ebp]
  00337 85 c9        test        ecx, ecx
  00339 74 1d        je  SHORT $LN7@lookup_cla
  0033b 0f bf 95 f8 fe
        ff ff          movsx       edx, WORD PTR __Mask$[ebp]
  00342 83 e2 03   and         edx, 3
  00345 74 11        je  SHORT $LN7@lookup_cla

; 384  :                  _Mask |= _Ch_lower | _Ch_upper;

  00347 0f bf 85 f8 fe
        ff ff          movsx       eax, WORD PTR __Mask$[ebp]
  0034e 83 c8 03   or  eax, 3
  00351 66 89 85 f8 fe
        ff ff          mov         WORD PTR __Mask$[ebp], ax
$LN7@lookup_cla:

; 385  :              return (_Mask);

  00358 66 8b 85 f8 fe
        ff ff          mov         ax, WORD PTR __Mask$[ebp]

; 386  :              }

  0035f 8b 4d fc   mov         ecx, DWORD PTR __$ArrayPad$[ebp]
  00362 33 cd        xor         ecx, ebp
  00364 e8 00 00 00 00     call    @__security_check_cookie@4
  00369 8b e5        mov         esp, ebp
  0036b 5d                 pop     ebp
  0036c c2 0c 00   ret         12           ; 0000000cH
??$lookup_classname@PBD@?$_Regex_traits@D@std@@QBEFPBD0_N@Z ENDP ; std::_Regex_traits<char>::lookup_classname<char const *>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??G?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEHABV?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Right$ = 8                                            ; size = 4
??G?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEHABV?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@@Z PROC ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator-, COMDAT
; _this$ = ecx

; 2322 :              {   // return difference of iterators

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2323 :              return (*(_Mybase *)this - _Right);

  00007 8b 45 08   mov         eax, DWORD PTR __Right$[ebp]
  0000a 50                 push    eax
  0000b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000e e8 00 00 00 00     call    ??G?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEHABV01@@Z ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator-

; 2324 :              }

  00013 8b e5        mov         esp, ebp
  00015 5d                 pop     ebp
  00016 c2 04 00   ret         4
??G?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEHABV?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@@Z ENDP ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator-
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??G?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT   SEGMENT
__Tmp$ = -12                                            ; size = 8
_this$ = -4                                   ; size = 4
___$ReturnUdt$ = 8                                  ; size = 4
__Off$ = 12                                   ; size = 4
??G?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator-, COMDAT
; _this$ = ecx

; 2316 :              {   // return this - integer

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 0c   sub         esp, 12                        ; 0000000cH
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2317 :              _Mytype _Tmp = *this;

  00009 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000c 8b 08        mov         ecx, DWORD PTR [eax]
  0000e 8b 50 04   mov         edx, DWORD PTR [eax+4]
  00011 89 4d f4   mov         DWORD PTR __Tmp$[ebp], ecx
  00014 89 55 f8   mov         DWORD PTR __Tmp$[ebp+4], edx

; 2318 :              return (_Tmp -= _Off);

  00017 8b 45 0c   mov         eax, DWORD PTR __Off$[ebp]
  0001a 50                 push    eax
  0001b 8d 4d f4   lea         ecx, DWORD PTR __Tmp$[ebp]
  0001e e8 00 00 00 00     call    ??Z?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator-=
  00023 8b 08        mov         ecx, DWORD PTR [eax]
  00025 8b 50 04   mov         edx, DWORD PTR [eax+4]
  00028 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]
  0002b 89 08        mov         DWORD PTR [eax], ecx
  0002d 89 50 04   mov         DWORD PTR [eax+4], edx
  00030 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2319 :              }

  00033 8b e5        mov         esp, ebp
  00035 5d                 pop     ebp
  00036 c2 08 00   ret         8
??G?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator-
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??Z?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Off$ = 8                                          ; size = 4
??Z?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator-=, COMDAT
; _this$ = ecx

; 2311 :              {   // decrement by integer

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2312 :              return (*this += -_Off);

  00007 8b 45 08   mov         eax, DWORD PTR __Off$[ebp]
  0000a f7 d8        neg         eax
  0000c 50                 push    eax
  0000d 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00010 e8 00 00 00 00     call    ??Y?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator+=

; 2313 :              }

  00015 8b e5        mov         esp, ebp
  00017 5d                 pop     ebp
  00018 c2 04 00   ret         4
??Z?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator-=
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??H?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT   SEGMENT
__Tmp$ = -12                                            ; size = 8
_this$ = -4                                   ; size = 4
___$ReturnUdt$ = 8                                  ; size = 4
__Off$ = 12                                   ; size = 4
??H?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator+, COMDAT
; _this$ = ecx

; 2305 :              {   // return this + integer

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 0c   sub         esp, 12                        ; 0000000cH
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2306 :              _Mytype _Tmp = *this;

  00009 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000c 8b 08        mov         ecx, DWORD PTR [eax]
  0000e 8b 50 04   mov         edx, DWORD PTR [eax+4]
  00011 89 4d f4   mov         DWORD PTR __Tmp$[ebp], ecx
  00014 89 55 f8   mov         DWORD PTR __Tmp$[ebp+4], edx

; 2307 :              return (_Tmp += _Off);

  00017 8b 45 0c   mov         eax, DWORD PTR __Off$[ebp]
  0001a 50                 push    eax
  0001b 8d 4d f4   lea         ecx, DWORD PTR __Tmp$[ebp]
  0001e e8 00 00 00 00     call    ??Y?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator+=
  00023 8b 08        mov         ecx, DWORD PTR [eax]
  00025 8b 50 04   mov         edx, DWORD PTR [eax+4]
  00028 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]
  0002b 89 08        mov         DWORD PTR [eax], ecx
  0002d 89 50 04   mov         DWORD PTR [eax+4], edx
  00030 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2308 :              }

  00033 8b e5        mov         esp, ebp
  00035 5d                 pop     ebp
  00036 c2 08 00   ret         8
??H?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator+
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??Y?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Off$ = 8                                          ; size = 4
??Y?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator+=, COMDAT
; _this$ = ecx

; 2299 :              {   // increment by integer

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2300 :              *(_Mybase *)this += _Off;

  00007 8b 45 08   mov         eax, DWORD PTR __Off$[ebp]
  0000a 50                 push    eax
  0000b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000e e8 00 00 00 00     call    ??Y?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator+=

; 2301 :              return (*this);

  00013 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]

; 2302 :              }

  00016 8b e5        mov         esp, ebp
  00018 5d                 pop     ebp
  00019 c2 04 00   ret         4
??Y?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator+=
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??F?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??F?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator--, COMDAT
; _this$ = ecx

; 2286 :              {   // predecrement

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2287 :              --*(_Mybase *)this;

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ??F?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator--

; 2288 :              return (*this);

  0000f 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]

; 2289 :              }

  00012 8b e5        mov         esp, ebp
  00014 5d                 pop     ebp
  00015 c3                 ret     0
??F?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator--
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??E?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??E?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator++, COMDAT
; _this$ = ecx

; 2273 :              {   // preincrement

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2274 :              ++*(_Mybase *)this;

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ??E?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator++

; 2275 :              return (*this);

  0000f 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]

; 2276 :              }

  00012 8b e5        mov         esp, ebp
  00014 5d                 pop     ebp
  00015 c3                 ret     0
??E?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator++
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??D?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
___$ReturnUdt$ = 8                                  ; size = 4
??D?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@XZ PROC ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator*, COMDAT
; _this$ = ecx

; 2268 :              {   // return (reference to) designated object

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2269 :              return (_Reft(*this));

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a 50                 push    eax
  0000b 8b 4d 08   mov         ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0000e e8 00 00 00 00     call    ??0?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@@Z ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >
  00013 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2270 :              }

  00016 8b e5        mov         esp, ebp
  00018 5d                 pop     ebp
  00019 c2 04 00   ret         4
??D?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@XZ ENDP ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator*
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??0?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PAIPAU_Container_base0@1@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Ptr$ = 8                                          ; size = 4
__Mypvbool$ = 12                                        ; size = 4
??0?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PAIPAU_Container_base0@1@@Z PROC ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >, COMDAT
; _this$ = ecx

; 2264 :              {   // construct with offset and pointer

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2263 :              : _Mybase(_Ptr, _Mypvbool)

  00007 8b 45 0c   mov         eax, DWORD PTR __Mypvbool$[ebp]
  0000a 50                 push    eax
  0000b 8b 4d 08   mov         ecx, DWORD PTR __Ptr$[ebp]
  0000e 51                 push    ecx
  0000f 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00012 e8 00 00 00 00     call    ??0?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIPBU_Container_base0@1@@Z ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >

; 2265 :              }

  00017 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0001a 8b e5        mov         esp, ebp
  0001c 5d                 pop     ebp
  0001d c2 08 00   ret         8
??0?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PAIPAU_Container_base0@1@@Z ENDP ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Inc@?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Inc@?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXXZ PROC ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Inc, COMDAT
; _this$ = ecx

; 2202 :              {   // increment bit position

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2203 :              if (this->_Myoff < _VBITS - 1)

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a 83 78 04 1f        cmp   DWORD PTR [eax+4], 31      ; 0000001fH
  0000e 73 11        jae         SHORT $LN2@Inc

; 2204 :                  ++this->_Myoff;

  00010 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00013 8b 51 04   mov         edx, DWORD PTR [ecx+4]
  00016 83 c2 01   add         edx, 1
  00019 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0001c 89 50 04   mov         DWORD PTR [eax+4], edx

; 2205 :              else

  0001f eb 17        jmp         SHORT $LN1@Inc
$LN2@Inc:

; 2206 :                  {       // move to next word
; 2207 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2208 :                  if (this->_Getcont() == 0 || 0 < this->_Valid(1))
; 2209 :                          {       // report error
; 2210 :                          _DEBUG_ERROR("vector<bool> iterator not incrementable");
; 2211 :                          _SCL_SECURE_OUT_OF_RANGE;
; 2212 :                          }
; 2213 :
; 2214 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 2215 :                  _SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 2216 :                  _SCL_SECURE_VALIDATE_RANGE(this->_Valid(1) <= 0);
; 2217 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 2218 :
; 2219 :                  this->_Myoff = 0;

  00021 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00024 c7 41 04 00 00
        00 00          mov         DWORD PTR [ecx+4], 0

; 2220 :                  ++this->_Myptr;

  0002b 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  0002e 8b 02        mov         eax, DWORD PTR [edx]
  00030 83 c0 04   add         eax, 4
  00033 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00036 89 01        mov         DWORD PTR [ecx], eax
$LN1@Inc:

; 2221 :                  }
; 2222 :              }

  00038 8b e5        mov         esp, ebp
  0003a 5d                 pop     ebp
  0003b c3                 ret     0
?_Inc@?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Inc
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Dec@?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Dec@?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXXZ PROC ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Dec, COMDAT
; _this$ = ecx

; 2179 :              {   // decrement bit position

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2180 :              if (this->_Myoff != 0)

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a 83 78 04 00        cmp   DWORD PTR [eax+4], 0
  0000e 74 11        je  SHORT $LN2@Dec

; 2181 :                  --this->_Myoff;

  00010 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00013 8b 51 04   mov         edx, DWORD PTR [ecx+4]
  00016 83 ea 01   sub         edx, 1
  00019 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0001c 89 50 04   mov         DWORD PTR [eax+4], edx

; 2182 :              else

  0001f eb 17        jmp         SHORT $LN1@Dec
$LN2@Dec:

; 2183 :                  {       // move to previous word
; 2184 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2185 :                  if (this->_Getcont() == 0 || 0 < this->_Valid((size_type)-1))
; 2186 :                          {       // report error
; 2187 :                          _DEBUG_ERROR("vector<bool> iterator not decrementable");
; 2188 :                          _SCL_SECURE_OUT_OF_RANGE;
; 2189 :                          }
; 2190 :
; 2191 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 2192 :                  _SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 2193 :                  _SCL_SECURE_VALIDATE_RANGE(this->_Valid((size_type)-1) <= 0);
; 2194 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 2195 :
; 2196 :                  this->_Myoff = _VBITS - 1;

  00021 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00024 c7 41 04 1f 00
        00 00          mov         DWORD PTR [ecx+4], 31  ; 0000001fH

; 2197 :                  --this->_Myptr;

  0002b 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  0002e 8b 02        mov         eax, DWORD PTR [edx]
  00030 83 e8 04   sub         eax, 4
  00033 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00036 89 01        mov         DWORD PTR [ecx], eax
$LN1@Dec:

; 2198 :                  }
; 2199 :              }

  00038 8b e5        mov         esp, ebp
  0003a 5d                 pop     ebp
  0003b c3                 ret     0
?_Dec@?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Dec
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Compat@?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEXABV12@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
___formal$ = 8                                      ; size = 4
?_Compat@?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Compat, COMDAT
; _this$ = ecx

; 2174 :              {   // test for compatible iterator pair

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2175 :              }

  00007 8b e5        mov         esp, ebp
  00009 5d                 pop     ebp
  0000a c2 04 00   ret         4
?_Compat@?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Compat
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??9?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT   SEGMENT
_this$ = -8                                   ; size = 4
tv69 = -4                                         ; size = 4
__Right$ = 8                                            ; size = 4
??9?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator!=, COMDAT
; _this$ = ecx

; 2132 :              {   // test for iterator inequality

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d f8   mov         DWORD PTR _this$[ebp], ecx

; 2133 :              return (!(*this == _Right));

  00009 8b 45 08   mov         eax, DWORD PTR __Right$[ebp]
  0000c 50                 push    eax
  0000d 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00010 e8 00 00 00 00     call    ??8?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator==
  00015 0f b6 c8   movzx       ecx, al
  00018 85 c9        test        ecx, ecx
  0001a 75 09        jne         SHORT $LN3@operator
  0001c c7 45 fc 01 00
        00 00          mov         DWORD PTR tv69[ebp], 1
  00023 eb 07        jmp         SHORT $LN4@operator
$LN3@operator:
  00025 c7 45 fc 00 00
        00 00          mov         DWORD PTR tv69[ebp], 0
$LN4@operator:
  0002c 8a 45 fc   mov         al, BYTE PTR tv69[ebp]

; 2134 :              }

  0002f 8b e5        mov         esp, ebp
  00031 5d                 pop     ebp
  00032 c2 04 00   ret         4
??9?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator!=
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??8?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT   SEGMENT
tv88 = -8                                         ; size = 4
_this$ = -4                                   ; size = 4
__Right$ = 8                                            ; size = 4
??8?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator==, COMDAT
; _this$ = ecx

; 2125 :              {   // test for iterator equality

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2126 :              _Compat(_Right);

  00009 8b 45 08   mov         eax, DWORD PTR __Right$[ebp]
  0000c 50                 push    eax
  0000d 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00010 e8 00 00 00 00     call    ?_Compat@?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Compat

; 2127 :              return (this->_Myptr == _Right._Myptr

  00015 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00018 8b 55 08   mov         edx, DWORD PTR __Right$[ebp]
  0001b 8b 01        mov         eax, DWORD PTR [ecx]
  0001d 3b 02        cmp         eax, DWORD PTR [edx]
  0001f 75 17        jne         SHORT $LN3@operator
  00021 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00024 8b 55 08   mov         edx, DWORD PTR __Right$[ebp]
  00027 8b 41 04   mov         eax, DWORD PTR [ecx+4]
  0002a 3b 42 04   cmp         eax, DWORD PTR [edx+4]
  0002d 75 09        jne         SHORT $LN3@operator
  0002f c7 45 f8 01 00
        00 00          mov         DWORD PTR tv88[ebp], 1
  00036 eb 07        jmp         SHORT $LN4@operator
$LN3@operator:
  00038 c7 45 f8 00 00
        00 00          mov         DWORD PTR tv88[ebp], 0
$LN4@operator:
  0003f 8a 45 f8   mov         al, BYTE PTR tv88[ebp]

; 2128 :                  && this->_Myoff == _Right._Myoff);
; 2129 :              }

  00042 8b e5        mov         esp, ebp
  00044 5d                 pop     ebp
  00045 c2 04 00   ret         4
??8?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator==
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??G?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEHABV01@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Right$ = 8                                            ; size = 4
??G?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator-, COMDAT
; _this$ = ecx

; 2112 :              {   // return difference of iterators

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2113 :              _Compat(_Right);

  00007 8b 45 08   mov         eax, DWORD PTR __Right$[ebp]
  0000a 50                 push    eax
  0000b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000e e8 00 00 00 00     call    ?_Compat@?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Compat

; 2114 :              return (_VBITS * (this->_Myptr - _Right._Myptr)

  00013 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00016 8b 55 08   mov         edx, DWORD PTR __Right$[ebp]
  00019 8b 01        mov         eax, DWORD PTR [ecx]
  0001b 2b 02        sub         eax, DWORD PTR [edx]
  0001d c1 f8 02   sar         eax, 2
  00020 c1 e0 05   shl         eax, 5
  00023 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00026 03 41 04   add         eax, DWORD PTR [ecx+4]
  00029 8b 55 08   mov         edx, DWORD PTR __Right$[ebp]
  0002c 2b 42 04   sub         eax, DWORD PTR [edx+4]

; 2115 :                  + (difference_type)this->_Myoff
; 2116 :                  - (difference_type)_Right._Myoff);
; 2117 :              }

  0002f 8b e5        mov         esp, ebp
  00031 5d                 pop     ebp
  00032 c2 04 00   ret         4
??G?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator-
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??Y?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Off$ = 8                                          ; size = 4
??Y?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator+=, COMDAT
; _this$ = ecx

; 2077 :              {   // increment by integer

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2078 :              if (_Off < 0 && this->_Myoff < 0 - (size_type)_Off)

  00007 83 7d 08 00        cmp   DWORD PTR __Off$[ebp], 0
  0000b 7d 52        jge         SHORT $LN2@operator
  0000d 33 c0        xor         eax, eax
  0000f 2b 45 08   sub         eax, DWORD PTR __Off$[ebp]
  00012 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00015 39 41 04   cmp         DWORD PTR [ecx+4], eax
  00018 73 45        jae         SHORT $LN2@operator

; 2079 :                  {       /* add negative increment */
; 2080 :                  this->_Myoff += _Off;

  0001a 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  0001d 8b 42 04   mov         eax, DWORD PTR [edx+4]
  00020 03 45 08   add         eax, DWORD PTR __Off$[ebp]
  00023 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00026 89 41 04   mov         DWORD PTR [ecx+4], eax

; 2081 :                  this->_Myptr -= 1 + ((size_type)(-1) - this->_Myoff) / _VBITS;

  00029 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  0002c 83 c8 ff   or  eax, -1
  0002f 2b 42 04   sub         eax, DWORD PTR [edx+4]
  00032 c1 e8 05   shr         eax, 5
  00035 8d 0c 85 04 00
        00 00          lea         ecx, DWORD PTR [eax*4+4]
  0003c 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  0003f 8b 02        mov         eax, DWORD PTR [edx]
  00041 2b c1        sub         eax, ecx
  00043 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00046 89 01        mov         DWORD PTR [ecx], eax

; 2082 :                  this->_Myoff %= _VBITS;

  00048 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  0004b 8b 42 04   mov         eax, DWORD PTR [edx+4]
  0004e 33 d2        xor         edx, edx
  00050 b9 20 00 00 00     mov     ecx, 32                        ; 00000020H
  00055 f7 f1        div         ecx
  00057 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0005a 89 50 04   mov         DWORD PTR [eax+4], edx

; 2083 :                  }
; 2084 :              else

  0005d eb 3a        jmp         SHORT $LN3@operator
$LN2@operator:

; 2085 :                  {       /* add non-negative increment */
; 2086 :                  this->_Myoff += _Off;

  0005f 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00062 8b 51 04   mov         edx, DWORD PTR [ecx+4]
  00065 03 55 08   add         edx, DWORD PTR __Off$[ebp]
  00068 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0006b 89 50 04   mov         DWORD PTR [eax+4], edx

; 2087 :                  this->_Myptr += this->_Myoff / _VBITS;

  0006e 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00071 8b 51 04   mov         edx, DWORD PTR [ecx+4]
  00074 c1 ea 05   shr         edx, 5
  00077 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0007a 8b 08        mov         ecx, DWORD PTR [eax]
  0007c 8d 14 91   lea         edx, DWORD PTR [ecx+edx*4]
  0007f 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00082 89 10        mov         DWORD PTR [eax], edx

; 2088 :                  this->_Myoff %= _VBITS;

  00084 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00087 8b 41 04   mov         eax, DWORD PTR [ecx+4]
  0008a 33 d2        xor         edx, edx
  0008c b9 20 00 00 00     mov     ecx, 32                        ; 00000020H
  00091 f7 f1        div         ecx
  00093 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00096 89 50 04   mov         DWORD PTR [eax+4], edx
$LN3@operator:

; 2089 :                  }
; 2090 :              return (*this);

  00099 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]

; 2091 :              }

  0009c 8b e5        mov         esp, ebp
  0009e 5d                 pop     ebp
  0009f c2 04 00   ret         4
??Y?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator+=
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??F?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??F?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator--, COMDAT
; _this$ = ecx

; 2064 :              {   // predecrement

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2065 :              _Dec();

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Dec@?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXXZ ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Dec

; 2066 :              return (*this);

  0000f 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]

; 2067 :              }

  00012 8b e5        mov         esp, ebp
  00014 5d                 pop     ebp
  00015 c3                 ret     0
??F?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator--
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??E?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??E?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator++, COMDAT
; _this$ = ecx

; 2051 :              {   // preincrement

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2052 :              _Inc();

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Inc@?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXXZ ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Inc

; 2053 :              return (*this);

  0000f 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]

; 2054 :              }

  00012 8b e5        mov         esp, ebp
  00014 5d                 pop     ebp
  00015 c3                 ret     0
??E?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator++
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??0?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIPBU_Container_base0@1@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Ptr$ = 8                                          ; size = 4
__Mypvbool$ = 12                                        ; size = 4
??0?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIPBU_Container_base0@1@@Z PROC ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >, COMDAT
; _this$ = ecx

; 2042 :              {   // construct with offset and pointer

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2041 :              : _Mybase(_Ptr, 0, _Mypvbool)

  00007 8b 45 0c   mov         eax, DWORD PTR __Mypvbool$[ebp]
  0000a 50                 push    eax
  0000b 6a 00        push        0
  0000d 8b 4d 08   mov         ecx, DWORD PTR __Ptr$[ebp]
  00010 51                 push    ecx
  00011 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00014 e8 00 00 00 00     call    ??0?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIIPBU_Container_base0@1@@Z ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >

; 2043 :              }

  00019 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0001c 8b e5        mov         esp, ebp
  0001e 5d                 pop     ebp
  0001f c2 08 00   ret         8
??0?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIPBU_Container_base0@1@@Z ENDP ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;       COMDAT ??$construct@IABI@?$allocator_traits@V?$allocator@I@std@@@std@@SAXAAV?$allocator@I@1@PAIABI@Z
_TEXT   SEGMENT
__Al$ = 8                                         ; size = 4
__Ptr$ = 12                                   ; size = 4
_<_Args_0>$ = 16                                        ; size = 4
??$construct@IABI@?$allocator_traits@V?$allocator@I@std@@@std@@SAXAAV?$allocator@I@1@PAIABI@Z PROC ; std::allocator_traits<std::allocator<unsigned int> >::construct<unsigned int,unsigned int const &>, COMDAT

; 754  :              {   // construct _Objty(_Types...) at _Ptr

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 755  :              _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  00003 8b 45 10   mov         eax, DWORD PTR _<_Args_0>$[ebp]
  00006 50                 push    eax
  00007 e8 00 00 00 00     call    ??$forward@ABI@std@@YAABIABI@Z ; std::forward<unsigned int const &>
  0000c 83 c4 04   add         esp, 4
  0000f 50                 push    eax
  00010 8b 4d 0c   mov         ecx, DWORD PTR __Ptr$[ebp]
  00013 51                 push    ecx
  00014 8b 4d 08   mov         ecx, DWORD PTR __Al$[ebp]
  00017 e8 00 00 00 00     call    ??$construct@IABI@?$allocator@I@std@@QAEXPAIABI@Z ; std::allocator<unsigned int>::construct<unsigned int,unsigned int const &>

; 756  :              }

  0001c 5d                 pop     ebp
  0001d c3                 ret     0
??$construct@IABI@?$allocator_traits@V?$allocator@I@std@@@std@@SAXAAV?$allocator@I@1@PAIABI@Z ENDP ; std::allocator_traits<std::allocator<unsigned int> >::construct<unsigned int,unsigned int const &>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;       COMDAT ??$forward@ABI@std@@YAABIABI@Z
_TEXT   SEGMENT
__Arg$ = 8                                          ; size = 4
??$forward@ABI@std@@YAABIABI@Z PROC           ; std::forward<unsigned int const &>, COMDAT

; 1298 :        {     // forward an lvalue as either an lvalue or an rvalue

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 1299 :        return (static_cast<_Ty&&>(_Arg));

  00003 8b 45 08   mov         eax, DWORD PTR __Arg$[ebp]

; 1300 :        }

  00006 5d                 pop     ebp
  00007 c3                 ret     0
??$forward@ABI@std@@YAABIABI@Z ENDP           ; std::forward<unsigned int const &>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;       COMDAT ??$?0_N@?$allocator@I@std@@QAE@ABV?$allocator@_N@1@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
___formal$ = 8                                      ; size = 4
??$?0_N@?$allocator@I@std@@QAE@ABV?$allocator@_N@1@@Z PROC ; std::allocator<unsigned int>::allocator<unsigned int><bool>, COMDAT
; _this$ = ecx

; 609  :              {   // construct from a related allocator (do nothing)

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 610  :              }

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a 8b e5        mov         esp, ebp
  0000c 5d                 pop     ebp
  0000d c2 04 00   ret         4
??$?0_N@?$allocator@I@std@@QAE@ABV?$allocator@_N@1@@Z ENDP ; std::allocator<unsigned int>::allocator<unsigned int><bool>
_TEXT   ENDS
; Function compile flags: /Odtp
;       COMDAT ??_G?$_Node_str@D@std@@UAEPAXI@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
___flags$ = 8                                     ; size = 4
??_G?$_Node_str@D@std@@UAEPAXI@Z PROC             ; std::_Node_str<char>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ??1?$_Node_str@D@std@@UAE@XZ
  0000f 8b 45 08   mov         eax, DWORD PTR ___flags$[ebp]
  00012 83 e0 01   and         eax, 1
  00015 74 0e        je  SHORT $LN2@scalar
  00017 6a 20        push        32             ; 00000020H
  00019 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001c 51                 push    ecx
  0001d e8 00 00 00 00     call    ??3@YAXPAXI@Z                ; operator delete
  00022 83 c4 08   add         esp, 8
$LN2@scalar:
  00025 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00028 8b e5        mov         esp, ebp
  0002a 5d                 pop     ebp
  0002b c2 04 00   ret         4
??_G?$_Node_str@D@std@@UAEPAXI@Z ENDP             ; std::_Node_str<char>::`scalar deleting destructor'
_TEXT   ENDS
; Function compile flags: /Odtp
;       COMDAT ??1?$_Node_str@D@std@@UAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??1?$_Node_str@D@std@@UAE@XZ PROC                 ; std::_Node_str<char>::~_Node_str<char>, COMDAT
; _this$ = ecx
  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a 83 c1 14   add         ecx, 20                        ; 00000014H
  0000d e8 00 00 00 00     call    ??1?$_Buf@D@std@@QAE@XZ      ; std::_Buf<char>::~_Buf<char>
  00012 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00015 e8 00 00 00 00     call    ??1_Node_base@std@@UAE@XZ ; std::_Node_base::~_Node_base
  0001a 8b e5        mov         esp, ebp
  0001c 5d                 pop     ebp
  0001d c3                 ret     0
??1?$_Node_str@D@std@@UAE@XZ ENDP                 ; std::_Node_str<char>::~_Node_str<char>
_TEXT   ENDS
; Function compile flags: /Odtp
;       COMDAT ??_G?$_Buf@D@std@@QAEPAXI@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
___flags$ = 8                                     ; size = 4
??_G?$_Buf@D@std@@QAEPAXI@Z PROC                        ; std::_Buf<char>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ??1?$_Buf@D@std@@QAE@XZ      ; std::_Buf<char>::~_Buf<char>
  0000f 8b 45 08   mov         eax, DWORD PTR ___flags$[ebp]
  00012 83 e0 01   and         eax, 1
  00015 74 0e        je  SHORT $LN2@scalar
  00017 6a 0c        push        12             ; 0000000cH
  00019 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001c 51                 push    ecx
  0001d e8 00 00 00 00     call    ??3@YAXPAXI@Z                ; operator delete
  00022 83 c4 08   add         esp, 8
$LN2@scalar:
  00025 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00028 8b e5        mov         esp, ebp
  0002a 5d                 pop     ebp
  0002b c2 04 00   ret         4
??_G?$_Buf@D@std@@QAEPAXI@Z ENDP                        ; std::_Buf<char>::`scalar deleting destructor'
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Expand@?$_Buf@D@std@@AAEXI@Z
_TEXT   SEGMENT
__Tmp$ = -8                                   ; size = 4
_this$ = -4                                   ; size = 4
__Len$ = 8                                          ; size = 4
?_Expand@?$_Buf@D@std@@AAEXI@Z PROC           ; std::_Buf<char>::_Expand, COMDAT
; _this$ = ecx

; 1675 :              {   // expand buffer to hold _Len characters

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1676 :              _Elem *_Tmp = (_Elem *)realloc(_Chrs, _Len * sizeof (_Elem));

  00009 8b 45 08   mov         eax, DWORD PTR __Len$[ebp]
  0000c 50                 push    eax
  0000d 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00010 8b 51 08   mov         edx, DWORD PTR [ecx+8]
  00013 52                 push    edx
  00014 e8 00 00 00 00     call    _realloc
  00019 83 c4 08   add         esp, 8
  0001c 89 45 f8   mov         DWORD PTR __Tmp$[ebp], eax

; 1677 :              if (!_Tmp)

  0001f 83 7d f8 00        cmp   DWORD PTR __Tmp$[ebp], 0
  00023 75 05        jne         SHORT $LN2@Expand

; 1678 :                  _Xbad_alloc();

  00025 e8 00 00 00 00     call    ?_Xbad_alloc@std@@YAXXZ      ; std::_Xbad_alloc
$LN2@Expand:

; 1679 :              _Chrs = _Tmp;

  0002a 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0002d 8b 4d f8   mov         ecx, DWORD PTR __Tmp$[ebp]
  00030 89 48 08   mov         DWORD PTR [eax+8], ecx

; 1680 :              _Sz = _Len;

  00033 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  00036 8b 45 08   mov         eax, DWORD PTR __Len$[ebp]
  00039 89 02        mov         DWORD PTR [edx], eax
$LN3@Expand:

; 1681 :              }

  0003b 8b e5        mov         esp, ebp
  0003d 5d                 pop     ebp
  0003e c2 04 00   ret         4
?_Expand@?$_Buf@D@std@@AAEXI@Z ENDP           ; std::_Buf<char>::_Expand
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Del@?$_Buf@D@std@@QAEDXZ
_TEXT   SEGMENT
tv69 = -8                                         ; size = 4
_this$ = -4                                   ; size = 4
?_Del@?$_Buf@D@std@@QAEDXZ PROC               ; std::_Buf<char>::_Del, COMDAT
; _this$ = ecx

; 1662 :              {   // remove and return last character

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1663 :              return (_Chrs[--_Nchrs]);

  00009 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000c 8b 48 04   mov         ecx, DWORD PTR [eax+4]
  0000f 83 e9 01   sub         ecx, 1
  00012 89 4d f8   mov         DWORD PTR tv69[ebp], ecx
  00015 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  00018 8b 45 f8   mov         eax, DWORD PTR tv69[ebp]
  0001b 89 42 04   mov         DWORD PTR [edx+4], eax
  0001e 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00021 8b 51 08   mov         edx, DWORD PTR [ecx+8]
  00024 8b 45 f8   mov         eax, DWORD PTR tv69[ebp]
  00027 8a 04 02   mov         al, BYTE PTR [edx+eax]

; 1664 :              }

  0002a 8b e5        mov         esp, ebp
  0002c 5d                 pop     ebp
  0002d c3                 ret     0
?_Del@?$_Buf@D@std@@QAEDXZ ENDP               ; std::_Buf<char>::_Del
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Insert@?$_Buf@D@std@@QAEXD@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Ch$ = 8                                         ; size = 1
?_Insert@?$_Buf@D@std@@QAEXD@Z PROC           ; std::_Buf<char>::_Insert, COMDAT
; _this$ = ecx

; 1655 :              {   // append _Ch

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1656 :              if (_Sz <= _Nchrs)

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000d 8b 10        mov         edx, DWORD PTR [eax]
  0000f 3b 51 04   cmp         edx, DWORD PTR [ecx+4]
  00012 77 12        ja  SHORT $LN2@Insert

; 1657 :                  _Expand(_Nchrs + _Buf_incr);

  00014 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00017 8b 48 04   mov         ecx, DWORD PTR [eax+4]
  0001a 83 c1 10   add         ecx, 16                        ; 00000010H
  0001d 51                 push    ecx
  0001e 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00021 e8 00 00 00 00     call    ?_Expand@?$_Buf@D@std@@AAEXI@Z ; std::_Buf<char>::_Expand
$LN2@Insert:

; 1658 :              _Chrs[_Nchrs++] = _Ch;

  00026 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  00029 8b 42 04   mov         eax, DWORD PTR [edx+4]
  0002c 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0002f 8b 51 08   mov         edx, DWORD PTR [ecx+8]
  00032 8a 4d 08   mov         cl, BYTE PTR __Ch$[ebp]
  00035 88 0c 02   mov         BYTE PTR [edx+eax], cl
  00038 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  0003b 8b 42 04   mov         eax, DWORD PTR [edx+4]
  0003e 83 c0 01   add         eax, 1
  00041 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00044 89 41 04   mov         DWORD PTR [ecx+4], eax

; 1659 :              }

  00047 8b e5        mov         esp, ebp
  00049 5d                 pop     ebp
  0004a c2 04 00   ret         4
?_Insert@?$_Buf@D@std@@QAEXD@Z ENDP           ; std::_Buf<char>::_Insert
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Size@?$_Buf@D@std@@QBEIXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Size@?$_Buf@D@std@@QBEIXZ PROC                        ; std::_Buf<char>::_Size, COMDAT
; _this$ = ecx

; 1632 :              {   // return number of characters held in buffer

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1633 :              return (_Nchrs);

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a 8b 40 04   mov         eax, DWORD PTR [eax+4]

; 1634 :              }

  0000d 8b e5        mov         esp, ebp
  0000f 5d                 pop     ebp
  00010 c3                 ret     0
?_Size@?$_Buf@D@std@@QBEIXZ ENDP                        ; std::_Buf<char>::_Size
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ??1?$_Buf@D@std@@QAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??1?$_Buf@D@std@@QAE@XZ PROC                            ; std::_Buf<char>::~_Buf<char>, COMDAT
; _this$ = ecx

; 1627 :              {   // destroy

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1628 :              free(_Chrs);

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a 8b 48 08   mov         ecx, DWORD PTR [eax+8]
  0000d 51                 push    ecx
  0000e e8 00 00 00 00     call    _free
  00013 83 c4 04   add         esp, 4

; 1629 :              }

  00016 8b e5        mov         esp, ebp
  00018 5d                 pop     ebp
  00019 c3                 ret     0
??1?$_Buf@D@std@@QAE@XZ ENDP                            ; std::_Buf<char>::~_Buf<char>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ??0?$_Buf@D@std@@QAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??0?$_Buf@D@std@@QAE@XZ PROC                            ; std::_Buf<char>::_Buf<char>, COMDAT
; _this$ = ecx

; 1623 :              {   // construct

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1622 :              : _Sz(0), _Nchrs(0), _Chrs(0)

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a c7 00 00 00 00
        00           mov     DWORD PTR [eax], 0
  00010 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00013 c7 41 04 00 00
        00 00          mov         DWORD PTR [ecx+4], 0
  0001a 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  0001d c7 42 08 00 00
        00 00          mov         DWORD PTR [edx+8], 0

; 1624 :              }

  00024 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00027 8b e5        mov         esp, ebp
  00029 5d                 pop     ebp
  0002a c3                 ret     0
??0?$_Buf@D@std@@QAE@XZ ENDP                            ; std::_Buf<char>::_Buf<char>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ??0?$_Node_str@D@std@@QAE@W4_Node_flags@1@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Fl$ = 8                                         ; size = 4
??0?$_Node_str@D@std@@QAE@W4_Node_flags@1@@Z PROC       ; std::_Node_str<char>::_Node_str<char>, COMDAT
; _this$ = ecx

; 1845 :              {   // construct

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1844 :              : _Node_base(_N_str, _Fl)

  00007 8b 45 08   mov         eax, DWORD PTR __Fl$[ebp]
  0000a 50                 push    eax
  0000b 6a 06        push        6
  0000d 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00010 e8 00 00 00 00     call    ??0_Node_base@std@@QAE@W4_Node_type@1@W4_Node_flags@1@@Z ; std::_Node_base::_Node_base

; 1845 :              {   // construct

  00015 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00018 c7 01 00 00 00
        00           mov     DWORD PTR [ecx], OFFSET ??_7?$_Node_str@D@std@@6B@
  0001e 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00021 83 c1 14   add         ecx, 20                        ; 00000014H
  00024 e8 00 00 00 00     call    ??0?$_Buf@D@std@@QAE@XZ      ; std::_Buf<char>::_Buf<char>

; 1846 :              }

  00029 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0002c 8b e5        mov         esp, ebp
  0002e 5d                 pop     ebp
  0002f c2 04 00   ret         4
??0?$_Node_str@D@std@@QAE@W4_Node_flags@1@@Z ENDP       ; std::_Node_str<char>::_Node_str<char>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Mask@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@IBEIXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Mask@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@IBEIXZ PROC ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Mask, COMDAT
; _this$ = ecx

; 2003 :              {   // convert offset to mask

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2004 :              return ((_Vbase)(1) << this->_Myoff);

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a ba 01 00 00 00     mov     edx, 1
  0000f 8b 48 04   mov         ecx, DWORD PTR [eax+4]
  00012 d3 e2        shl         edx, cl
  00014 8b c2        mov         eax, edx

; 2005 :              }

  00016 8b e5        mov         esp, ebp
  00018 5d                 pop     ebp
  00019 c3                 ret     0
?_Mask@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@IBEIXZ ENDP ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Mask
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Getptr@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEPBIXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Getptr@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEPBIXZ PROC ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Getptr, COMDAT
; _this$ = ecx

; 1983 :              {   // get pointer to base word

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1984 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1985 :              if (this->_Getcont() == 0
; 1986 :                  || this->_Myptr == 0
; 1987 :                  || 0 <= this->_Valid(0))
; 1988 :                  {       // report error
; 1989 :                  _DEBUG_ERROR("vector<bool> iterator not dereferencable");
; 1990 :                  _SCL_SECURE_OUT_OF_RANGE;
; 1991 :                  }
; 1992 :
; 1993 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1994 :              _SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Myptr != 0);
; 1995 :              _SCL_SECURE_VALIDATE_RANGE(this->_Valid(0) < 0);
; 1996 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1997 :
; 1998 :              return (this->_Myptr);

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a 8b 00        mov         eax, DWORD PTR [eax]

; 1999 :              }

  0000c 8b e5        mov         esp, ebp
  0000e 5d                 pop     ebp
  0000f c3                 ret     0
?_Getptr@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEPBIXZ ENDP ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Getptr
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??B?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE_NXZ
_TEXT   SEGMENT
tv70 = -8                                         ; size = 4
_this$ = -4                                   ; size = 4
??B?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE_NXZ PROC ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator bool, COMDAT
; _this$ = ecx

; 1978 :              {   // test if bit is set

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 56                 push    esi
  00007 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1979 :              return ((*_Getptr() & _Mask()) != 0);

  0000a 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000d e8 00 00 00 00     call    ?_Getptr@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEPBIXZ ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Getptr
  00012 8b f0        mov         esi, eax
  00014 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00017 e8 00 00 00 00     call    ?_Mask@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@IBEIXZ ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Mask
  0001c 23 06        and         eax, DWORD PTR [esi]
  0001e 74 09        je  SHORT $LN3@operator
  00020 c7 45 f8 01 00
        00 00          mov         DWORD PTR tv70[ebp], 1
  00027 eb 07        jmp         SHORT $LN4@operator
$LN3@operator:
  00029 c7 45 f8 00 00
        00 00          mov         DWORD PTR tv70[ebp], 0
$LN4@operator:
  00030 8a 45 f8   mov         al, BYTE PTR tv70[ebp]

; 1980 :              }

  00033 5e                 pop     esi
  00034 8b e5        mov         esp, ebp
  00036 5d                 pop     ebp
  00037 c3                 ret     0
??B?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE_NXZ ENDP ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator bool
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??4?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@_N@Z
_TEXT   SEGMENT
tv77 = -12                                          ; size = 4
tv70 = -8                                         ; size = 4
_this$ = -4                                   ; size = 4
__Val$ = 8                                          ; size = 1
??4?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@_N@Z PROC ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator=, COMDAT
; _this$ = ecx

; 1964 :              {   // assign _Val to bit

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 0c   sub         esp, 12                        ; 0000000cH
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1965 :              if (_Val)

  00009 0f b6 45 08        movzx         eax, BYTE PTR __Val$[ebp]
  0000d 85 c0        test        eax, eax
  0000f 74 1f        je  SHORT $LN2@operator

; 1966 :                  *(_Vbase *)_Getptr() |= _Mask();

  00011 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00014 e8 00 00 00 00     call    ?_Getptr@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEPBIXZ ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Getptr
  00019 89 45 f8   mov         DWORD PTR tv70[ebp], eax
  0001c 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001f e8 00 00 00 00     call    ?_Mask@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@IBEIXZ ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Mask
  00024 8b 4d f8   mov         ecx, DWORD PTR tv70[ebp]
  00027 0b 01        or  eax, DWORD PTR [ecx]
  00029 8b 55 f8   mov         edx, DWORD PTR tv70[ebp]
  0002c 89 02        mov         DWORD PTR [edx], eax

; 1967 :              else

  0002e eb 1f        jmp         SHORT $LN3@operator
$LN2@operator:

; 1968 :                  *(_Vbase *)_Getptr() &= (~_Mask());     // STET

  00030 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00033 e8 00 00 00 00     call    ?_Getptr@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEPBIXZ ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Getptr
  00038 89 45 f4   mov         DWORD PTR tv77[ebp], eax
  0003b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0003e e8 00 00 00 00     call    ?_Mask@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@IBEIXZ ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Mask
  00043 f7 d0        not         eax
  00045 8b 4d f4   mov         ecx, DWORD PTR tv77[ebp]
  00048 23 01        and         eax, DWORD PTR [ecx]
  0004a 8b 55 f4   mov         edx, DWORD PTR tv77[ebp]
  0004d 89 02        mov         DWORD PTR [edx], eax
$LN3@operator:

; 1969 :              return (*this);

  0004f 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]

; 1970 :              }

  00052 8b e5        mov         esp, ebp
  00054 5d                 pop     ebp
  00055 c2 04 00   ret         4
??4?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@_N@Z ENDP ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator=
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??4?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Right$ = 8                                            ; size = 4
??4?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator=, COMDAT
; _this$ = ecx

; 1959 :              {   // assign _Vb_reference _Right to bit

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1960 :              return (*this = bool(_Right));

  00007 8b 4d 08   mov         ecx, DWORD PTR __Right$[ebp]
  0000a e8 00 00 00 00     call    ??B?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE_NXZ ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator bool
  0000f 0f b6 c0   movzx       eax, al
  00012 50                 push    eax
  00013 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00016 e8 00 00 00 00     call    ??4?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@_N@Z ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator=

; 1961 :              }

  0001b 8b e5        mov         esp, ebp
  0001d 5d                 pop     ebp
  0001e c2 04 00   ret         4
??4?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator=
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??0?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Right$ = 8                                            ; size = 4
??0?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@@Z PROC ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >, COMDAT
; _this$ = ecx

; 1955 :              {   // construct with base

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1954 :              : _Mybase(_Right._Myptr, _Right._Myoff, _Right._Getcont())

  00007 8b 4d 08   mov         ecx, DWORD PTR __Right$[ebp]
  0000a e8 00 00 00 00     call    ?_Getcont@_Iterator_base0@std@@QBEPBU_Container_base0@2@XZ ; std::_Iterator_base0::_Getcont
  0000f 50                 push    eax
  00010 8b 45 08   mov         eax, DWORD PTR __Right$[ebp]
  00013 8b 48 04   mov         ecx, DWORD PTR [eax+4]
  00016 51                 push    ecx
  00017 8b 55 08   mov         edx, DWORD PTR __Right$[ebp]
  0001a 8b 02        mov         eax, DWORD PTR [edx]
  0001c 50                 push    eax
  0001d 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00020 e8 00 00 00 00     call    ??0?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIIPBU_Container_base0@1@@Z ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >

; 1956 :              }

  00025 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00028 8b e5        mov         esp, ebp
  0002a 5d                 pop     ebp
  0002b c2 04 00   ret         4
??0?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@@Z ENDP ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Advance@?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXI@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Off$ = 8                                          ; size = 4
?_Advance@?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXI@Z PROC ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Advance, COMDAT
; _this$ = ecx

; 1914 :              {   // advance iterator by _Off

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1915 :              _Myoff += _Off;

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a 8b 48 04   mov         ecx, DWORD PTR [eax+4]
  0000d 03 4d 08   add         ecx, DWORD PTR __Off$[ebp]
  00010 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  00013 89 4a 04   mov         DWORD PTR [edx+4], ecx

; 1916 :              _Myptr += _Myoff / _VBITS;

  00016 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00019 8b 48 04   mov         ecx, DWORD PTR [eax+4]
  0001c c1 e9 05   shr         ecx, 5
  0001f 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  00022 8b 02        mov         eax, DWORD PTR [edx]
  00024 8d 0c 88   lea         ecx, DWORD PTR [eax+ecx*4]
  00027 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  0002a 89 0a        mov         DWORD PTR [edx], ecx

; 1917 :              _Myoff %= _VBITS;

  0002c 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0002f 8b 40 04   mov         eax, DWORD PTR [eax+4]
  00032 33 d2        xor         edx, edx
  00034 b9 20 00 00 00     mov     ecx, 32                        ; 00000020H
  00039 f7 f1        div         ecx
  0003b 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0003e 89 50 04   mov         DWORD PTR [eax+4], edx

; 1918 :              }

  00041 8b e5        mov         esp, ebp
  00043 5d                 pop     ebp
  00044 c2 04 00   ret         4
?_Advance@?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXI@Z ENDP ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Advance
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??0?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIIPBU_Container_base0@1@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Ptr$ = 8                                          ; size = 4
__Off$ = 12                                   ; size = 4
__Mypvbool$ = 16                                        ; size = 4
??0?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIIPBU_Container_base0@1@@Z PROC ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >, COMDAT
; _this$ = ecx

; 1909 :              {   // construct with offset and pointer

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1908 :              : _Myptr(_Ptr), _Myoff(_Off)

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a 8b 4d 08   mov         ecx, DWORD PTR __Ptr$[ebp]
  0000d 89 08        mov         DWORD PTR [eax], ecx
  0000f 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  00012 8b 45 0c   mov         eax, DWORD PTR __Off$[ebp]
  00015 89 42 04   mov         DWORD PTR [edx+4], eax

; 1910 :              this->_Adopt(_Mypvbool);

  00018 8b 4d 10   mov         ecx, DWORD PTR __Mypvbool$[ebp]
  0001b 51                 push    ecx
  0001c 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001f e8 00 00 00 00     call    ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 1911 :              }

  00024 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00027 8b e5        mov         esp, ebp
  00029 5d                 pop     ebp
  0002a c2 0c 00   ret         12           ; 0000000cH
??0?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIIPBU_Container_base0@1@@Z ENDP ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;       COMDAT ??$construct@IABI@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAIABI@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Ptr$ = 8                                          ; size = 4
_<_Args_0>$ = 12                                        ; size = 4
??$construct@IABI@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAIABI@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned int> >::construct<unsigned int,unsigned int const &>, COMDAT
; _this$ = ecx

; 892  :              {   // construct _Ty(_Types...) at _Ptr

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 893  :              _Mytraits::construct(*this, _Ptr,

  00007 8b 45 0c   mov         eax, DWORD PTR _<_Args_0>$[ebp]
  0000a 50                 push    eax
  0000b e8 00 00 00 00     call    ??$forward@ABI@std@@YAABIABI@Z ; std::forward<unsigned int const &>
  00010 83 c4 04   add         esp, 4
  00013 50                 push    eax
  00014 8b 4d 08   mov         ecx, DWORD PTR __Ptr$[ebp]
  00017 51                 push    ecx
  00018 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  0001b 52                 push    edx
  0001c e8 00 00 00 00     call    ??$construct@IABI@?$allocator_traits@V?$allocator@I@std@@@std@@SAXAAV?$allocator@I@1@PAIABI@Z ; std::allocator_traits<std::allocator<unsigned int> >::construct<unsigned int,unsigned int const &>
  00021 83 c4 0c   add         esp, 12                        ; 0000000cH

; 894  :                  _STD forward<_Types>(_Args)...);
; 895  :              }

  00024 8b e5        mov         esp, ebp
  00026 5d                 pop     ebp
  00027 c2 08 00   ret         8
??$construct@IABI@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAIABI@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned int> >::construct<unsigned int,unsigned int const &>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;       COMDAT ??$?0ABV?$allocator@_N@std@@@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAE@ABV?$allocator@_N@1@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Right$ = 8                                            ; size = 4
??$?0ABV?$allocator@_N@std@@@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAE@ABV?$allocator@_N@1@@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned int> >::_Wrap_alloc<std::allocator<unsigned int> ><std::allocator<bool> const &>, COMDAT
; _this$ = ecx

; 850  :              {   // construct from a related allocator

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 849  :              : _Mybase(_STD forward<_Other>(_Right))

  00007 8b 45 08   mov         eax, DWORD PTR __Right$[ebp]
  0000a 50                 push    eax
  0000b e8 00 00 00 00     call    ??$forward@ABV?$allocator@_N@std@@@std@@YAABV?$allocator@_N@0@ABV10@@Z ; std::forward<std::allocator<bool> const &>
  00010 83 c4 04   add         esp, 4
  00013 50                 push    eax
  00014 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00017 e8 00 00 00 00     call    ??$?0_N@?$allocator@I@std@@QAE@ABV?$allocator@_N@1@@Z ; std::allocator<unsigned int>::allocator<unsigned int><bool>

; 851  :              }

  0001c 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0001f 8b e5        mov         esp, ebp
  00021 5d                 pop     ebp
  00022 c2 04 00   ret         4
??$?0ABV?$allocator@_N@std@@@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAE@ABV?$allocator@_N@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned int> >::_Wrap_alloc<std::allocator<unsigned int> ><std::allocator<bool> const &>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ??$_Copy_memmove@PAIPAI@std@@YAPAIPAI00@Z
_TEXT   SEGMENT
__Last_ch$ = -16                                        ; size = 4
__Count$ = -12                                      ; size = 4
__Dest_ch$ = -8                               ; size = 4
__First_ch$ = -4                                        ; size = 4
__First$ = 8                                            ; size = 4
__Last$ = 12                                            ; size = 4
__Dest$ = 16                                            ; size = 4
??$_Copy_memmove@PAIPAI@std@@YAPAIPAI00@Z PROC      ; std::_Copy_memmove<unsigned int *,unsigned int *>, COMDAT

; 2251 :        {     // implement copy-like function as memmove

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 10   sub         esp, 16                        ; 00000010H

; 2252 :        const char * const _First_ch = reinterpret_cast<const char *>(_First);

  00006 8b 45 08   mov         eax, DWORD PTR __First$[ebp]
  00009 89 45 fc   mov         DWORD PTR __First_ch$[ebp], eax

; 2253 :        const char * const _Last_ch = reinterpret_cast<const char *>(_Last);

  0000c 8b 4d 0c   mov         ecx, DWORD PTR __Last$[ebp]
  0000f 89 4d f0   mov         DWORD PTR __Last_ch$[ebp], ecx

; 2254 :        char * const _Dest_ch = reinterpret_cast<char *>(_Dest);

  00012 8b 55 10   mov         edx, DWORD PTR __Dest$[ebp]
  00015 89 55 f8   mov         DWORD PTR __Dest_ch$[ebp], edx

; 2255 :        const size_t _Count = _Last_ch - _First_ch;

  00018 8b 45 f0   mov         eax, DWORD PTR __Last_ch$[ebp]
  0001b 2b 45 fc   sub         eax, DWORD PTR __First_ch$[ebp]
  0001e 89 45 f4   mov         DWORD PTR __Count$[ebp], eax

; 2256 :        _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021 8b 4d f4   mov         ecx, DWORD PTR __Count$[ebp]
  00024 51                 push    ecx
  00025 8b 55 fc   mov         edx, DWORD PTR __First_ch$[ebp]
  00028 52                 push    edx
  00029 8b 45 f8   mov         eax, DWORD PTR __Dest_ch$[ebp]
  0002c 50                 push    eax
  0002d e8 00 00 00 00     call    _memmove
  00032 83 c4 0c   add         esp, 12                        ; 0000000cH

; 2257 :        return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

  00035 8b 45 f8   mov         eax, DWORD PTR __Dest_ch$[ebp]
  00038 03 45 f4   add         eax, DWORD PTR __Count$[ebp]

; 2258 :        }

  0003b 8b e5        mov         esp, ebp
  0003d 5d                 pop     ebp
  0003e c3                 ret     0
??$_Copy_memmove@PAIPAI@std@@YAPAIPAI00@Z ENDP      ; std::_Copy_memmove<unsigned int *,unsigned int *>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;       COMDAT ??$destroy@I@?$allocator@I@std@@QAEXPAI@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Ptr$ = 8                                          ; size = 4
??$destroy@I@?$allocator@I@std@@QAEXPAI@Z PROC      ; std::allocator<unsigned int>::destroy<unsigned int>, COMDAT
; _this$ = ecx

; 643  :              {   // destroy object at _Ptr

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 644  :              _Ptr->~_Uty();
; 645  :              }

  00007 8b e5        mov         esp, ebp
  00009 5d                 pop     ebp
  0000a c2 04 00   ret         4
??$destroy@I@?$allocator@I@std@@QAEXPAI@Z ENDP      ; std::allocator<unsigned int>::destroy<unsigned int>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;       COMDAT ??$_Uninit_alloc_fill_n1@PAIIV?$allocator@I@std@@U?$integral_constant@_N$0A@@2@@std@@YAXPAIIPBIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U?$integral_constant@_N$0A@@0@@Z
_TEXT   SEGMENT
__Next$ = -20                                     ; size = 4
__$EHRec$ = -16                               ; size = 16
__First$ = 8                                            ; size = 4
__Count$ = 12                                     ; size = 4
__Pval$ = 16                                            ; size = 4
__Al$ = 20                                          ; size = 4
___formal$ = 24                               ; size = 1
??$_Uninit_alloc_fill_n1@PAIIV?$allocator@I@std@@U?$integral_constant@_N$0A@@2@@std@@YAXPAIIPBIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Uninit_alloc_fill_n1<unsigned int *,unsigned int,std::allocator<unsigned int>,std::integral_constant<bool,0> >, COMDAT

; 477  :        {     // copy _Count copies of *_Pval to raw _First, using _Al, no special optimization

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 6a ff        push        -1
  00005 68 00 00 00 00     push    __ehhandler$??$_Uninit_alloc_fill_n1@PAIIV?$allocator@I@std@@U?$integral_constant@_N$0A@@2@@std@@YAXPAIIPBIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U?$integral_constant@_N$0A@@0@@Z
  0000a 64 a1 00 00 00
        00           mov     eax, DWORD PTR fs:0
  00010 50                 push    eax
  00011 51                 push    ecx
  00012 51                 push    ecx
  00013 53                 push    ebx
  00014 56                 push    esi
  00015 57                 push    edi
  00016 a1 00 00 00 00     mov     eax, DWORD PTR ___security_cookie
  0001b 33 c5        xor         eax, ebp
  0001d 50                 push    eax
  0001e 8d 45 f4   lea         eax, DWORD PTR __$EHRec$[ebp+4]
  00021 64 a3 00 00 00
        00           mov     DWORD PTR fs:0, eax
  00027 89 65 f0   mov         DWORD PTR __$EHRec$[ebp], esp

; 478  :        _FwdIt _Next = _First;

  0002a 8b 45 08   mov         eax, DWORD PTR __First$[ebp]
  0002d 89 45 ec   mov         DWORD PTR __Next$[ebp], eax

; 479  :
; 480  :        _TRY_BEGIN

  00030 c7 45 fc 00 00
        00 00          mov         DWORD PTR __$EHRec$[ebp+12], 0

; 481  :        for (; 0 < _Count; --_Count, (void)++_First)

  00037 eb 12        jmp         SHORT $LN4@Uninit_all
$LN2@Uninit_all:
  00039 8b 4d 0c   mov         ecx, DWORD PTR __Count$[ebp]
  0003c 83 e9 01   sub         ecx, 1
  0003f 89 4d 0c   mov         DWORD PTR __Count$[ebp], ecx
  00042 8b 55 08   mov         edx, DWORD PTR __First$[ebp]
  00045 83 c2 04   add         edx, 4
  00048 89 55 08   mov         DWORD PTR __First$[ebp], edx
$LN4@Uninit_all:
  0004b 83 7d 0c 00        cmp   DWORD PTR __Count$[ebp], 0
  0004f 76 12        jbe         SHORT $LN3@Uninit_all

; 482  :              _Al.construct(_First, *_Pval);

  00051 8b 45 10   mov         eax, DWORD PTR __Pval$[ebp]
  00054 50                 push    eax
  00055 8b 4d 08   mov         ecx, DWORD PTR __First$[ebp]
  00058 51                 push    ecx
  00059 8b 4d 14   mov         ecx, DWORD PTR __Al$[ebp]
  0005c e8 00 00 00 00     call    ??$construct@IABI@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAIABI@Z ; std::_Wrap_alloc<std::allocator<unsigned int> >::construct<unsigned int,unsigned int const &>
  00061 eb d6        jmp         SHORT $LN2@Uninit_all
$LN3@Uninit_all:
  00063 eb 30        jmp         SHORT $LN10@Uninit_all
__catch$??$_Uninit_alloc_fill_n1@PAIIV?$allocator@I@std@@U?$integral_constant@_N$0A@@2@@std@@YAXPAIIPBIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U?$integral_constant@_N$0A@@0@@Z$0:

; 483  :        _CATCH_ALL
; 484  :        for (; _Next != _First; ++_Next)

  00065 eb 09        jmp         SHORT $LN7@Uninit_all
$LN5@Uninit_all:
  00067 8b 55 ec   mov         edx, DWORD PTR __Next$[ebp]
  0006a 83 c2 04   add         edx, 4
  0006d 89 55 ec   mov         DWORD PTR __Next$[ebp], edx
$LN7@Uninit_all:
  00070 8b 45 ec   mov         eax, DWORD PTR __Next$[ebp]
  00073 3b 45 08   cmp         eax, DWORD PTR __First$[ebp]
  00076 74 0e        je  SHORT $LN6@Uninit_all

; 485  :              _Al.destroy(_Next);

  00078 8b 4d ec   mov         ecx, DWORD PTR __Next$[ebp]
  0007b 51                 push    ecx
  0007c 8b 4d 14   mov         ecx, DWORD PTR __Al$[ebp]
  0007f e8 00 00 00 00     call    ??$destroy@I@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAI@Z ; std::_Wrap_alloc<std::allocator<unsigned int> >::destroy<unsigned int>
  00084 eb e1        jmp         SHORT $LN5@Uninit_all
$LN6@Uninit_all:

; 486  :        _RERAISE;

  00086 6a 00        push        0
  00088 6a 00        push        0
  0008a e8 00 00 00 00     call    __CxxThrowException@8

; 487  :        _CATCH_END

  0008f b8 00 00 00 00     mov     eax, $LN13@Uninit_all
  00094 c3                 ret     0
$LN10@Uninit_all:
  00095 c7 45 fc ff ff
        ff ff          mov         DWORD PTR __$EHRec$[ebp+12], -1
  0009c eb 07        jmp         SHORT $LN9@Uninit_all
$LN13@Uninit_all:
  0009e c7 45 fc ff ff
        ff ff          mov         DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_all:

; 488  :        }

  000a5 8b 4d f4   mov         ecx, DWORD PTR __$EHRec$[ebp+4]
  000a8 64 89 0d 00 00
        00 00          mov         DWORD PTR fs:0, ecx
  000af 59                 pop     ecx
  000b0 5f                 pop     edi
  000b1 5e                 pop     esi
  000b2 5b                 pop     ebx
  000b3 8b e5        mov         esp, ebp
  000b5 5d                 pop     ebp
  000b6 c3                 ret     0
_TEXT   ENDS
;       COMDAT text$x
text$x  SEGMENT
__ehhandler$??$_Uninit_alloc_fill_n1@PAIIV?$allocator@I@std@@U?$integral_constant@_N$0A@@2@@std@@YAXPAIIPBIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U?$integral_constant@_N$0A@@0@@Z:
  00000 8b 54 24 08        mov   edx, DWORD PTR [esp+8]
  00004 8d 42 0c   lea         eax, DWORD PTR [edx+12]
  00007 8b 4a e8   mov         ecx, DWORD PTR [edx-24]
  0000a 33 c8        xor         ecx, eax
  0000c e8 00 00 00 00     call    @__security_check_cookie@4
  00011 b8 00 00 00 00     mov     eax, OFFSET __ehfuncinfo$??$_Uninit_alloc_fill_n1@PAIIV?$allocator@I@std@@U?$integral_constant@_N$0A@@2@@std@@YAXPAIIPBIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U?$integral_constant@_N$0A@@0@@Z
  00016 e9 00 00 00 00     jmp     ___CxxFrameHandler3
text$x  ENDS
??$_Uninit_alloc_fill_n1@PAIIV?$allocator@I@std@@U?$integral_constant@_N$0A@@2@@std@@YAXPAIIPBIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Uninit_alloc_fill_n1<unsigned int *,unsigned int,std::allocator<unsigned int>,std::integral_constant<bool,0> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ??$_Fill_memset_is_safe@PAII@std@@YA?AU?$integral_constant@_N$0A@@0@ABQAIABI@Z
_TEXT   SEGMENT
$T1 = -1                                                ; size = 1
___formal$ = 8                                      ; size = 4
___formal$ = 12                               ; size = 4
??$_Fill_memset_is_safe@PAII@std@@YA?AU?$integral_constant@_N$0A@@0@ABQAIABI@Z PROC ; std::_Fill_memset_is_safe<unsigned int *,unsigned int>, COMDAT

; 2746 :        {     // type deduction for _Fill_memset_is_safe_helper

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx

; 2747 :        return {};

  00004 33 c0        xor         eax, eax
  00006 88 45 ff   mov         BYTE PTR $T1[ebp], al
  00009 8a 45 ff   mov         al, BYTE PTR $T1[ebp]

; 2748 :        }

  0000c 8b e5        mov         esp, ebp
  0000e 5d                 pop     ebp
  0000f c3                 ret     0
??$_Fill_memset_is_safe@PAII@std@@YA?AU?$integral_constant@_N$0A@@0@ABQAIABI@Z ENDP ; std::_Fill_memset_is_safe<unsigned int *,unsigned int>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;       COMDAT ??$_Addressof@$$CBI@std@@YAPBIABIU?$integral_constant@_N$0A@@0@@Z
_TEXT   SEGMENT
__Val$ = 8                                          ; size = 4
___formal$ = 12                               ; size = 1
??$_Addressof@$$CBI@std@@YAPBIABIU?$integral_constant@_N$0A@@0@@Z PROC ; std::_Addressof<unsigned int const >, COMDAT

; 707  :        {     // return address of object _Val

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 708  :        return (reinterpret_cast<_Ty *>(

  00003 8b 45 08   mov         eax, DWORD PTR __Val$[ebp]

; 709  :              &const_cast<char&>(
; 710  :              reinterpret_cast<const volatile char&>(_Val))));
; 711  :        }

  00006 5d                 pop     ebp
  00007 c3                 ret     0
??$_Addressof@$$CBI@std@@YAPBIABIU?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Addressof<unsigned int const >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ??$?0ABV?$allocator@_N@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@_N@1@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
___formal$ = 8                                      ; size = 1
__Val1$ = 12                                            ; size = 4
??$?0ABV?$allocator@_N@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@_N@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned int> >,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned int> >,std::_Vector_val<std::_Simple_types<unsigned int> >,1><std::allocator<bool> const &>, COMDAT
; _this$ = ecx

; 288  :              {   // construct from forwarded values

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 286  :              : _Ty1(_STD forward<_Other1>(_Val1)),

  00007 8b 45 0c   mov         eax, DWORD PTR __Val1$[ebp]
  0000a 50                 push    eax
  0000b e8 00 00 00 00     call    ??$forward@ABV?$allocator@_N@std@@@std@@YAABV?$allocator@_N@0@ABV10@@Z ; std::forward<std::allocator<bool> const &>
  00010 83 c4 04   add         esp, 4
  00013 50                 push    eax
  00014 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00017 e8 00 00 00 00     call    ??$?0ABV?$allocator@_N@std@@@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAE@ABV?$allocator@_N@1@@Z ; std::_Wrap_alloc<std::allocator<unsigned int> >::_Wrap_alloc<std::allocator<unsigned int> ><std::allocator<bool> const &>

; 287  :                  _Myval2(_STD forward<_Other2>(_Val2)...)

  0001c 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001f e8 00 00 00 00     call    ??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<unsigned int> >::_Vector_val<std::_Simple_types<unsigned int> >

; 289  :              }

  00024 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00027 8b e5        mov         esp, ebp
  00029 5d                 pop     ebp
  0002a c2 08 00   ret         8
??$?0ABV?$allocator@_N@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@_N@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned int> >,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned int> >,std::_Vector_val<std::_Simple_types<unsigned int> >,1><std::allocator<bool> const &>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;       COMDAT ??$forward@ABV?$allocator@_N@std@@@std@@YAABV?$allocator@_N@0@ABV10@@Z
_TEXT   SEGMENT
__Arg$ = 8                                          ; size = 4
??$forward@ABV?$allocator@_N@std@@@std@@YAABV?$allocator@_N@0@ABV10@@Z PROC ; std::forward<std::allocator<bool> const &>, COMDAT

; 1298 :        {     // forward an lvalue as either an lvalue or an rvalue

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 1299 :        return (static_cast<_Ty&&>(_Arg));

  00003 8b 45 08   mov         eax, DWORD PTR __Arg$[ebp]

; 1300 :        }

  00006 5d                 pop     ebp
  00007 c3                 ret     0
??$forward@ABV?$allocator@_N@std@@@std@@YAABV?$allocator@_N@0@ABV10@@Z ENDP ; std::forward<std::allocator<bool> const &>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ??$_Move_unchecked1@PAIPAI@std@@YAPAIPAI00U_Trivially_copyable_ptr_iterator_tag@0@@Z
_TEXT   SEGMENT
__First$ = 8                                            ; size = 4
__Last$ = 12                                            ; size = 4
__Dest$ = 16                                            ; size = 4
___formal$ = 20                               ; size = 1
??$_Move_unchecked1@PAIPAI@std@@YAPAIPAI00U_Trivially_copyable_ptr_iterator_tag@0@@Z PROC ; std::_Move_unchecked1<unsigned int *,unsigned int *>, COMDAT

; 2578 :        {     // move [_First, _Last) to [_Dest, ...), memmove optimization

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 2579 :        return (_Copy_memmove(_First, _Last, _Dest));

  00003 8b 45 10   mov         eax, DWORD PTR __Dest$[ebp]
  00006 50                 push    eax
  00007 8b 4d 0c   mov         ecx, DWORD PTR __Last$[ebp]
  0000a 51                 push    ecx
  0000b 8b 55 08   mov         edx, DWORD PTR __First$[ebp]
  0000e 52                 push    edx
  0000f e8 00 00 00 00     call    ??$_Copy_memmove@PAIPAI@std@@YAPAIPAI00@Z ; std::_Copy_memmove<unsigned int *,unsigned int *>
  00014 83 c4 0c   add         esp, 12                        ; 0000000cH

; 2580 :        }

  00017 5d                 pop     ebp
  00018 c3                 ret     0
??$_Move_unchecked1@PAIPAI@std@@YAPAIPAI00U_Trivially_copyable_ptr_iterator_tag@0@@Z ENDP ; std::_Move_unchecked1<unsigned int *,unsigned int *>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ??$_Ptr_move_cat@II@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAI0@Z
_TEXT   SEGMENT
___$ReturnUdt$ = 8                                  ; size = 4
___formal$ = 12                               ; size = 4
___formal$ = 16                               ; size = 4
??$_Ptr_move_cat@II@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAI0@Z PROC ; std::_Ptr_move_cat<unsigned int,unsigned int>, COMDAT

; 725  :        {     // return pointer move optimization category for pointers

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 726  :        return {};

  00003 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]

; 727  :        }

  00006 5d                 pop     ebp
  00007 c3                 ret     0
??$_Ptr_move_cat@II@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAI0@Z ENDP ; std::_Ptr_move_cat<unsigned int,unsigned int>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;       COMDAT ??$destroy@I@?$allocator_traits@V?$allocator@I@std@@@std@@SAXAAV?$allocator@I@1@PAI@Z
_TEXT   SEGMENT
__Al$ = 8                                         ; size = 4
__Ptr$ = 12                                   ; size = 4
??$destroy@I@?$allocator_traits@V?$allocator@I@std@@@std@@SAXAAV?$allocator@I@1@PAI@Z PROC ; std::allocator_traits<std::allocator<unsigned int> >::destroy<unsigned int>, COMDAT

; 761  :              {   // destroy object at _Ptr

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 762  :              _Al.destroy(_Ptr);

  00003 8b 45 0c   mov         eax, DWORD PTR __Ptr$[ebp]
  00006 50                 push    eax
  00007 8b 4d 08   mov         ecx, DWORD PTR __Al$[ebp]
  0000a e8 00 00 00 00     call    ??$destroy@I@?$allocator@I@std@@QAEXPAI@Z ; std::allocator<unsigned int>::destroy<unsigned int>

; 763  :              }

  0000f 5d                 pop     ebp
  00010 c3                 ret     0
??$destroy@I@?$allocator_traits@V?$allocator@I@std@@@std@@SAXAAV?$allocator@I@1@PAI@Z ENDP ; std::allocator_traits<std::allocator<unsigned int> >::destroy<unsigned int>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;       COMDAT ??$_Addressof@I@std@@YAPAIAAIU?$integral_constant@_N$0A@@0@@Z
_TEXT   SEGMENT
__Val$ = 8                                          ; size = 4
___formal$ = 12                               ; size = 1
??$_Addressof@I@std@@YAPAIAAIU?$integral_constant@_N$0A@@0@@Z PROC ; std::_Addressof<unsigned int>, COMDAT

; 707  :        {     // return address of object _Val

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 708  :        return (reinterpret_cast<_Ty *>(

  00003 8b 45 08   mov         eax, DWORD PTR __Val$[ebp]

; 709  :              &const_cast<char&>(
; 710  :              reinterpret_cast<const volatile char&>(_Val))));
; 711  :        }

  00006 5d                 pop     ebp
  00007 c3                 ret     0
??$_Addressof@I@std@@YAPAIAAIU?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Addressof<unsigned int>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;       COMDAT ??$_Uninitialized_fill_n@PAIIU?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAXPAIIPBIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z
_TEXT   SEGMENT
$T1 = -1                                                ; size = 1
__First$ = 8                                            ; size = 4
__Count$ = 12                                     ; size = 4
__Pval$ = 16                                            ; size = 4
__Al$ = 20                                          ; size = 4
??$_Uninitialized_fill_n@PAIIU?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAXPAIIPBIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z PROC ; std::_Uninitialized_fill_n<unsigned int *,unsigned int,std::_Wrap_alloc<std::allocator<unsigned int> > >, COMDAT

; 505  :        {     // copy _Count copies of *_Pval to raw _First, using _Al

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx

; 506  :        _Uninit_alloc_fill_n1(_First, _Count, _Pval, _Al, _Fill_memset_is_safe(_First, *_Pval));

  00004 8b 45 10   mov         eax, DWORD PTR __Pval$[ebp]
  00007 50                 push    eax
  00008 8d 4d 08   lea         ecx, DWORD PTR __First$[ebp]
  0000b 51                 push    ecx
  0000c e8 00 00 00 00     call    ??$_Fill_memset_is_safe@PAII@std@@YA?AU?$integral_constant@_N$0A@@0@ABQAIABI@Z ; std::_Fill_memset_is_safe<unsigned int *,unsigned int>
  00011 83 c4 08   add         esp, 8
  00014 88 45 ff   mov         BYTE PTR $T1[ebp], al
  00017 0f b6 55 ff        movzx         edx, BYTE PTR $T1[ebp]
  0001b 52                 push    edx
  0001c 8b 45 14   mov         eax, DWORD PTR __Al$[ebp]
  0001f 50                 push    eax
  00020 8b 4d 10   mov         ecx, DWORD PTR __Pval$[ebp]
  00023 51                 push    ecx
  00024 8b 55 0c   mov         edx, DWORD PTR __Count$[ebp]
  00027 52                 push    edx
  00028 8b 45 08   mov         eax, DWORD PTR __First$[ebp]
  0002b 50                 push    eax
  0002c e8 00 00 00 00     call    ??$_Uninit_alloc_fill_n1@PAIIV?$allocator@I@std@@U?$integral_constant@_N$0A@@2@@std@@YAXPAIIPBIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninit_alloc_fill_n1<unsigned int *,unsigned int,std::allocator<unsigned int>,std::integral_constant<bool,0> >
  00031 83 c4 14   add         esp, 20                        ; 00000014H

; 507  :        }

  00034 8b e5        mov         esp, ebp
  00036 5d                 pop     ebp
  00037 c3                 ret     0
??$_Uninitialized_fill_n@PAIIU?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAXPAIIPBIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z ENDP ; std::_Uninitialized_fill_n<unsigned int *,unsigned int,std::_Wrap_alloc<std::allocator<unsigned int> > >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;       COMDAT ??$addressof@$$CBI@std@@YAPBIABI@Z
_TEXT   SEGMENT
$T1 = -1                                                ; size = 1
__Val$ = 8                                          ; size = 4
??$addressof@$$CBI@std@@YAPBIABI@Z PROC       ; std::addressof<unsigned int const >, COMDAT

; 715  :        {     // return address of _Val

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx

; 716  :        return (_Addressof(_Val, is_function<_Ty>()));

  00004 0f b6 45 ff        movzx         eax, BYTE PTR $T1[ebp]
  00008 50                 push    eax
  00009 8b 4d 08   mov         ecx, DWORD PTR __Val$[ebp]
  0000c 51                 push    ecx
  0000d e8 00 00 00 00     call    ??$_Addressof@$$CBI@std@@YAPBIABIU?$integral_constant@_N$0A@@0@@Z ; std::_Addressof<unsigned int const >
  00012 83 c4 08   add         esp, 8

; 717  :        }

  00015 8b e5        mov         esp, ebp
  00017 5d                 pop     ebp
  00018 c3                 ret     0
??$addressof@$$CBI@std@@YAPBIABI@Z ENDP       ; std::addressof<unsigned int const >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??$?0ABV?$allocator@_N@std@@@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAE@ABV?$allocator@_N@1@@Z
_TEXT   SEGMENT
_this$ = -8                                   ; size = 4
$T1 = -1                                                ; size = 1
__Al$ = 8                                         ; size = 4
??$?0ABV?$allocator@_N@std@@@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAE@ABV?$allocator@_N@1@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > ><std::allocator<bool> const &>, COMDAT
; _this$ = ecx

; 521  :              {   // construct allocator from _Al

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d f8   mov         DWORD PTR _this$[ebp], ecx

; 519  :              : _Mypair(_One_then_variadic_args_t(),

  00009 8b 45 08   mov         eax, DWORD PTR __Al$[ebp]
  0000c 50                 push    eax
  0000d e8 00 00 00 00     call    ??$forward@ABV?$allocator@_N@std@@@std@@YAABV?$allocator@_N@0@ABV10@@Z ; std::forward<std::allocator<bool> const &>
  00012 83 c4 04   add         esp, 4
  00015 50                 push    eax
  00016 0f b6 4d ff        movzx         ecx, BYTE PTR $T1[ebp]
  0001a 51                 push    ecx
  0001b 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  0001e e8 00 00 00 00     call    ??$?0ABV?$allocator@_N@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@_N@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned int> >,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned int> >,std::_Vector_val<std::_Simple_types<unsigned int> >,1><std::allocator<bool> const &>

; 522  :              }

  00023 8b 45 f8   mov         eax, DWORD PTR _this$[ebp]
  00026 8b e5        mov         esp, ebp
  00028 5d                 pop     ebp
  00029 c2 04 00   ret         4
??$?0ABV?$allocator@_N@std@@@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAE@ABV?$allocator@_N@1@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > ><std::allocator<bool> const &>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ??$_Move_unchecked@PAIPAI@std@@YAPAIPAI00@Z
_TEXT   SEGMENT
$T1 = -2                                                ; size = 1
$T2 = -1                                                ; size = 1
__First$ = 8                                            ; size = 4
__Last$ = 12                                            ; size = 4
__Dest$ = 16                                            ; size = 4
??$_Move_unchecked@PAIPAI@std@@YAPAIPAI00@Z PROC        ; std::_Move_unchecked<unsigned int *,unsigned int *>, COMDAT

; 2586 :        {     // move [_First, _Last) to [_Dest, ...), choose optimization

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx

; 2587 :        return (_Move_unchecked1(_First, _Last,

  00004 8d 45 10   lea         eax, DWORD PTR __Dest$[ebp]
  00007 50                 push    eax
  00008 8d 4d 08   lea         ecx, DWORD PTR __First$[ebp]
  0000b 51                 push    ecx
  0000c 8d 55 ff   lea         edx, DWORD PTR $T2[ebp]
  0000f 52                 push    edx
  00010 e8 00 00 00 00     call    ??$_Ptr_move_cat@II@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAI0@Z ; std::_Ptr_move_cat<unsigned int,unsigned int>
  00015 83 c4 0c   add         esp, 12                        ; 0000000cH
  00018 0f b6 45 fe        movzx         eax, BYTE PTR $T1[ebp]
  0001c 50                 push    eax
  0001d 8b 4d 10   mov         ecx, DWORD PTR __Dest$[ebp]
  00020 51                 push    ecx
  00021 8b 55 0c   mov         edx, DWORD PTR __Last$[ebp]
  00024 52                 push    edx
  00025 8b 45 08   mov         eax, DWORD PTR __First$[ebp]
  00028 50                 push    eax
  00029 e8 00 00 00 00     call    ??$_Move_unchecked1@PAIPAI@std@@YAPAIPAI00U_Trivially_copyable_ptr_iterator_tag@0@@Z ; std::_Move_unchecked1<unsigned int *,unsigned int *>
  0002e 83 c4 10   add         esp, 16                        ; 00000010H

; 2588 :              _Dest, _Ptr_move_cat(_First, _Dest)));
; 2589 :        }

  00031 8b e5        mov         esp, ebp
  00033 5d                 pop     ebp
  00034 c3                 ret     0
??$_Move_unchecked@PAIPAI@std@@YAPAIPAI00@Z ENDP        ; std::_Move_unchecked<unsigned int *,unsigned int *>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT   SEGMENT
__Tmp$ = -8                                   ; size = 4
_this$ = -4                                   ; size = 4
___$ReturnUdt$ = 8                                  ; size = 4
__Off$ = 12                                   ; size = 4
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+, COMDAT
; _this$ = ecx

; 366  :              {   // return this + integer

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 367  :              _Myiter _Tmp = *this;

  00009 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000c 8b 08        mov         ecx, DWORD PTR [eax]
  0000e 89 4d f8   mov         DWORD PTR __Tmp$[ebp], ecx

; 368  :              return (_Tmp += _Off);

  00011 8b 55 0c   mov         edx, DWORD PTR __Off$[ebp]
  00014 52                 push    edx
  00015 8d 4d f8   lea         ecx, DWORD PTR __Tmp$[ebp]
  00018 e8 00 00 00 00     call    ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+=
  0001d 8b 00        mov         eax, DWORD PTR [eax]
  0001f 8b 4d 08   mov         ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00022 89 01        mov         DWORD PTR [ecx], eax
  00024 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]

; 369  :              }

  00027 8b e5        mov         esp, ebp
  00029 5d                 pop     ebp
  0002a c2 08 00   ret         8
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Off$ = 8                                          ; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+=, COMDAT
; _this$ = ecx

; 360  :              {   // increment by integer

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 361  :              *(_Mybase *)this += _Off;

  00007 8b 45 08   mov         eax, DWORD PTR __Off$[ebp]
  0000a 50                 push    eax
  0000b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000e e8 00 00 00 00     call    ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+=

; 362  :              return (*this);

  00013 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]

; 363  :              }

  00016 8b e5        mov         esp, ebp
  00018 5d                 pop     ebp
  00019 c2 04 00   ret         4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+=
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base0@1@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Parg$ = 8                                   ; size = 4
__Pvector$ = 12                               ; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >, COMDAT
; _this$ = ecx

; 307  :              {   // construct with pointer _Parg

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 306  :              : _Mybase(_Parg, _Pvector)

  00007 8b 45 0c   mov         eax, DWORD PTR __Pvector$[ebp]
  0000a 50                 push    eax
  0000b 8b 4d 08   mov         ecx, DWORD PTR __Parg$[ebp]
  0000e 51                 push    ecx
  0000f 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00012 e8 00 00 00 00     call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >

; 308  :              }

  00017 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0001a 8b e5        mov         esp, ebp
  0001c 5d                 pop     ebp
  0001d c2 08 00   ret         8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBEXABV12@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
___formal$ = 8                                      ; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Compat, COMDAT
; _this$ = ecx

; 255  :              {   // test for compatible iterator pair

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 256  :              }

  00007 8b e5        mov         esp, ebp
  00009 5d                 pop     ebp
  0000a c2 04 00   ret         4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Compat
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT   SEGMENT
_this$ = -8                                   ; size = 4
tv69 = -4                                         ; size = 4
__Right$ = 8                                            ; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator!=, COMDAT
; _this$ = ecx

; 212  :              {   // test for iterator inequality

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d f8   mov         DWORD PTR _this$[ebp], ecx

; 213  :              return (!(*this == _Right));

  00009 8b 45 08   mov         eax, DWORD PTR __Right$[ebp]
  0000c 50                 push    eax
  0000d 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00010 e8 00 00 00 00     call    ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator==
  00015 0f b6 c8   movzx       ecx, al
  00018 85 c9        test        ecx, ecx
  0001a 75 09        jne         SHORT $LN3@operator
  0001c c7 45 fc 01 00
        00 00          mov         DWORD PTR tv69[ebp], 1
  00023 eb 07        jmp         SHORT $LN4@operator
$LN3@operator:
  00025 c7 45 fc 00 00
        00 00          mov         DWORD PTR tv69[ebp], 0
$LN4@operator:
  0002c 8a 45 fc   mov         al, BYTE PTR tv69[ebp]

; 214  :              }

  0002f 8b e5        mov         esp, ebp
  00031 5d                 pop     ebp
  00032 c2 04 00   ret         4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator!=
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT   SEGMENT
tv69 = -8                                         ; size = 4
_this$ = -4                                   ; size = 4
__Right$ = 8                                            ; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator==, COMDAT
; _this$ = ecx

; 206  :              {   // test for iterator equality

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 207  :              _Compat(_Right);

  00009 8b 45 08   mov         eax, DWORD PTR __Right$[ebp]
  0000c 50                 push    eax
  0000d 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00010 e8 00 00 00 00     call    ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Compat

; 208  :              return (_Ptr == _Right._Ptr);

  00015 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00018 8b 55 08   mov         edx, DWORD PTR __Right$[ebp]
  0001b 8b 01        mov         eax, DWORD PTR [ecx]
  0001d 3b 02        cmp         eax, DWORD PTR [edx]
  0001f 75 09        jne         SHORT $LN3@operator
  00021 c7 45 f8 01 00
        00 00          mov         DWORD PTR tv69[ebp], 1
  00028 eb 07        jmp         SHORT $LN4@operator
$LN3@operator:
  0002a c7 45 f8 00 00
        00 00          mov         DWORD PTR tv69[ebp], 0
$LN4@operator:
  00031 8a 45 f8   mov         al, BYTE PTR tv69[ebp]

; 209  :              }

  00034 8b e5        mov         esp, ebp
  00036 5d                 pop     ebp
  00037 c2 04 00   ret         4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator==
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Off$ = 8                                          ; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+=, COMDAT
; _this$ = ecx

; 153  :              {   // increment by integer

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  :              if (_Off != 0 && (this->_Getcont() == 0
; 156  :                  || _Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  :                  || ((_Myvec *)this->_Getcont())->_Mylast < _Ptr + _Off))
; 158  :                  {
; 159  :                  _DEBUG_ERROR("vector iterator + offset out of range");
; 160  :                  _SCL_SECURE_OUT_OF_RANGE;
; 161  :                  }
; 162  :
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  :              if (_Off != 0)
; 165  :                  {
; 166  :                  _SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 167  :                  _SCL_SECURE_VALIDATE_RANGE(
; 168  :                          ((_Myvec *)this->_Getcont())->_Myfirst <= _Ptr + _Off
; 169  :                          && _Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 170  :                  }
; 171  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 172  :
; 173  :              _Ptr += _Off;

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a 8b 08        mov         ecx, DWORD PTR [eax]
  0000c 8b 55 08   mov         edx, DWORD PTR __Off$[ebp]
  0000f 8d 04 91   lea         eax, DWORD PTR [ecx+edx*4]
  00012 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00015 89 01        mov         DWORD PTR [ecx], eax

; 174  :              return (*this);

  00017 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]

; 175  :              }

  0001a 8b e5        mov         esp, ebp
  0001c 5d                 pop     ebp
  0001d c2 04 00   ret         4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+=
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base0@1@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Parg$ = 8                                   ; size = 4
__Pvector$ = 12                               ; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >, COMDAT
; _this$ = ecx

; 47   :              {   // construct with pointer _Parg

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 46   :              : _Ptr(_Parg)

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a 8b 4d 08   mov         ecx, DWORD PTR __Parg$[ebp]
  0000d 89 08        mov         DWORD PTR [eax], ecx

; 48   :              this->_Adopt(_Pvector);

  0000f 8b 55 0c   mov         edx, DWORD PTR __Pvector$[ebp]
  00012 52                 push    edx
  00013 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00016 e8 00 00 00 00     call    ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 49   :              }

  0001b 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0001e 8b e5        mov         esp, ebp
  00020 5d                 pop     ebp
  00021 c2 08 00   ret         8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;       COMDAT ??$destroy@I@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAI@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Ptr$ = 8                                          ; size = 4
??$destroy@I@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAI@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned int> >::destroy<unsigned int>, COMDAT
; _this$ = ecx

; 900  :              {   // destroy object at _Ptr

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 901  :              _Mytraits::destroy(*this, _Ptr);

  00007 8b 45 08   mov         eax, DWORD PTR __Ptr$[ebp]
  0000a 50                 push    eax
  0000b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000e 51                 push    ecx
  0000f e8 00 00 00 00     call    ??$destroy@I@?$allocator_traits@V?$allocator@I@std@@@std@@SAXAAV?$allocator@I@1@PAI@Z ; std::allocator_traits<std::allocator<unsigned int> >::destroy<unsigned int>
  00014 83 c4 08   add         esp, 8

; 902  :              }

  00017 8b e5        mov         esp, ebp
  00019 5d                 pop     ebp
  0001a c2 04 00   ret         4
??$destroy@I@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAI@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned int> >::destroy<unsigned int>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;       COMDAT ??$addressof@I@std@@YAPAIAAI@Z
_TEXT   SEGMENT
$T1 = -1                                                ; size = 1
__Val$ = 8                                          ; size = 4
??$addressof@I@std@@YAPAIAAI@Z PROC           ; std::addressof<unsigned int>, COMDAT

; 715  :        {     // return address of _Val

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx

; 716  :        return (_Addressof(_Val, is_function<_Ty>()));

  00004 0f b6 45 ff        movzx         eax, BYTE PTR $T1[ebp]
  00008 50                 push    eax
  00009 8b 4d 08   mov         ecx, DWORD PTR __Val$[ebp]
  0000c 51                 push    ecx
  0000d e8 00 00 00 00     call    ??$_Addressof@I@std@@YAPAIAAIU?$integral_constant@_N$0A@@0@@Z ; std::_Addressof<unsigned int>
  00012 83 c4 08   add         esp, 8

; 717  :        }

  00015 8b e5        mov         esp, ebp
  00017 5d                 pop     ebp
  00018 c3                 ret     0
??$addressof@I@std@@YAPAIAAI@Z ENDP           ; std::addressof<unsigned int>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;       COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT   SEGMENT
_this$ = -12                                            ; size = 4
tv73 = -8                                         ; size = 4
$T1 = -4                                                ; size = 4
__Ptr$ = 8                                          ; size = 4
_<_Args_0>$ = 12                                        ; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 636  :              {   // construct _Objty(_Types...) at _Ptr

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 0c   sub         esp, 12                        ; 0000000cH
  00006 89 4d f4   mov         DWORD PTR _this$[ebp], ecx

; 637  :              ::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00009 8b 45 08   mov         eax, DWORD PTR __Ptr$[ebp]
  0000c 50                 push    eax
  0000d 6a 04        push        4
  0000f e8 00 00 00 00     call    ??2@YAPAXIPAX@Z          ; operator new
  00014 83 c4 08   add         esp, 8
  00017 89 45 fc   mov         DWORD PTR $T1[ebp], eax
  0001a 83 7d fc 00        cmp   DWORD PTR $T1[ebp], 0
  0001e 74 1b        je  SHORT $LN3@construct
  00020 8b 4d 0c   mov         ecx, DWORD PTR _<_Args_0>$[ebp]
  00023 51                 push    ecx
  00024 e8 00 00 00 00     call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>
  00029 83 c4 04   add         esp, 4
  0002c 8b 55 fc   mov         edx, DWORD PTR $T1[ebp]
  0002f 8b 00        mov         eax, DWORD PTR [eax]
  00031 89 02        mov         DWORD PTR [edx], eax
  00033 8b 4d fc   mov         ecx, DWORD PTR $T1[ebp]
  00036 89 4d f8   mov         DWORD PTR tv73[ebp], ecx
  00039 eb 07        jmp         SHORT $LN1@construct
$LN3@construct:
  0003b c7 45 f8 00 00
        00 00          mov         DWORD PTR tv73[ebp], 0
$LN1@construct:

; 638  :              }

  00042 8b e5        mov         esp, ebp
  00044 5d                 pop     ebp
  00045 c2 08 00   ret         8
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;       COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Ptr$ = 8                                          ; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC      ; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 643  :              {   // destroy object at _Ptr

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 644  :              _Ptr->~_Uty();
; 645  :              }

  00007 8b e5        mov         esp, ebp
  00009 5d                 pop     ebp
  0000a c2 04 00   ret         4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP      ; std::allocator<char>::destroy<char *>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ??$_Iter_cat@PAD@std@@YA?AUrandom_access_iterator_tag@0@ABQAD@Z
_TEXT   SEGMENT
___$ReturnUdt$ = 8                                  ; size = 4
___formal$ = 12                               ; size = 4
??$_Iter_cat@PAD@std@@YA?AUrandom_access_iterator_tag@0@ABQAD@Z PROC ; std::_Iter_cat<char *>, COMDAT

; 639  :        {     // return category from iterator argument

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 640  :        return {};

  00003 33 c0        xor         eax, eax
  00005 8b 4d 08   mov         ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00008 88 01        mov         BYTE PTR [ecx], al
  0000a 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]

; 641  :        }

  0000d 5d                 pop     ebp
  0000e c3                 ret     0
??$_Iter_cat@PAD@std@@YA?AUrandom_access_iterator_tag@0@ABQAD@Z ENDP ; std::_Iter_cat<char *>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ??$_Unchecked@PAD@std@@YAPADPAD@Z
_TEXT   SEGMENT
__Src$ = 8                                          ; size = 4
??$_Unchecked@PAD@std@@YAPADPAD@Z PROC              ; std::_Unchecked<char *>, COMDAT

; 438  :        {     // construct unchecked from checked, generic

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 439  :        return (_Src);

  00003 8b 45 08   mov         eax, DWORD PTR __Src$[ebp]

; 440  :        }

  00006 5d                 pop     ebp
  00007 c3                 ret     0
??$_Unchecked@PAD@std@@YAPADPAD@Z ENDP              ; std::_Unchecked<char *>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\locale
;       COMDAT ??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ
text$di SEGMENT
??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ PROC     ; `dynamic initializer for 'std::collate<char>::id'', COMDAT

; 134  :        __PURE_APPDOMAIN_GLOBAL locale::id collate<_Elem>::id;

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 6a 00        push        0
  00005 b9 00 00 00 00     mov     ecx, OFFSET ?id@?$collate@D@std@@2V0locale@2@A ; std::collate<char>::id
  0000a e8 00 00 00 00     call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id
  0000f 5d                 pop     ebp
  00010 c3                 ret     0
??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ ENDP     ; `dynamic initializer for 'std::collate<char>::id''
text$di ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;       COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAXPAI0AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z
_TEXT   SEGMENT
__First$ = 8                                            ; size = 4
__Last$ = 12                                            ; size = 4
__Al$ = 16                                          ; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAXPAI0AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<unsigned int> > >, COMDAT

; 163  :        {     // destroy [_First, _Last)

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 164  :        for (; _First != _Last; ++_First)

  00003 eb 09        jmp         SHORT $LN4@Destroy_ra
$LN2@Destroy_ra:
  00005 8b 45 08   mov         eax, DWORD PTR __First$[ebp]
  00008 83 c0 04   add         eax, 4
  0000b 89 45 08   mov         DWORD PTR __First$[ebp], eax
$LN4@Destroy_ra:
  0000e 8b 4d 08   mov         ecx, DWORD PTR __First$[ebp]
  00011 3b 4d 0c   cmp         ecx, DWORD PTR __Last$[ebp]
  00014 74 17        je  SHORT $LN1@Destroy_ra

; 165  :              _Al.destroy(_STD addressof(*_First));

  00016 8b 55 08   mov         edx, DWORD PTR __First$[ebp]
  00019 52                 push    edx
  0001a e8 00 00 00 00     call    ??$addressof@I@std@@YAPAIAAI@Z ; std::addressof<unsigned int>
  0001f 83 c4 04   add         esp, 4
  00022 50                 push    eax
  00023 8b 4d 10   mov         ecx, DWORD PTR __Al$[ebp]
  00026 e8 00 00 00 00     call    ??$destroy@I@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAI@Z ; std::_Wrap_alloc<std::allocator<unsigned int> >::destroy<unsigned int>
  0002b eb d8        jmp         SHORT $LN2@Destroy_ra
$LN1@Destroy_ra:

; 166  :        }

  0002d 5d                 pop     ebp
  0002e c3                 ret     0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAXPAI0AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<unsigned int> > >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;       COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT   SEGMENT
__Al$ = 8                                         ; size = 4
__Ptr$ = 12                                   ; size = 4
_<_Args_0>$ = 16                                        ; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 754  :              {   // construct _Objty(_Types...) at _Ptr

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 755  :              _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  00003 8b 45 10   mov         eax, DWORD PTR _<_Args_0>$[ebp]
  00006 50                 push    eax
  00007 e8 00 00 00 00     call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>
  0000c 83 c4 04   add         esp, 4
  0000f 50                 push    eax
  00010 8b 4d 0c   mov         ecx, DWORD PTR __Ptr$[ebp]
  00013 51                 push    ecx
  00014 8b 4d 08   mov         ecx, DWORD PTR __Al$[ebp]
  00017 e8 00 00 00 00     call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>

; 756  :              }

  0001c 5d                 pop     ebp
  0001d c3                 ret     0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;       COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT   SEGMENT
__Arg$ = 8                                          ; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC             ; std::forward<char * &>, COMDAT

; 1298 :        {     // forward an lvalue as either an lvalue or an rvalue

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 1299 :        return (static_cast<_Ty&&>(_Arg));

  00003 8b 45 08   mov         eax, DWORD PTR __Arg$[ebp]

; 1300 :        }

  00006 5d                 pop     ebp
  00007 c3                 ret     0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP             ; std::forward<char * &>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;       COMDAT ??$_Addressof@D@std@@YAPADAADU?$integral_constant@_N$0A@@0@@Z
_TEXT   SEGMENT
__Val$ = 8                                          ; size = 4
___formal$ = 12                               ; size = 1
??$_Addressof@D@std@@YAPADAADU?$integral_constant@_N$0A@@0@@Z PROC ; std::_Addressof<char>, COMDAT

; 707  :        {     // return address of object _Val

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 708  :        return (reinterpret_cast<_Ty *>(

  00003 8b 45 08   mov         eax, DWORD PTR __Val$[ebp]

; 709  :              &const_cast<char&>(
; 710  :              reinterpret_cast<const volatile char&>(_Val))));
; 711  :        }

  00006 5d                 pop     ebp
  00007 c3                 ret     0
??$_Addressof@D@std@@YAPADAADU?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Addressof<char>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;       COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT   SEGMENT
__Al$ = 8                                         ; size = 4
__Ptr$ = 12                                   ; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 761  :              {   // destroy object at _Ptr

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 762  :              _Al.destroy(_Ptr);

  00003 8b 45 0c   mov         eax, DWORD PTR __Ptr$[ebp]
  00006 50                 push    eax
  00007 8b 4d 08   mov         ecx, DWORD PTR __Al$[ebp]
  0000a e8 00 00 00 00     call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 763  :              }

  0000f 5d                 pop     ebp
  00010 c3                 ret     0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
___formal$ = 8                                      ; size = 1
__Val1$ = 12                                            ; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::_Wrap_alloc<std::allocator<char> > >, COMDAT
; _this$ = ecx

; 288  :              {   // construct from forwarded values

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 286  :              : _Ty1(_STD forward<_Other1>(_Val1)),

  00007 8b 45 0c   mov         eax, DWORD PTR __Val1$[ebp]
  0000a 50                 push    eax
  0000b e8 00 00 00 00     call    ??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ; std::forward<std::_Wrap_alloc<std::allocator<char> > >
  00010 83 c4 04   add         esp, 4
  00013 50                 push    eax
  00014 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00017 e8 00 00 00 00     call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >

; 287  :                  _Myval2(_STD forward<_Other2>(_Val2)...)

  0001c 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001f e8 00 00 00 00     call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >

; 289  :              }

  00024 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00027 8b e5        mov         esp, ebp
  00029 5d                 pop     ebp
  0002a c2 08 00   ret         8
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::_Wrap_alloc<std::allocator<char> > >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;       COMDAT ??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z
_TEXT   SEGMENT
__Arg$ = 8                                          ; size = 4
??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<char> > >, COMDAT

; 1298 :        {     // forward an lvalue as either an lvalue or an rvalue

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 1299 :        return (static_cast<_Ty&&>(_Arg));

  00003 8b 45 08   mov         eax, DWORD PTR __Arg$[ebp]

; 1300 :        }

  00006 5d                 pop     ebp
  00007 c3                 ret     0
??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<char> > >
_TEXT   ENDS
; Function compile flags: /Odtp
;       COMDAT ??1?$_Parser@PBDDV?$regex_traits@D@std@@@std@@QAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??1?$_Parser@PBDDV?$regex_traits@D@std@@@std@@QAE@XZ PROC ; std::_Parser<char const *,char,std::regex_traits<char> >::~_Parser<char const *,char,std::regex_traits<char> >, COMDAT
; _this$ = ecx
  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a 83 c1 14   add         ecx, 20                        ; 00000014H
  0000d e8 00 00 00 00     call    ??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ ; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
  00012 8b e5        mov         esp, ebp
  00014 5d                 pop     ebp
  00015 c3                 ret     0
??1?$_Parser@PBDDV?$regex_traits@D@std@@@std@@QAE@XZ ENDP ; std::_Parser<char const *,char,std::regex_traits<char> >::~_Parser<char const *,char,std::regex_traits<char> >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Get_tmax@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@ABEIXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Get_tmax@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@ABEIXZ PROC ; std::_Builder<char const *,char,std::regex_traits<char> >::_Get_tmax, COMDAT
; _this$ = ecx

; 3998 :        {

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 3999 :        return (static_cast<unsigned int>(_Tmax));

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a 8b 40 14   mov         eax, DWORD PTR [eax+20]

; 4000 :        }

  0000d 8b e5        mov         esp, ebp
  0000f 5d                 pop     ebp
  00010 c3                 ret     0
?_Get_tmax@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@ABEIXZ ENDP ; std::_Builder<char const *,char,std::regex_traits<char> >::_Get_tmax
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Get_bmax@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@ABEIXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Get_bmax@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@ABEIXZ PROC ; std::_Builder<char const *,char,std::regex_traits<char> >::_Get_bmax, COMDAT
; _this$ = ecx

; 3990 :        {

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 3991 :        return (static_cast<unsigned int>(_Bmax));

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a 8b 40 10   mov         eax, DWORD PTR [eax+16]

; 3992 :        }

  0000d 8b e5        mov         esp, ebp
  0000f 5d                 pop     ebp
  00010 c3                 ret     0
?_Get_bmax@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@ABEIXZ ENDP ; std::_Builder<char const *,char,std::regex_traits<char> >::_Get_bmax
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Char_to_elts@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEXPBD0HPAPAU?$_Sequence@D@2@@Z
_TEXT   SEGMENT
_this$ = -16                                            ; size = 4
__Node$1 = -12                                      ; size = 4
tv80 = -8                                         ; size = 4
$T2 = -4                                                ; size = 4
__First$ = 8                                            ; size = 4
__Last$ = 12                                            ; size = 4
__Diff$ = 16                                            ; size = 4
__Cur$ = 20                                   ; size = 4
?_Char_to_elts@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEXPBD0HPAPAU?$_Sequence@D@2@@Z PROC ; std::_Builder<char const *,char,std::regex_traits<char> >::_Char_to_elts, COMDAT
; _this$ = ecx

; 3974 :        {     // add collation element to element sequence

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 10   sub         esp, 16                        ; 00000010H
  00006 89 4d f0   mov         DWORD PTR _this$[ebp], ecx
$LN2@Char_to_el:

; 3975 :        while (*_Cur && (unsigned int)_Diff < (*_Cur)->_Sz)

  00009 8b 45 14   mov         eax, DWORD PTR __Cur$[ebp]
  0000c 83 38 00   cmp         DWORD PTR [eax], 0
  0000f 74 19        je  SHORT $LN3@Char_to_el
  00011 8b 4d 14   mov         ecx, DWORD PTR __Cur$[ebp]
  00014 8b 11        mov         edx, DWORD PTR [ecx]
  00016 8b 45 10   mov         eax, DWORD PTR __Diff$[ebp]
  00019 3b 02        cmp         eax, DWORD PTR [edx]
  0001b 73 0d        jae         SHORT $LN3@Char_to_el

; 3976 :              _Cur = &(*_Cur)->_Next;

  0001d 8b 4d 14   mov         ecx, DWORD PTR __Cur$[ebp]
  00020 8b 11        mov         edx, DWORD PTR [ecx]
  00022 83 c2 10   add         edx, 16                        ; 00000010H
  00025 89 55 14   mov         DWORD PTR __Cur$[ebp], edx
  00028 eb df        jmp         SHORT $LN2@Char_to_el
$LN3@Char_to_el:

; 3977 :        if (!(*_Cur) || (unsigned int)_Diff != (*_Cur)->_Sz)

  0002a 8b 45 14   mov         eax, DWORD PTR __Cur$[ebp]
  0002d 83 38 00   cmp         DWORD PTR [eax], 0
  00030 74 0c        je  SHORT $LN5@Char_to_el
  00032 8b 4d 14   mov         ecx, DWORD PTR __Cur$[ebp]
  00035 8b 11        mov         edx, DWORD PTR [ecx]
  00037 8b 45 10   mov         eax, DWORD PTR __Diff$[ebp]
  0003a 3b 02        cmp         eax, DWORD PTR [edx]
  0003c 74 46        je  SHORT $LN4@Char_to_el
$LN5@Char_to_el:

; 3978 :              {   // add new sequence holding elements of the same length
; 3979 :              _Sequence<_Elem> *_Node = *_Cur;

  0003e 8b 4d 14   mov         ecx, DWORD PTR __Cur$[ebp]
  00041 8b 11        mov         edx, DWORD PTR [ecx]
  00043 89 55 f4   mov         DWORD PTR __Node$1[ebp], edx

; 3980 :              *_Cur = new _Sequence<_Elem>((unsigned int)_Diff);

  00046 6a 14        push        20             ; 00000014H
  00048 e8 00 00 00 00     call    ??2@YAPAXI@Z   ; operator new
  0004d 83 c4 04   add         esp, 4
  00050 89 45 fc   mov         DWORD PTR $T2[ebp], eax
  00053 83 7d fc 00        cmp   DWORD PTR $T2[ebp], 0
  00057 74 11        je  SHORT $LN7@Char_to_el
  00059 8b 45 10   mov         eax, DWORD PTR __Diff$[ebp]
  0005c 50                 push    eax
  0005d 8b 4d fc   mov         ecx, DWORD PTR $T2[ebp]
  00060 e8 00 00 00 00     call    ??0?$_Sequence@D@std@@QAE@I@Z ; std::_Sequence<char>::_Sequence<char>
  00065 89 45 f8   mov         DWORD PTR tv80[ebp], eax
  00068 eb 07        jmp         SHORT $LN8@Char_to_el
$LN7@Char_to_el:
  0006a c7 45 f8 00 00
        00 00          mov         DWORD PTR tv80[ebp], 0
$LN8@Char_to_el:
  00071 8b 4d 14   mov         ecx, DWORD PTR __Cur$[ebp]
  00074 8b 55 f8   mov         edx, DWORD PTR tv80[ebp]
  00077 89 11        mov         DWORD PTR [ecx], edx

; 3981 :              (*_Cur)->_Next = _Node;

  00079 8b 45 14   mov         eax, DWORD PTR __Cur$[ebp]
  0007c 8b 08        mov         ecx, DWORD PTR [eax]
  0007e 8b 55 f4   mov         edx, DWORD PTR __Node$1[ebp]
  00081 89 51 10   mov         DWORD PTR [ecx+16], edx
$LN4@Char_to_el:

; 3982 :              }
; 3983 :        (*_Cur)->_Data._Insert(_First, _Last);

  00084 8b 45 0c   mov         eax, DWORD PTR __Last$[ebp]
  00087 50                 push    eax
  00088 8b 4d 08   mov         ecx, DWORD PTR __First$[ebp]
  0008b 51                 push    ecx
  0008c 8b 55 14   mov         edx, DWORD PTR __Cur$[ebp]
  0008f 8b 0a        mov         ecx, DWORD PTR [edx]
  00091 83 c1 04   add         ecx, 4
  00094 e8 00 00 00 00     call    ??$_Insert@PBD@?$_Buf@D@std@@QAEXPBD0@Z ; std::_Buf<char>::_Insert<char const *>

; 3984 :        }

  00099 8b e5        mov         esp, ebp
  0009b 5d                 pop     ebp
  0009c c2 10 00   ret         16           ; 00000010H
?_Char_to_elts@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEXPBD0HPAPAU?$_Sequence@D@2@@Z ENDP ; std::_Builder<char const *,char,std::regex_traits<char> >::_Char_to_elts
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Add_elts@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEXPAV?$_Node_class@DV?$regex_traits@D@std@@@2@F_N@Z
_TEXT   SEGMENT
_this$ = -20                                            ; size = 4
tv89 = -16                                          ; size = 4
$T1 = -12                                         ; size = 4
__Ch$2 = -8                                   ; size = 4
__Matches$3 = -1                                        ; size = 1
__Node$ = 8                                   ; size = 4
__Cl$ = 12                                          ; size = 2
__Negate$ = 16                                      ; size = 1
?_Add_elts@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEXPAV?$_Node_class@DV?$regex_traits@D@std@@@2@F_N@Z PROC ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_elts, COMDAT
; _this$ = ecx

; 3940 :        {     // add characters in named class to set

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 14   sub         esp, 20                        ; 00000014H
  00006 89 4d ec   mov         DWORD PTR _this$[ebp], ecx

; 3941 :        for (unsigned int _Ch = 0; _Ch < _Bmp_max; ++_Ch)

  00009 c7 45 f8 00 00
        00 00          mov         DWORD PTR __Ch$2[ebp], 0
  00010 eb 09        jmp         SHORT $LN4@Add_elts
$LN2@Add_elts:
  00012 8b 45 f8   mov         eax, DWORD PTR __Ch$2[ebp]
  00015 83 c0 01   add         eax, 1
  00018 89 45 f8   mov         DWORD PTR __Ch$2[ebp], eax
$LN4@Add_elts:
  0001b 81 7d f8 00 01
        00 00          cmp         DWORD PTR __Ch$2[ebp], 256 ; 00000100H
  00022 73 6e        jae         SHORT $LN1@Add_elts

; 3942 :              {   // add elements or their inverse
; 3943 :              bool _Matches = _Traits.isctype(static_cast<_Elem>(_Ch), _Cl);

  00024 0f b7 4d 0c        movzx         ecx, WORD PTR __Cl$[ebp]
  00028 51                 push    ecx
  00029 0f b6 55 f8        movzx         edx, BYTE PTR __Ch$2[ebp]
  0002d 52                 push    edx
  0002e 8b 45 ec   mov         eax, DWORD PTR _this$[ebp]
  00031 8b 48 0c   mov         ecx, DWORD PTR [eax+12]
  00034 e8 00 00 00 00     call    ?isctype@?$_Regex_traits@D@std@@QBE_NDF@Z ; std::_Regex_traits<char>::isctype
  00039 88 45 ff   mov         BYTE PTR __Matches$3[ebp], al

; 3944 :              if (_Matches != _Negate)

  0003c 0f b6 4d ff        movzx         ecx, BYTE PTR __Matches$3[ebp]
  00040 0f b6 55 10        movzx         edx, BYTE PTR __Negate$[ebp]
  00044 3b ca        cmp         ecx, edx
  00046 74 48        je  SHORT $LN5@Add_elts

; 3945 :                  {       // add contents of named class to accelerator table
; 3946 :                  if (!_Node->_Small)

  00048 8b 45 08   mov         eax, DWORD PTR __Node$[ebp]
  0004b 83 78 18 00        cmp   DWORD PTR [eax+24], 0
  0004f 75 30        jne         SHORT $LN6@Add_elts

; 3947 :                          _Node->_Small = new _Bitmap;

  00051 6a 20        push        32             ; 00000020H
  00053 e8 00 00 00 00     call    ??2@YAPAXI@Z   ; operator new
  00058 83 c4 04   add         esp, 4
  0005b 89 45 f4   mov         DWORD PTR $T1[ebp], eax
  0005e 83 7d f4 00        cmp   DWORD PTR $T1[ebp], 0
  00062 74 0d        je  SHORT $LN8@Add_elts
  00064 8b 4d f4   mov         ecx, DWORD PTR $T1[ebp]
  00067 e8 00 00 00 00     call    ??0_Bitmap@std@@QAE@XZ       ; std::_Bitmap::_Bitmap
  0006c 89 45 f0   mov         DWORD PTR tv89[ebp], eax
  0006f eb 07        jmp         SHORT $LN9@Add_elts
$LN8@Add_elts:
  00071 c7 45 f0 00 00
        00 00          mov         DWORD PTR tv89[ebp], 0
$LN9@Add_elts:
  00078 8b 4d 08   mov         ecx, DWORD PTR __Node$[ebp]
  0007b 8b 55 f0   mov         edx, DWORD PTR tv89[ebp]
  0007e 89 51 18   mov         DWORD PTR [ecx+24], edx
$LN6@Add_elts:

; 3948 :                  _Node->_Small->_Mark(_Ch);

  00081 8b 45 f8   mov         eax, DWORD PTR __Ch$2[ebp]
  00084 50                 push    eax
  00085 8b 4d 08   mov         ecx, DWORD PTR __Node$[ebp]
  00088 8b 49 18   mov         ecx, DWORD PTR [ecx+24]
  0008b e8 00 00 00 00     call    ??$_Mark@I@_Bitmap@std@@QAEXI@Z ; std::_Bitmap::_Mark<unsigned int>
$LN5@Add_elts:

; 3949 :                  }
; 3950 :              }

  00090 eb 80        jmp         SHORT $LN2@Add_elts
$LN1@Add_elts:

; 3951 :        }

  00092 8b e5        mov         esp, ebp
  00094 5d                 pop     ebp
  00095 c2 0c 00   ret         12           ; 0000000cH
?_Add_elts@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEXPAV?$_Node_class@DV?$regex_traits@D@std@@@2@F_N@Z ENDP ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_elts
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Add_char_to_array@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEXD@Z
_TEXT   SEGMENT
tv93 = -16                                          ; size = 4
$T1 = -12                                         ; size = 4
__Node$ = -8                                            ; size = 4
_this$ = -4                                   ; size = 4
__Ch$ = 8                                         ; size = 1
?_Add_char_to_array@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEXD@Z PROC ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_char_to_array, COMDAT
; _this$ = ecx

; 3877 :        {     // append character to character array

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 10   sub         esp, 16                        ; 00000010H
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 3878 :        if (_Flags & regex_constants::icase)

  00009 68 00 01 00 00     push    256              ; 00000100H
  0000e 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00011 8b 48 08   mov         ecx, DWORD PTR [eax+8]
  00014 51                 push    ecx
  00015 e8 00 00 00 00     call    ??Iregex_constants@std@@YA?AW4syntax_option_type@01@W4201@0@Z ; std::regex_constants::operator&
  0001a 83 c4 08   add         esp, 8
  0001d 85 c0        test        eax, eax
  0001f 74 13        je  SHORT $LN2@Add_char_t

; 3879 :              _Ch = _Traits.translate_nocase(_Ch);

  00021 0f b6 55 08        movzx         edx, BYTE PTR __Ch$[ebp]
  00025 52                 push    edx
  00026 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00029 8b 48 0c   mov         ecx, DWORD PTR [eax+12]
  0002c e8 00 00 00 00     call    ?translate_nocase@?$_Regex_traits@D@std@@QBEDD@Z ; std::_Regex_traits<char>::translate_nocase
  00031 88 45 08   mov         BYTE PTR __Ch$[ebp], al
$LN2@Add_char_t:

; 3880 :        _Node_class<_Elem, _RxTraits> *_Node =
; 3881 :              (_Node_class<_Elem, _RxTraits> *)_Current;

  00034 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00037 8b 51 04   mov         edx, DWORD PTR [ecx+4]
  0003a 89 55 f8   mov         DWORD PTR __Node$[ebp], edx

; 3882 :        if (!_Node->_Large)

  0003d 8b 45 f8   mov         eax, DWORD PTR __Node$[ebp]
  00040 83 78 1c 00        cmp   DWORD PTR [eax+28], 0
  00044 75 30        jne         SHORT $LN3@Add_char_t

; 3883 :              _Node->_Large = new _Buf<_Elem>;

  00046 6a 0c        push        12             ; 0000000cH
  00048 e8 00 00 00 00     call    ??2@YAPAXI@Z   ; operator new
  0004d 83 c4 04   add         esp, 4
  00050 89 45 f4   mov         DWORD PTR $T1[ebp], eax
  00053 83 7d f4 00        cmp   DWORD PTR $T1[ebp], 0
  00057 74 0d        je  SHORT $LN5@Add_char_t
  00059 8b 4d f4   mov         ecx, DWORD PTR $T1[ebp]
  0005c e8 00 00 00 00     call    ??0?$_Buf@D@std@@QAE@XZ      ; std::_Buf<char>::_Buf<char>
  00061 89 45 f0   mov         DWORD PTR tv93[ebp], eax
  00064 eb 07        jmp         SHORT $LN6@Add_char_t
$LN5@Add_char_t:
  00066 c7 45 f0 00 00
        00 00          mov         DWORD PTR tv93[ebp], 0
$LN6@Add_char_t:
  0006d 8b 4d f8   mov         ecx, DWORD PTR __Node$[ebp]
  00070 8b 55 f0   mov         edx, DWORD PTR tv93[ebp]
  00073 89 51 1c   mov         DWORD PTR [ecx+28], edx
$LN3@Add_char_t:

; 3884 :        _Node->_Large->_Insert(_Ch);

  00076 0f b6 45 08        movzx         eax, BYTE PTR __Ch$[ebp]
  0007a 50                 push    eax
  0007b 8b 4d f8   mov         ecx, DWORD PTR __Node$[ebp]
  0007e 8b 49 1c   mov         ecx, DWORD PTR [ecx+28]
  00081 e8 00 00 00 00     call    ?_Insert@?$_Buf@D@std@@QAEXD@Z ; std::_Buf<char>::_Insert

; 3885 :        }

  00086 8b e5        mov         esp, ebp
  00088 5d                 pop     ebp
  00089 c2 04 00   ret         4
?_Add_char_to_array@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEXD@Z ENDP ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_char_to_array
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Add_char_to_bitmap@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEXD@Z
_TEXT   SEGMENT
tv93 = -16                                          ; size = 4
$T1 = -12                                         ; size = 4
__Node$ = -8                                            ; size = 4
_this$ = -4                                   ; size = 4
__Ch$ = 8                                         ; size = 1
?_Add_char_to_bitmap@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEXD@Z PROC ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_char_to_bitmap, COMDAT
; _this$ = ecx

; 3862 :        {     // add character to accelerator table

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 10   sub         esp, 16                        ; 00000010H
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 3863 :        if (_Flags & regex_constants::icase)

  00009 68 00 01 00 00     push    256              ; 00000100H
  0000e 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00011 8b 48 08   mov         ecx, DWORD PTR [eax+8]
  00014 51                 push    ecx
  00015 e8 00 00 00 00     call    ??Iregex_constants@std@@YA?AW4syntax_option_type@01@W4201@0@Z ; std::regex_constants::operator&
  0001a 83 c4 08   add         esp, 8
  0001d 85 c0        test        eax, eax
  0001f 74 13        je  SHORT $LN2@Add_char_t

; 3864 :              _Ch = _Traits.translate_nocase(_Ch);

  00021 0f b6 55 08        movzx         edx, BYTE PTR __Ch$[ebp]
  00025 52                 push    edx
  00026 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00029 8b 48 0c   mov         ecx, DWORD PTR [eax+12]
  0002c e8 00 00 00 00     call    ?translate_nocase@?$_Regex_traits@D@std@@QBEDD@Z ; std::_Regex_traits<char>::translate_nocase
  00031 88 45 08   mov         BYTE PTR __Ch$[ebp], al
$LN2@Add_char_t:

; 3865 :        _Node_class<_Elem, _RxTraits> *_Node =
; 3866 :              (_Node_class<_Elem, _RxTraits> *)_Current;

  00034 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00037 8b 51 04   mov         edx, DWORD PTR [ecx+4]
  0003a 89 55 f8   mov         DWORD PTR __Node$[ebp], edx

; 3867 :
; 3868 :        if (!_Node->_Small)

  0003d 8b 45 f8   mov         eax, DWORD PTR __Node$[ebp]
  00040 83 78 18 00        cmp   DWORD PTR [eax+24], 0
  00044 75 30        jne         SHORT $LN3@Add_char_t

; 3869 :              _Node->_Small = new _Bitmap;

  00046 6a 20        push        32             ; 00000020H
  00048 e8 00 00 00 00     call    ??2@YAPAXI@Z   ; operator new
  0004d 83 c4 04   add         esp, 4
  00050 89 45 f4   mov         DWORD PTR $T1[ebp], eax
  00053 83 7d f4 00        cmp   DWORD PTR $T1[ebp], 0
  00057 74 0d        je  SHORT $LN5@Add_char_t
  00059 8b 4d f4   mov         ecx, DWORD PTR $T1[ebp]
  0005c e8 00 00 00 00     call    ??0_Bitmap@std@@QAE@XZ       ; std::_Bitmap::_Bitmap
  00061 89 45 f0   mov         DWORD PTR tv93[ebp], eax
  00064 eb 07        jmp         SHORT $LN6@Add_char_t
$LN5@Add_char_t:
  00066 c7 45 f0 00 00
        00 00          mov         DWORD PTR tv93[ebp], 0
$LN6@Add_char_t:
  0006d 8b 4d f8   mov         ecx, DWORD PTR __Node$[ebp]
  00070 8b 55 f0   mov         edx, DWORD PTR tv93[ebp]
  00073 89 51 18   mov         DWORD PTR [ecx+24], edx
$LN3@Add_char_t:

; 3870 :        _Node->_Small->_Mark(static_cast<typename _RxTraits::_Uelem>(_Ch));

  00076 0f b6 45 08        movzx         eax, BYTE PTR __Ch$[ebp]
  0007a 50                 push    eax
  0007b 8b 4d f8   mov         ecx, DWORD PTR __Node$[ebp]
  0007e 8b 49 18   mov         ecx, DWORD PTR [ecx+24]
  00081 e8 00 00 00 00     call    ??$_Mark@E@_Bitmap@std@@QAEXE@Z ; std::_Bitmap::_Mark<unsigned char>

; 3871 :        }

  00086 8b e5        mov         esp, ebp
  00088 5d                 pop     ebp
  00089 c2 04 00   ret         4
?_Add_char_to_bitmap@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEXD@Z ENDP ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_char_to_bitmap
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Beg_expr@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@ABE_NPAV_Node_base@2@@Z
_TEXT   SEGMENT
_this$ = -8                                   ; size = 4
tv70 = -4                                         ; size = 4
__Nx$ = 8                                         ; size = 4
?_Beg_expr@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@ABE_NPAV_Node_base@2@@Z PROC ; std::_Builder<char const *,char,std::regex_traits<char> >::_Beg_expr, COMDAT
; _this$ = ecx

; 3746 :        {     // test for beginning of expression or subexpression

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d f8   mov         DWORD PTR _this$[ebp], ecx

; 3747 :        return (_Nx->_Kind == _N_begin

  00009 8b 45 08   mov         eax, DWORD PTR __Nx$[ebp]
  0000c 83 78 04 14        cmp   DWORD PTR [eax+4], 20      ; 00000014H
  00010 74 1b        je  SHORT $LN3@Beg_expr
  00012 8b 4d 08   mov         ecx, DWORD PTR __Nx$[ebp]
  00015 83 79 04 08        cmp   DWORD PTR [ecx+4], 8
  00019 74 12        je  SHORT $LN3@Beg_expr
  0001b 8b 55 08   mov         edx, DWORD PTR __Nx$[ebp]
  0001e 83 7a 04 0d        cmp   DWORD PTR [edx+4], 13      ; 0000000dH
  00022 74 09        je  SHORT $LN3@Beg_expr
  00024 c7 45 fc 00 00
        00 00          mov         DWORD PTR tv70[ebp], 0
  0002b eb 07        jmp         SHORT $LN4@Beg_expr
$LN3@Beg_expr:
  0002d c7 45 fc 01 00
        00 00          mov         DWORD PTR tv70[ebp], 1
$LN4@Beg_expr:
  00034 8a 45 fc   mov         al, BYTE PTR tv70[ebp]

; 3748 :              || _Nx->_Kind == _N_group
; 3749 :              || _Nx->_Kind == _N_capture);
; 3750 :        }

  00037 8b e5        mov         esp, ebp
  00039 5d                 pop     ebp
  0003a c2 04 00   ret         4
?_Beg_expr@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@ABE_NPAV_Node_base@2@@Z ENDP ; std::_Builder<char const *,char,std::regex_traits<char> >::_Beg_expr
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Add_str_node@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ
_TEXT   SEGMENT
_this$ = -12                                            ; size = 4
tv78 = -8                                         ; size = 4
$T1 = -4                                                ; size = 4
?_Add_str_node@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ PROC ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_str_node, COMDAT
; _this$ = ecx

; 3831 :        {     // add string node

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 0c   sub         esp, 12                        ; 0000000cH
  00006 89 4d f4   mov         DWORD PTR _this$[ebp], ecx

; 3832 :        _Link_node(new _Node_str<_Elem>);

  00009 6a 20        push        32             ; 00000020H
  0000b e8 00 00 00 00     call    ??2@YAPAXI@Z   ; operator new
  00010 83 c4 04   add         esp, 4
  00013 89 45 fc   mov         DWORD PTR $T1[ebp], eax
  00016 83 7d fc 00        cmp   DWORD PTR $T1[ebp], 0
  0001a 74 0f        je  SHORT $LN3@Add_str_no
  0001c 6a 00        push        0
  0001e 8b 4d fc   mov         ecx, DWORD PTR $T1[ebp]
  00021 e8 00 00 00 00     call    ??0?$_Node_str@D@std@@QAE@W4_Node_flags@1@@Z ; std::_Node_str<char>::_Node_str<char>
  00026 89 45 f8   mov         DWORD PTR tv78[ebp], eax
  00029 eb 07        jmp         SHORT $LN4@Add_str_no
$LN3@Add_str_no:
  0002b c7 45 f8 00 00
        00 00          mov         DWORD PTR tv78[ebp], 0
$LN4@Add_str_no:
  00032 8b 45 f8   mov         eax, DWORD PTR tv78[ebp]
  00035 50                 push    eax
  00036 8b 4d f4   mov         ecx, DWORD PTR _this$[ebp]
  00039 e8 00 00 00 00     call    ?_Link_node@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEPAV_Node_base@2@PAV32@@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Link_node

; 3833 :        }

  0003e 8b e5        mov         esp, ebp
  00040 5d                 pop     ebp
  00041 c3                 ret     0
?_Add_str_node@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ENDP ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_str_node
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_New_node@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEPAV_Node_base@2@W4_Node_type@2@@Z
_TEXT   SEGMENT
_this$ = -12                                            ; size = 4
tv76 = -8                                         ; size = 4
$T1 = -4                                                ; size = 4
__Kind$ = 8                                   ; size = 4
?_New_node@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEPAV_Node_base@2@W4_Node_type@2@@Z PROC ; std::_Builder<char const *,char,std::regex_traits<char> >::_New_node, COMDAT
; _this$ = ecx

; 3783 :        {     // allocate and link simple node

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 0c   sub         esp, 12                        ; 0000000cH
  00006 89 4d f4   mov         DWORD PTR _this$[ebp], ecx

; 3784 :        return (_Link_node(new _Node_base(_Kind)));

  00009 6a 14        push        20             ; 00000014H
  0000b e8 00 00 00 00     call    ??2@YAPAXI@Z   ; operator new
  00010 83 c4 04   add         esp, 4
  00013 89 45 fc   mov         DWORD PTR $T1[ebp], eax
  00016 83 7d fc 00        cmp   DWORD PTR $T1[ebp], 0
  0001a 74 13        je  SHORT $LN3@New_node
  0001c 6a 00        push        0
  0001e 8b 45 08   mov         eax, DWORD PTR __Kind$[ebp]
  00021 50                 push    eax
  00022 8b 4d fc   mov         ecx, DWORD PTR $T1[ebp]
  00025 e8 00 00 00 00     call    ??0_Node_base@std@@QAE@W4_Node_type@1@W4_Node_flags@1@@Z ; std::_Node_base::_Node_base
  0002a 89 45 f8   mov         DWORD PTR tv76[ebp], eax
  0002d eb 07        jmp         SHORT $LN4@New_node
$LN3@New_node:
  0002f c7 45 f8 00 00
        00 00          mov         DWORD PTR tv76[ebp], 0
$LN4@New_node:
  00036 8b 4d f8   mov         ecx, DWORD PTR tv76[ebp]
  00039 51                 push    ecx
  0003a 8b 4d f4   mov         ecx, DWORD PTR _this$[ebp]
  0003d e8 00 00 00 00     call    ?_Link_node@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEPAV_Node_base@2@PAV32@@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Link_node

; 3785 :        }

  00042 8b e5        mov         esp, ebp
  00044 5d                 pop     ebp
  00045 c2 04 00   ret         4
?_New_node@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEPAV_Node_base@2@W4_Node_type@2@@Z ENDP ; std::_Builder<char const *,char,std::regex_traits<char> >::_New_node
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Link_node@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEPAV_Node_base@2@PAV32@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Nx$ = 8                                         ; size = 4
?_Link_node@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEPAV_Node_base@2@PAV32@@Z PROC ; std::_Builder<char const *,char,std::regex_traits<char> >::_Link_node, COMDAT
; _this$ = ecx

; 3766 :        {     // insert _Nx at current location

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 3767 :        _Nx->_Prev = _Current;

  00007 8b 45 08   mov         eax, DWORD PTR __Nx$[ebp]
  0000a 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000d 8b 51 04   mov         edx, DWORD PTR [ecx+4]
  00010 89 50 10   mov         DWORD PTR [eax+16], edx

; 3768 :        if (_Current->_Next)

  00013 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00016 8b 48 04   mov         ecx, DWORD PTR [eax+4]
  00019 83 79 0c 00        cmp   DWORD PTR [ecx+12], 0
  0001d 74 1e        je  SHORT $LN2@Link_node

; 3769 :              {   // set back pointer
; 3770 :              _Nx->_Next = _Current->_Next;

  0001f 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  00022 8b 42 04   mov         eax, DWORD PTR [edx+4]
  00025 8b 4d 08   mov         ecx, DWORD PTR __Nx$[ebp]
  00028 8b 50 0c   mov         edx, DWORD PTR [eax+12]
  0002b 89 51 0c   mov         DWORD PTR [ecx+12], edx

; 3771 :              _Current->_Next->_Prev = _Nx;

  0002e 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00031 8b 48 04   mov         ecx, DWORD PTR [eax+4]
  00034 8b 51 0c   mov         edx, DWORD PTR [ecx+12]
  00037 8b 45 08   mov         eax, DWORD PTR __Nx$[ebp]
  0003a 89 42 10   mov         DWORD PTR [edx+16], eax
$LN2@Link_node:

; 3772 :              }
; 3773 :        _Current->_Next = _Nx;

  0003d 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00040 8b 51 04   mov         edx, DWORD PTR [ecx+4]
  00043 8b 45 08   mov         eax, DWORD PTR __Nx$[ebp]
  00046 89 42 0c   mov         DWORD PTR [edx+12], eax

; 3774 :        _Current = _Nx;

  00049 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0004c 8b 55 08   mov         edx, DWORD PTR __Nx$[ebp]
  0004f 89 51 04   mov         DWORD PTR [ecx+4], edx

; 3775 :        return (_Nx);

  00052 8b 45 08   mov         eax, DWORD PTR __Nx$[ebp]

; 3776 :        }

  00055 8b e5        mov         esp, ebp
  00057 5d                 pop     ebp
  00058 c2 04 00   ret         4
?_Link_node@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEPAV_Node_base@2@PAV32@@Z ENDP ; std::_Builder<char const *,char,std::regex_traits<char> >::_Link_node
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_End_pattern@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Root_node@2@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_End_pattern@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Root_node@2@XZ PROC ; std::_Builder<char const *,char,std::regex_traits<char> >::_End_pattern, COMDAT
; _this$ = ecx

; 4185 :        {     // wrap up

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 4186 :        _New_node(_N_end);

  00007 6a 15        push        21             ; 00000015H
  00009 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000c e8 00 00 00 00     call    ?_New_node@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEPAV_Node_base@2@W4_Node_type@2@@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_New_node

; 4187 :        return (_Root);

  00011 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00014 8b 00        mov         eax, DWORD PTR [eax]

; 4188 :        }

  00016 8b e5        mov         esp, ebp
  00018 5d                 pop     ebp
  00019 c3                 ret     0
?_End_pattern@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Root_node@2@XZ ENDP ; std::_Builder<char const *,char,std::regex_traits<char> >::_End_pattern
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Mark_final@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Mark_final@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXXZ PROC ; std::_Builder<char const *,char,std::regex_traits<char> >::_Mark_final, COMDAT
; _this$ = ecx

; 3729 :        {     // set flag

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 3730 :        _Current->_Flags |= _Fl_final;

  00007 6a 04        push        4
  00009 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000c 8b 48 04   mov         ecx, DWORD PTR [eax+4]
  0000f 83 c1 08   add         ecx, 8
  00012 51                 push    ecx
  00013 e8 00 00 00 00     call    ??_5std@@YA?AW4_Node_flags@0@AAW410@W410@@Z ; std::operator|=
  00018 83 c4 08   add         esp, 8

; 3731 :        }

  0001b 8b e5        mov         esp, ebp
  0001d 5d                 pop     ebp
  0001e c3                 ret     0
?_Mark_final@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXXZ ENDP ; std::_Builder<char const *,char,std::regex_traits<char> >::_Mark_final
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Negate@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Negate@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXXZ PROC ; std::_Builder<char const *,char,std::regex_traits<char> >::_Negate, COMDAT
; _this$ = ecx

; 3721 :        {     // set flag

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 3722 :        _Current->_Flags ^= _Fl_negate;

  00007 6a 01        push        1
  00009 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000c 8b 48 04   mov         ecx, DWORD PTR [eax+4]
  0000f 83 c1 08   add         ecx, 8
  00012 51                 push    ecx
  00013 e8 00 00 00 00     call    ??_6std@@YA?AW4_Node_flags@0@AAW410@W410@@Z ; std::operator^=
  00018 83 c4 08   add         esp, 8

; 3723 :        }

  0001b 8b e5        mov         esp, ebp
  0001d 5d                 pop     ebp
  0001e c3                 ret     0
?_Negate@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXXZ ENDP ; std::_Builder<char const *,char,std::regex_traits<char> >::_Negate
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Add_rep@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXHH_N@Z
_TEXT   SEGMENT
tv143 = -40                                   ; size = 4
__Node$1 = -36                                      ; size = 4
tv149 = -32                                   ; size = 4
$T2 = -28                                         ; size = 4
tv95 = -24                                          ; size = 4
$T3 = -20                                         ; size = 4
__Node0$ = -16                                      ; size = 4
__Nx$ = -12                                   ; size = 4
__Pos$ = -8                                   ; size = 4
_this$ = -4                                   ; size = 4
__Min$ = 8                                          ; size = 4
__Max$ = 12                                   ; size = 4
__Greedy$ = 16                                      ; size = 1
?_Add_rep@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXHH_N@Z PROC ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_rep, COMDAT
; _this$ = ecx

; 4159 :        {     // add repeat node

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 28   sub         esp, 40                        ; 00000028H
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 4160 :        if (_Current->_Kind == _N_str
; 4161 :              && ((_Node_str<_Elem> *)_Current)->_Data._Size() != 1)

  00009 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000c 8b 48 04   mov         ecx, DWORD PTR [eax+4]
  0000f 83 79 04 06        cmp   DWORD PTR [ecx+4], 6
  00013 75 33        jne         SHORT $LN2@Add_rep
  00015 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  00018 8b 4a 04   mov         ecx, DWORD PTR [edx+4]
  0001b 83 c1 14   add         ecx, 20                        ; 00000014H
  0001e e8 00 00 00 00     call    ?_Size@?$_Buf@D@std@@QBEIXZ ; std::_Buf<char>::_Size
  00023 83 f8 01   cmp         eax, 1
  00026 74 20        je  SHORT $LN2@Add_rep

; 4162 :              {   // move final character to new string node
; 4163 :              _Node_str<_Elem> *_Node = (_Node_str<_Elem> *)_Current;

  00028 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0002b 8b 48 04   mov         ecx, DWORD PTR [eax+4]
  0002e 89 4d dc   mov         DWORD PTR __Node$1[ebp], ecx

; 4164 :              _Add_char(_Node->_Data._Del());

  00031 8b 4d dc   mov         ecx, DWORD PTR __Node$1[ebp]
  00034 83 c1 14   add         ecx, 20                        ; 00000014H
  00037 e8 00 00 00 00     call    ?_Del@?$_Buf@D@std@@QAEDXZ ; std::_Buf<char>::_Del
  0003c 0f b6 d0   movzx       edx, al
  0003f 52                 push    edx
  00040 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00043 e8 00 00 00 00     call    ?_Add_char@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXD@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_char
$LN2@Add_rep:

; 4165 :              }
; 4166 :        _Node_base *_Pos = _Current;

  00048 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0004b 8b 48 04   mov         ecx, DWORD PTR [eax+4]
  0004e 89 4d f8   mov         DWORD PTR __Pos$[ebp], ecx

; 4167 :        _Node_end_rep *_Node0 = new _Node_end_rep();

  00051 6a 18        push        24             ; 00000018H
  00053 e8 00 00 00 00     call    ??2@YAPAXI@Z   ; operator new
  00058 83 c4 04   add         esp, 4
  0005b 89 45 ec   mov         DWORD PTR $T3[ebp], eax
  0005e 83 7d ec 00        cmp   DWORD PTR $T3[ebp], 0
  00062 74 0d        je  SHORT $LN6@Add_rep
  00064 8b 4d ec   mov         ecx, DWORD PTR $T3[ebp]
  00067 e8 00 00 00 00     call    ??0_Node_end_rep@std@@QAE@XZ ; std::_Node_end_rep::_Node_end_rep
  0006c 89 45 e8   mov         DWORD PTR tv95[ebp], eax
  0006f eb 07        jmp         SHORT $LN7@Add_rep
$LN6@Add_rep:
  00071 c7 45 e8 00 00
        00 00          mov         DWORD PTR tv95[ebp], 0
$LN7@Add_rep:
  00078 8b 55 e8   mov         edx, DWORD PTR tv95[ebp]
  0007b 89 55 f0   mov         DWORD PTR __Node0$[ebp], edx

; 4168 :        _Node_rep *_Nx =
; 4169 :              new _Node_rep(_Greedy, _Min, _Max, _Node0, _Root->_Loops++);

  0007e 6a 28        push        40             ; 00000028H
  00080 e8 00 00 00 00     call    ??2@YAPAXI@Z   ; operator new
  00085 83 c4 04   add         esp, 4
  00088 89 45 e4   mov         DWORD PTR $T2[ebp], eax
  0008b 83 7d e4 00        cmp   DWORD PTR $T2[ebp], 0
  0008f 74 40        je  SHORT $LN8@Add_rep
  00091 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00094 8b 08        mov         ecx, DWORD PTR [eax]
  00096 8b 51 18   mov         edx, DWORD PTR [ecx+24]
  00099 89 55 d8   mov         DWORD PTR tv143[ebp], edx
  0009c 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0009f 8b 08        mov         ecx, DWORD PTR [eax]
  000a1 8b 51 18   mov         edx, DWORD PTR [ecx+24]
  000a4 83 c2 01   add         edx, 1
  000a7 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  000aa 8b 08        mov         ecx, DWORD PTR [eax]
  000ac 89 51 18   mov         DWORD PTR [ecx+24], edx
  000af 8b 55 d8   mov         edx, DWORD PTR tv143[ebp]
  000b2 52                 push    edx
  000b3 8b 45 f0   mov         eax, DWORD PTR __Node0$[ebp]
  000b6 50                 push    eax
  000b7 8b 4d 0c   mov         ecx, DWORD PTR __Max$[ebp]
  000ba 51                 push    ecx
  000bb 8b 55 08   mov         edx, DWORD PTR __Min$[ebp]
  000be 52                 push    edx
  000bf 0f b6 45 10        movzx         eax, BYTE PTR __Greedy$[ebp]
  000c3 50                 push    eax
  000c4 8b 4d e4   mov         ecx, DWORD PTR $T2[ebp]
  000c7 e8 00 00 00 00     call    ??0_Node_rep@std@@QAE@_NHHPAV_Node_end_rep@1@I@Z ; std::_Node_rep::_Node_rep
  000cc 89 45 e0   mov         DWORD PTR tv149[ebp], eax
  000cf eb 07        jmp         SHORT $LN9@Add_rep
$LN8@Add_rep:
  000d1 c7 45 e0 00 00
        00 00          mov         DWORD PTR tv149[ebp], 0
$LN9@Add_rep:
  000d8 8b 4d e0   mov         ecx, DWORD PTR tv149[ebp]
  000db 89 4d f4   mov         DWORD PTR __Nx$[ebp], ecx

; 4170 :        _Node0->_Begin_rep = _Nx;

  000de 8b 55 f0   mov         edx, DWORD PTR __Node0$[ebp]
  000e1 8b 45 f4   mov         eax, DWORD PTR __Nx$[ebp]
  000e4 89 42 14   mov         DWORD PTR [edx+20], eax

; 4171 :        _Link_node(_Node0);

  000e7 8b 4d f0   mov         ecx, DWORD PTR __Node0$[ebp]
  000ea 51                 push    ecx
  000eb 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000ee e8 00 00 00 00     call    ?_Link_node@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEPAV_Node_base@2@PAV32@@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Link_node

; 4172 :        if (_Pos->_Kind == _N_end_group
; 4173 :              || _Pos->_Kind == _N_end_capture)

  000f3 8b 55 f8   mov         edx, DWORD PTR __Pos$[ebp]
  000f6 83 7a 04 09        cmp   DWORD PTR [edx+4], 9
  000fa 74 09        je  SHORT $LN4@Add_rep
  000fc 8b 45 f8   mov         eax, DWORD PTR __Pos$[ebp]
  000ff 83 78 04 0e        cmp   DWORD PTR [eax+4], 14      ; 0000000eH
  00103 75 09        jne         SHORT $LN3@Add_rep
$LN4@Add_rep:

; 4174 :              _Pos = ((_Node_end_group *)_Pos)->_Back;

  00105 8b 4d f8   mov         ecx, DWORD PTR __Pos$[ebp]
  00108 8b 51 14   mov         edx, DWORD PTR [ecx+20]
  0010b 89 55 f8   mov         DWORD PTR __Pos$[ebp], edx
$LN3@Add_rep:

; 4175 :        _Pos->_Prev->_Next = _Nx;

  0010e 8b 45 f8   mov         eax, DWORD PTR __Pos$[ebp]
  00111 8b 48 10   mov         ecx, DWORD PTR [eax+16]
  00114 8b 55 f4   mov         edx, DWORD PTR __Nx$[ebp]
  00117 89 51 0c   mov         DWORD PTR [ecx+12], edx

; 4176 :        _Nx->_Prev = _Pos->_Prev;

  0011a 8b 45 f4   mov         eax, DWORD PTR __Nx$[ebp]
  0011d 8b 4d f8   mov         ecx, DWORD PTR __Pos$[ebp]
  00120 8b 51 10   mov         edx, DWORD PTR [ecx+16]
  00123 89 50 10   mov         DWORD PTR [eax+16], edx

; 4177 :        _Pos->_Prev = _Nx;

  00126 8b 45 f8   mov         eax, DWORD PTR __Pos$[ebp]
  00129 8b 4d f4   mov         ecx, DWORD PTR __Nx$[ebp]
  0012c 89 48 10   mov         DWORD PTR [eax+16], ecx

; 4178 :        _Nx->_Next = _Pos;

  0012f 8b 55 f4   mov         edx, DWORD PTR __Nx$[ebp]
  00132 8b 45 f8   mov         eax, DWORD PTR __Pos$[ebp]
  00135 89 42 0c   mov         DWORD PTR [edx+12], eax

; 4179 :        }

  00138 8b e5        mov         esp, ebp
  0013a 5d                 pop     ebp
  0013b c2 0c 00   ret         12           ; 0000000cH
?_Add_rep@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXHH_N@Z ENDP ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_rep
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Else_if@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXPAV_Node_base@2@0@Z
_TEXT   SEGMENT
__Last$ = -24                                     ; size = 4
__First$ = -20                                      ; size = 4
tv88 = -16                                          ; size = 4
$T1 = -12                                         ; size = 4
_this$ = -8                                   ; size = 4
__Parent$ = -4                                      ; size = 4
__Start$ = 8                                            ; size = 4
__End$ = 12                                   ; size = 4
?_Else_if@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXPAV_Node_base@2@0@Z PROC ; std::_Builder<char const *,char,std::regex_traits<char> >::_Else_if, COMDAT
; _this$ = ecx

; 4139 :        {     // add else node

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 18   sub         esp, 24                        ; 00000018H
  00006 89 4d f8   mov         DWORD PTR _this$[ebp], ecx

; 4140 :        _Node_if *_Parent = (_Node_if *)_Start->_Next;

  00009 8b 45 08   mov         eax, DWORD PTR __Start$[ebp]
  0000c 8b 48 0c   mov         ecx, DWORD PTR [eax+12]
  0000f 89 4d fc   mov         DWORD PTR __Parent$[ebp], ecx

; 4141 :        _Node_base *_First = _End->_Next;

  00012 8b 55 0c   mov         edx, DWORD PTR __End$[ebp]
  00015 8b 42 0c   mov         eax, DWORD PTR [edx+12]
  00018 89 45 ec   mov         DWORD PTR __First$[ebp], eax

; 4142 :        _End->_Next = 0;

  0001b 8b 4d 0c   mov         ecx, DWORD PTR __End$[ebp]
  0001e c7 41 0c 00 00
        00 00          mov         DWORD PTR [ecx+12], 0

; 4143 :        _Node_base *_Last = _Current;

  00025 8b 55 f8   mov         edx, DWORD PTR _this$[ebp]
  00028 8b 42 04   mov         eax, DWORD PTR [edx+4]
  0002b 89 45 e8   mov         DWORD PTR __Last$[ebp], eax

; 4144 :        _Current = _End;

  0002e 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00031 8b 55 0c   mov         edx, DWORD PTR __End$[ebp]
  00034 89 51 04   mov         DWORD PTR [ecx+4], edx

; 4145 :        _End->_Next = 0;

  00037 8b 45 0c   mov         eax, DWORD PTR __End$[ebp]
  0003a c7 40 0c 00 00
        00 00          mov         DWORD PTR [eax+12], 0

; 4146 :        _Last->_Next = _End;

  00041 8b 4d e8   mov         ecx, DWORD PTR __Last$[ebp]
  00044 8b 55 0c   mov         edx, DWORD PTR __End$[ebp]
  00047 89 51 0c   mov         DWORD PTR [ecx+12], edx
$LN2@Else_if:

; 4147 :        while (_Parent->_Child)

  0004a 8b 45 fc   mov         eax, DWORD PTR __Parent$[ebp]
  0004d 83 78 18 00        cmp   DWORD PTR [eax+24], 0
  00051 74 0b        je  SHORT $LN3@Else_if

; 4148 :              _Parent = _Parent->_Child;

  00053 8b 4d fc   mov         ecx, DWORD PTR __Parent$[ebp]
  00056 8b 51 18   mov         edx, DWORD PTR [ecx+24]
  00059 89 55 fc   mov         DWORD PTR __Parent$[ebp], edx
  0005c eb ec        jmp         SHORT $LN2@Else_if
$LN3@Else_if:

; 4149 :        _Parent->_Child = new _Node_if(_End);

  0005e 6a 1c        push        28             ; 0000001cH
  00060 e8 00 00 00 00     call    ??2@YAPAXI@Z   ; operator new
  00065 83 c4 04   add         esp, 4
  00068 89 45 f4   mov         DWORD PTR $T1[ebp], eax
  0006b 83 7d f4 00        cmp   DWORD PTR $T1[ebp], 0
  0006f 74 11        je  SHORT $LN5@Else_if
  00071 8b 45 0c   mov         eax, DWORD PTR __End$[ebp]
  00074 50                 push    eax
  00075 8b 4d f4   mov         ecx, DWORD PTR $T1[ebp]
  00078 e8 00 00 00 00     call    ??0_Node_if@std@@QAE@PAV_Node_base@1@@Z ; std::_Node_if::_Node_if
  0007d 89 45 f0   mov         DWORD PTR tv88[ebp], eax
  00080 eb 07        jmp         SHORT $LN6@Else_if
$LN5@Else_if:
  00082 c7 45 f0 00 00
        00 00          mov         DWORD PTR tv88[ebp], 0
$LN6@Else_if:
  00089 8b 4d fc   mov         ecx, DWORD PTR __Parent$[ebp]
  0008c 8b 55 f0   mov         edx, DWORD PTR tv88[ebp]
  0008f 89 51 18   mov         DWORD PTR [ecx+24], edx

; 4150 :        _Parent->_Child->_Next = _First;

  00092 8b 45 fc   mov         eax, DWORD PTR __Parent$[ebp]
  00095 8b 48 18   mov         ecx, DWORD PTR [eax+24]
  00098 8b 55 ec   mov         edx, DWORD PTR __First$[ebp]
  0009b 89 51 0c   mov         DWORD PTR [ecx+12], edx

; 4151 :        _First->_Prev = _Parent->_Child;

  0009e 8b 45 ec   mov         eax, DWORD PTR __First$[ebp]
  000a1 8b 4d fc   mov         ecx, DWORD PTR __Parent$[ebp]
  000a4 8b 51 18   mov         edx, DWORD PTR [ecx+24]
  000a7 89 50 10   mov         DWORD PTR [eax+16], edx

; 4152 :        }

  000aa 8b e5        mov         esp, ebp
  000ac 5d                 pop     ebp
  000ad c2 08 00   ret         8
?_Else_if@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXPAV_Node_base@2@0@Z ENDP ; std::_Builder<char const *,char,std::regex_traits<char> >::_Else_if
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Begin_if@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Node_base@2@PAV32@@Z
_TEXT   SEGMENT
_this$ = -32                                            ; size = 4
tv88 = -28                                          ; size = 4
$T1 = -24                                         ; size = 4
tv75 = -20                                          ; size = 4
$T2 = -16                                         ; size = 4
__Res$ = -12                                            ; size = 4
__Node1$ = -8                                     ; size = 4
__Pos$ = -4                                   ; size = 4
__Start$ = 8                                            ; size = 4
?_Begin_if@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Node_base@2@PAV32@@Z PROC ; std::_Builder<char const *,char,std::regex_traits<char> >::_Begin_if, COMDAT
; _this$ = ecx

; 4119 :        {     // add if node

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 20   sub         esp, 32                        ; 00000020H
  00006 89 4d e0   mov         DWORD PTR _this$[ebp], ecx

; 4120 :        /* append endif node */
; 4121 :        _Node_base *_Res = new _Node_endif;

  00009 6a 14        push        20             ; 00000014H
  0000b e8 00 00 00 00     call    ??2@YAPAXI@Z   ; operator new
  00010 83 c4 04   add         esp, 4
  00013 89 45 f0   mov         DWORD PTR $T2[ebp], eax
  00016 83 7d f0 00        cmp   DWORD PTR $T2[ebp], 0
  0001a 74 0d        je  SHORT $LN3@Begin_if
  0001c 8b 4d f0   mov         ecx, DWORD PTR $T2[ebp]
  0001f e8 00 00 00 00     call    ??0_Node_endif@std@@QAE@XZ ; std::_Node_endif::_Node_endif
  00024 89 45 ec   mov         DWORD PTR tv75[ebp], eax
  00027 eb 07        jmp         SHORT $LN4@Begin_if
$LN3@Begin_if:
  00029 c7 45 ec 00 00
        00 00          mov         DWORD PTR tv75[ebp], 0
$LN4@Begin_if:
  00030 8b 45 ec   mov         eax, DWORD PTR tv75[ebp]
  00033 89 45 f4   mov         DWORD PTR __Res$[ebp], eax

; 4122 :        _Link_node(_Res);

  00036 8b 4d f4   mov         ecx, DWORD PTR __Res$[ebp]
  00039 51                 push    ecx
  0003a 8b 4d e0   mov         ecx, DWORD PTR _this$[ebp]
  0003d e8 00 00 00 00     call    ?_Link_node@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEPAV_Node_base@2@PAV32@@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Link_node

; 4123 :
; 4124 :        /* insert if_node */
; 4125 :        _Node_if *_Node1 = new _Node_if(_Res);

  00042 6a 1c        push        28             ; 0000001cH
  00044 e8 00 00 00 00     call    ??2@YAPAXI@Z   ; operator new
  00049 83 c4 04   add         esp, 4
  0004c 89 45 e8   mov         DWORD PTR $T1[ebp], eax
  0004f 83 7d e8 00        cmp   DWORD PTR $T1[ebp], 0
  00053 74 11        je  SHORT $LN5@Begin_if
  00055 8b 55 f4   mov         edx, DWORD PTR __Res$[ebp]
  00058 52                 push    edx
  00059 8b 4d e8   mov         ecx, DWORD PTR $T1[ebp]
  0005c e8 00 00 00 00     call    ??0_Node_if@std@@QAE@PAV_Node_base@1@@Z ; std::_Node_if::_Node_if
  00061 89 45 e4   mov         DWORD PTR tv88[ebp], eax
  00064 eb 07        jmp         SHORT $LN6@Begin_if
$LN5@Begin_if:
  00066 c7 45 e4 00 00
        00 00          mov         DWORD PTR tv88[ebp], 0
$LN6@Begin_if:
  0006d 8b 45 e4   mov         eax, DWORD PTR tv88[ebp]
  00070 89 45 f8   mov         DWORD PTR __Node1$[ebp], eax

; 4126 :        _Node_base *_Pos = _Start->_Next;

  00073 8b 4d 08   mov         ecx, DWORD PTR __Start$[ebp]
  00076 8b 51 0c   mov         edx, DWORD PTR [ecx+12]
  00079 89 55 fc   mov         DWORD PTR __Pos$[ebp], edx

; 4127 :        _Node1->_Prev = _Pos->_Prev;

  0007c 8b 45 f8   mov         eax, DWORD PTR __Node1$[ebp]
  0007f 8b 4d fc   mov         ecx, DWORD PTR __Pos$[ebp]
  00082 8b 51 10   mov         edx, DWORD PTR [ecx+16]
  00085 89 50 10   mov         DWORD PTR [eax+16], edx

; 4128 :        _Pos->_Prev->_Next = _Node1;

  00088 8b 45 fc   mov         eax, DWORD PTR __Pos$[ebp]
  0008b 8b 48 10   mov         ecx, DWORD PTR [eax+16]
  0008e 8b 55 f8   mov         edx, DWORD PTR __Node1$[ebp]
  00091 89 51 0c   mov         DWORD PTR [ecx+12], edx

; 4129 :        _Node1->_Next = _Pos;

  00094 8b 45 f8   mov         eax, DWORD PTR __Node1$[ebp]
  00097 8b 4d fc   mov         ecx, DWORD PTR __Pos$[ebp]
  0009a 89 48 0c   mov         DWORD PTR [eax+12], ecx

; 4130 :        _Pos->_Prev = _Node1;

  0009d 8b 55 fc   mov         edx, DWORD PTR __Pos$[ebp]
  000a0 8b 45 f8   mov         eax, DWORD PTR __Node1$[ebp]
  000a3 89 42 10   mov         DWORD PTR [edx+16], eax

; 4131 :        return (_Res);

  000a6 8b 45 f4   mov         eax, DWORD PTR __Res$[ebp]

; 4132 :        }

  000a9 8b e5        mov         esp, ebp
  000ab 5d                 pop     ebp
  000ac c2 04 00   ret         4
?_Begin_if@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Node_base@2@PAV32@@Z ENDP ; std::_Builder<char const *,char,std::regex_traits<char> >::_Begin_if
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Add_backreference@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXI@Z
_TEXT   SEGMENT
_this$ = -12                                            ; size = 4
tv78 = -8                                         ; size = 4
$T1 = -4                                                ; size = 4
__Idx$ = 8                                          ; size = 4
?_Add_backreference@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXI@Z PROC ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_backreference, COMDAT
; _this$ = ecx

; 4110 :        {     // add back reference node

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 0c   sub         esp, 12                        ; 0000000cH
  00006 89 4d f4   mov         DWORD PTR _this$[ebp], ecx

; 4111 :        _Link_node(new _Node_back(_Idx));

  00009 6a 18        push        24             ; 00000018H
  0000b e8 00 00 00 00     call    ??2@YAPAXI@Z   ; operator new
  00010 83 c4 04   add         esp, 4
  00013 89 45 fc   mov         DWORD PTR $T1[ebp], eax
  00016 83 7d fc 00        cmp   DWORD PTR $T1[ebp], 0
  0001a 74 11        je  SHORT $LN3@Add_backre
  0001c 8b 45 08   mov         eax, DWORD PTR __Idx$[ebp]
  0001f 50                 push    eax
  00020 8b 4d fc   mov         ecx, DWORD PTR $T1[ebp]
  00023 e8 00 00 00 00     call    ??0_Node_back@std@@QAE@I@Z ; std::_Node_back::_Node_back
  00028 89 45 f8   mov         DWORD PTR tv78[ebp], eax
  0002b eb 07        jmp         SHORT $LN4@Add_backre
$LN3@Add_backre:
  0002d c7 45 f8 00 00
        00 00          mov         DWORD PTR tv78[ebp], 0
$LN4@Add_backre:
  00034 8b 4d f8   mov         ecx, DWORD PTR tv78[ebp]
  00037 51                 push    ecx
  00038 8b 4d f4   mov         ecx, DWORD PTR _this$[ebp]
  0003b e8 00 00 00 00     call    ?_Link_node@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEPAV_Node_base@2@PAV32@@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Link_node

; 4112 :        }

  00040 8b e5        mov         esp, ebp
  00042 5d                 pop     ebp
  00043 c2 04 00   ret         4
?_Add_backreference@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXI@Z ENDP ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_backreference
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Begin_capture_group@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Node_base@2@I@Z
_TEXT   SEGMENT
_this$ = -12                                            ; size = 4
tv78 = -8                                         ; size = 4
$T1 = -4                                                ; size = 4
__Idx$ = 8                                          ; size = 4
?_Begin_capture_group@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Node_base@2@I@Z PROC ; std::_Builder<char const *,char,std::regex_traits<char> >::_Begin_capture_group, COMDAT
; _this$ = ecx

; 4101 :        {     // add capture group node

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 0c   sub         esp, 12                        ; 0000000cH
  00006 89 4d f4   mov         DWORD PTR _this$[ebp], ecx

; 4102 :        return (_Link_node(new _Node_capture(_Idx)));

  00009 6a 18        push        24             ; 00000018H
  0000b e8 00 00 00 00     call    ??2@YAPAXI@Z   ; operator new
  00010 83 c4 04   add         esp, 4
  00013 89 45 fc   mov         DWORD PTR $T1[ebp], eax
  00016 83 7d fc 00        cmp   DWORD PTR $T1[ebp], 0
  0001a 74 11        je  SHORT $LN3@Begin_capt
  0001c 8b 45 08   mov         eax, DWORD PTR __Idx$[ebp]
  0001f 50                 push    eax
  00020 8b 4d fc   mov         ecx, DWORD PTR $T1[ebp]
  00023 e8 00 00 00 00     call    ??0_Node_capture@std@@QAE@I@Z ; std::_Node_capture::_Node_capture
  00028 89 45 f8   mov         DWORD PTR tv78[ebp], eax
  0002b eb 07        jmp         SHORT $LN4@Begin_capt
$LN3@Begin_capt:
  0002d c7 45 f8 00 00
        00 00          mov         DWORD PTR tv78[ebp], 0
$LN4@Begin_capt:
  00034 8b 4d f8   mov         ecx, DWORD PTR tv78[ebp]
  00037 51                 push    ecx
  00038 8b 4d f4   mov         ecx, DWORD PTR _this$[ebp]
  0003b e8 00 00 00 00     call    ?_Link_node@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEPAV_Node_base@2@PAV32@@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Link_node

; 4103 :        }

  00040 8b e5        mov         esp, ebp
  00042 5d                 pop     ebp
  00043 c2 04 00   ret         4
?_Begin_capture_group@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Node_base@2@I@Z ENDP ; std::_Builder<char const *,char,std::regex_traits<char> >::_Begin_capture_group
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_End_assert_group@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXPAV_Node_base@2@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Nx$ = 8                                         ; size = 4
?_End_assert_group@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXPAV_Node_base@2@@Z PROC ; std::_Builder<char const *,char,std::regex_traits<char> >::_End_assert_group, COMDAT
; _this$ = ecx

; 4091 :        {     // add end of assert node

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 4092 :        _End_group(_Nx);

  00007 8b 45 08   mov         eax, DWORD PTR __Nx$[ebp]
  0000a 50                 push    eax
  0000b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000e e8 00 00 00 00     call    ?_End_group@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXPAV_Node_base@2@@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_End_group

; 4093 :        _Current = _Nx;

  00013 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00016 8b 55 08   mov         edx, DWORD PTR __Nx$[ebp]
  00019 89 51 04   mov         DWORD PTR [ecx+4], edx

; 4094 :        }

  0001c 8b e5        mov         esp, ebp
  0001e 5d                 pop     ebp
  0001f c2 04 00   ret         4
?_End_assert_group@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXPAV_Node_base@2@@Z ENDP ; std::_Builder<char const *,char,std::regex_traits<char> >::_End_assert_group
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Begin_assert_group@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Node_base@2@_N@Z
_TEXT   SEGMENT
tv131 = -60                                   ; size = 4
$T2 = -56                                         ; size = 4
_this$ = -52                                            ; size = 4
tv88 = -48                                          ; size = 4
$T3 = -44                                         ; size = 4
tv77 = -40                                          ; size = 4
$T4 = -36                                         ; size = 4
tv75 = -32                                          ; size = 4
__Node2$ = -28                                      ; size = 4
$T5 = -24                                         ; size = 4
__Node1$ = -20                                      ; size = 4
__$EHRec$ = -16                               ; size = 16
__Neg$ = 8                                          ; size = 1
?_Begin_assert_group@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Node_base@2@_N@Z PROC ; std::_Builder<char const *,char,std::regex_traits<char> >::_Begin_assert_group, COMDAT
; _this$ = ecx

; 4067 :        {     // add assert node

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 6a ff        push        -1
  00005 68 00 00 00 00     push    __ehhandler$?_Begin_assert_group@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Node_base@2@_N@Z
  0000a 64 a1 00 00 00
        00           mov     eax, DWORD PTR fs:0
  00010 50                 push    eax
  00011 51                 push    ecx
  00012 83 ec 2c   sub         esp, 44                        ; 0000002cH
  00015 53                 push    ebx
  00016 56                 push    esi
  00017 57                 push    edi
  00018 a1 00 00 00 00     mov     eax, DWORD PTR ___security_cookie
  0001d 33 c5        xor         eax, ebp
  0001f 50                 push    eax
  00020 8d 45 f4   lea         eax, DWORD PTR __$EHRec$[ebp+4]
  00023 64 a3 00 00 00
        00           mov     DWORD PTR fs:0, eax
  00029 89 65 f0   mov         DWORD PTR __$EHRec$[ebp], esp
  0002c 89 4d cc   mov         DWORD PTR _this$[ebp], ecx

; 4068 :        _Node_assert *_Node1 = new _Node_assert(_Neg

  0002f 6a 18        push        24             ; 00000018H
  00031 e8 00 00 00 00     call    ??2@YAPAXI@Z   ; operator new
  00036 83 c4 04   add         esp, 4
  00039 89 45 dc   mov         DWORD PTR $T4[ebp], eax
  0003c 83 7d dc 00        cmp   DWORD PTR $T4[ebp], 0
  00040 74 2b        je  SHORT $LN6@Begin_asse
  00042 0f b6 45 08        movzx         eax, BYTE PTR __Neg$[ebp]
  00046 85 c0        test        eax, eax
  00048 74 09        je  SHORT $LN4@Begin_asse
  0004a c7 45 e0 0b 00
        00 00          mov         DWORD PTR tv75[ebp], 11        ; 0000000bH
  00051 eb 07        jmp         SHORT $LN5@Begin_asse
$LN4@Begin_asse:
  00053 c7 45 e0 0a 00
        00 00          mov         DWORD PTR tv75[ebp], 10        ; 0000000aH
$LN5@Begin_asse:
  0005a 6a 00        push        0
  0005c 8b 4d e0   mov         ecx, DWORD PTR tv75[ebp]
  0005f 51                 push    ecx
  00060 8b 4d dc   mov         ecx, DWORD PTR $T4[ebp]
  00063 e8 00 00 00 00     call    ??0_Node_assert@std@@QAE@W4_Node_type@1@W4_Node_flags@1@@Z ; std::_Node_assert::_Node_assert
  00068 89 45 d8   mov         DWORD PTR tv77[ebp], eax
  0006b eb 07        jmp         SHORT $LN7@Begin_asse
$LN6@Begin_asse:
  0006d c7 45 d8 00 00
        00 00          mov         DWORD PTR tv77[ebp], 0
$LN7@Begin_asse:
  00074 8b 55 d8   mov         edx, DWORD PTR tv77[ebp]
  00077 89 55 ec   mov         DWORD PTR __Node1$[ebp], edx

; 4069 :              ? _N_neg_assert : _N_assert);
; 4070 :
; 4071 :        _Node_base *_Node2;
; 4072 :        _TRY_BEGIN

  0007a c7 45 fc 00 00
        00 00          mov         DWORD PTR __$EHRec$[ebp+12], 0

; 4073 :        _Node2 = new _Node_base(_N_nop);

  00081 6a 14        push        20             ; 00000014H
  00083 e8 00 00 00 00     call    ??2@YAPAXI@Z   ; operator new
  00088 83 c4 04   add         esp, 4
  0008b 89 45 d4   mov         DWORD PTR $T3[ebp], eax
  0008e 83 7d d4 00        cmp   DWORD PTR $T3[ebp], 0
  00092 74 11        je  SHORT $LN8@Begin_asse
  00094 6a 00        push        0
  00096 6a 01        push        1
  00098 8b 4d d4   mov         ecx, DWORD PTR $T3[ebp]
  0009b e8 00 00 00 00     call    ??0_Node_base@std@@QAE@W4_Node_type@1@W4_Node_flags@1@@Z ; std::_Node_base::_Node_base
  000a0 89 45 d0   mov         DWORD PTR tv88[ebp], eax
  000a3 eb 07        jmp         SHORT $LN9@Begin_asse
$LN8@Begin_asse:
  000a5 c7 45 d0 00 00
        00 00          mov         DWORD PTR tv88[ebp], 0
$LN9@Begin_asse:
  000ac 8b 45 d0   mov         eax, DWORD PTR tv88[ebp]
  000af 89 45 e4   mov         DWORD PTR __Node2$[ebp], eax
  000b2 eb 3b        jmp         SHORT $LN12@Begin_asse
__catch$?_Begin_assert_group@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Node_base@2@_N@Z$0:

; 4074 :        _CATCH_ALL
; 4075 :        delete _Node1;

  000b4 8b 4d ec   mov         ecx, DWORD PTR __Node1$[ebp]
  000b7 89 4d c8   mov         DWORD PTR $T2[ebp], ecx
  000ba 8b 55 c8   mov         edx, DWORD PTR $T2[ebp]
  000bd 89 55 e8   mov         DWORD PTR $T5[ebp], edx
  000c0 83 7d e8 00        cmp   DWORD PTR $T5[ebp], 0
  000c4 74 13        je  SHORT $LN10@Begin_asse
  000c6 6a 01        push        1
  000c8 8b 45 e8   mov         eax, DWORD PTR $T5[ebp]
  000cb 8b 10        mov         edx, DWORD PTR [eax]
  000cd 8b 4d e8   mov         ecx, DWORD PTR $T5[ebp]
  000d0 8b 02        mov         eax, DWORD PTR [edx]
  000d2 ff d0        call        eax
  000d4 89 45 c4   mov         DWORD PTR tv131[ebp], eax
  000d7 eb 07        jmp         SHORT $LN11@Begin_asse
$LN10@Begin_asse:
  000d9 c7 45 c4 00 00
        00 00          mov         DWORD PTR tv131[ebp], 0
$LN11@Begin_asse:

; 4076 :        _RERAISE;

  000e0 6a 00        push        0
  000e2 6a 00        push        0
  000e4 e8 00 00 00 00     call    __CxxThrowException@8

; 4077 :        _CATCH_END

  000e9 b8 00 00 00 00     mov     eax, $LN15@Begin_asse
  000ee c3                 ret     0
$LN12@Begin_asse:
  000ef c7 45 fc ff ff
        ff ff          mov         DWORD PTR __$EHRec$[ebp+12], -1
  000f6 eb 07        jmp         SHORT __tryend$?_Begin_assert_group@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Node_base@2@_N@Z$1
$LN15@Begin_asse:
  000f8 c7 45 fc ff ff
        ff ff          mov         DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Begin_assert_group@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Node_base@2@_N@Z$1:

; 4078 :
; 4079 :        _Link_node(_Node1);

  000ff 8b 4d ec   mov         ecx, DWORD PTR __Node1$[ebp]
  00102 51                 push    ecx
  00103 8b 4d cc   mov         ecx, DWORD PTR _this$[ebp]
  00106 e8 00 00 00 00     call    ?_Link_node@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEPAV_Node_base@2@PAV32@@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Link_node

; 4080 :        _Node1->_Child = _Node2;

  0010b 8b 55 ec   mov         edx, DWORD PTR __Node1$[ebp]
  0010e 8b 45 e4   mov         eax, DWORD PTR __Node2$[ebp]
  00111 89 42 14   mov         DWORD PTR [edx+20], eax

; 4081 :        _Node2->_Prev = _Node1;

  00114 8b 4d e4   mov         ecx, DWORD PTR __Node2$[ebp]
  00117 8b 55 ec   mov         edx, DWORD PTR __Node1$[ebp]
  0011a 89 51 10   mov         DWORD PTR [ecx+16], edx

; 4082 :        _Current = _Node2;

  0011d 8b 45 cc   mov         eax, DWORD PTR _this$[ebp]
  00120 8b 4d e4   mov         ecx, DWORD PTR __Node2$[ebp]
  00123 89 48 04   mov         DWORD PTR [eax+4], ecx

; 4083 :        return (_Node1);

  00126 8b 45 ec   mov         eax, DWORD PTR __Node1$[ebp]
$LN3@Begin_asse:

; 4084 :        }

  00129 8b 4d f4   mov         ecx, DWORD PTR __$EHRec$[ebp+4]
  0012c 64 89 0d 00 00
        00 00          mov         DWORD PTR fs:0, ecx
  00133 59                 pop     ecx
  00134 5f                 pop     edi
  00135 5e                 pop     esi
  00136 5b                 pop     ebx
  00137 8b e5        mov         esp, ebp
  00139 5d                 pop     ebp
  0013a c2 04 00   ret         4
_TEXT   ENDS
;       COMDAT text$x
text$x  SEGMENT
__ehhandler$?_Begin_assert_group@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Node_base@2@_N@Z:
  00000 8b 54 24 08        mov   edx, DWORD PTR [esp+8]
  00004 8d 42 0c   lea         eax, DWORD PTR [edx+12]
  00007 8b 4a c0   mov         ecx, DWORD PTR [edx-64]
  0000a 33 c8        xor         ecx, eax
  0000c e8 00 00 00 00     call    @__security_check_cookie@4
  00011 b8 00 00 00 00     mov     eax, OFFSET __ehfuncinfo$?_Begin_assert_group@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Node_base@2@_N@Z
  00016 e9 00 00 00 00     jmp     ___CxxFrameHandler3
text$x  ENDS
?_Begin_assert_group@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Node_base@2@_N@Z ENDP ; std::_Builder<char const *,char,std::regex_traits<char> >::_Begin_assert_group
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_End_group@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXPAV_Node_base@2@@Z
_TEXT   SEGMENT
_this$ = -28                                            ; size = 4
__Elt$ = -24                                            ; size = 4
tv89 = -20                                          ; size = 4
$T1 = -16                                         ; size = 4
tv72 = -12                                          ; size = 4
tv71 = -8                                         ; size = 4
tv70 = -4                                         ; size = 4
__Back$ = 8                                   ; size = 4
?_End_group@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXPAV_Node_base@2@@Z PROC ; std::_Builder<char const *,char,std::regex_traits<char> >::_End_group, COMDAT
; _this$ = ecx

; 4054 :        {     // add end of group node

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 1c   sub         esp, 28                        ; 0000001cH
  00006 89 4d e4   mov         DWORD PTR _this$[ebp], ecx

; 4055 :        _Node_type _Elt = _Back->_Kind == _N_group ? _N_end_group

  00009 8b 45 08   mov         eax, DWORD PTR __Back$[ebp]
  0000c 83 78 04 08        cmp   DWORD PTR [eax+4], 8
  00010 75 09        jne         SHORT $LN7@End_group
  00012 c7 45 f4 09 00
        00 00          mov         DWORD PTR tv72[ebp], 9
  00019 eb 37        jmp         SHORT $LN8@End_group
$LN7@End_group:
  0001b 8b 4d 08   mov         ecx, DWORD PTR __Back$[ebp]
  0001e 83 79 04 0a        cmp   DWORD PTR [ecx+4], 10      ; 0000000aH
  00022 75 09        jne         SHORT $LN5@End_group
  00024 c7 45 f8 0c 00
        00 00          mov         DWORD PTR tv71[ebp], 12        ; 0000000cH
  0002b eb 1f        jmp         SHORT $LN6@End_group
$LN5@End_group:
  0002d 8b 55 08   mov         edx, DWORD PTR __Back$[ebp]
  00030 83 7a 04 0b        cmp   DWORD PTR [edx+4], 11      ; 0000000bH
  00034 75 09        jne         SHORT $LN3@End_group
  00036 c7 45 fc 0c 00
        00 00          mov         DWORD PTR tv70[ebp], 12        ; 0000000cH
  0003d eb 07        jmp         SHORT $LN4@End_group
$LN3@End_group:
  0003f c7 45 fc 0e 00
        00 00          mov         DWORD PTR tv70[ebp], 14        ; 0000000eH
$LN4@End_group:
  00046 8b 45 fc   mov         eax, DWORD PTR tv70[ebp]
  00049 89 45 f8   mov         DWORD PTR tv71[ebp], eax
$LN6@End_group:
  0004c 8b 4d f8   mov         ecx, DWORD PTR tv71[ebp]
  0004f 89 4d f4   mov         DWORD PTR tv72[ebp], ecx
$LN8@End_group:
  00052 8b 55 f4   mov         edx, DWORD PTR tv72[ebp]
  00055 89 55 e8   mov         DWORD PTR __Elt$[ebp], edx

; 4056 :              : _Back->_Kind == _N_assert ? _N_end_assert
; 4057 :              : _Back->_Kind == _N_neg_assert ? _N_end_assert
; 4058 :              : _N_end_capture;
; 4059 :        _Link_node(new _Node_end_group(_Elt, _Fl_none, _Back));

  00058 6a 18        push        24             ; 00000018H
  0005a e8 00 00 00 00     call    ??2@YAPAXI@Z   ; operator new
  0005f 83 c4 04   add         esp, 4
  00062 89 45 f0   mov         DWORD PTR $T1[ebp], eax
  00065 83 7d f0 00        cmp   DWORD PTR $T1[ebp], 0
  00069 74 17        je  SHORT $LN9@End_group
  0006b 8b 45 08   mov         eax, DWORD PTR __Back$[ebp]
  0006e 50                 push    eax
  0006f 6a 00        push        0
  00071 8b 4d e8   mov         ecx, DWORD PTR __Elt$[ebp]
  00074 51                 push    ecx
  00075 8b 4d f0   mov         ecx, DWORD PTR $T1[ebp]
  00078 e8 00 00 00 00     call    ??0_Node_end_group@std@@QAE@W4_Node_type@1@W4_Node_flags@1@PAV_Node_base@1@@Z ; std::_Node_end_group::_Node_end_group
  0007d 89 45 ec   mov         DWORD PTR tv89[ebp], eax
  00080 eb 07        jmp         SHORT $LN10@End_group
$LN9@End_group:
  00082 c7 45 ec 00 00
        00 00          mov         DWORD PTR tv89[ebp], 0
$LN10@End_group:
  00089 8b 55 ec   mov         edx, DWORD PTR tv89[ebp]
  0008c 52                 push    edx
  0008d 8b 4d e4   mov         ecx, DWORD PTR _this$[ebp]
  00090 e8 00 00 00 00     call    ?_Link_node@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEPAV_Node_base@2@PAV32@@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Link_node

; 4060 :        }

  00095 8b e5        mov         esp, ebp
  00097 5d                 pop     ebp
  00098 c2 04 00   ret         4
?_End_group@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXPAV_Node_base@2@@Z ENDP ; std::_Builder<char const *,char,std::regex_traits<char> >::_End_group
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Begin_group@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Node_base@2@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Begin_group@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Node_base@2@XZ PROC ; std::_Builder<char const *,char,std::regex_traits<char> >::_Begin_group, COMDAT
; _this$ = ecx

; 4045 :        {     // add group node

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 4046 :        return (_New_node(_N_group));

  00007 6a 08        push        8
  00009 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000c e8 00 00 00 00     call    ?_New_node@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEPAV_Node_base@2@W4_Node_type@2@@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_New_node

; 4047 :        }

  00011 8b e5        mov         esp, ebp
  00013 5d                 pop     ebp
  00014 c3                 ret     0
?_Begin_group@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Node_base@2@XZ ENDP ; std::_Builder<char const *,char,std::regex_traits<char> >::_Begin_group
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Add_coll@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXPBD0H@Z
_TEXT   SEGMENT
__Cur$ = -12                                            ; size = 4
__Node$ = -8                                            ; size = 4
_this$ = -4                                   ; size = 4
__First$ = 8                                            ; size = 4
__Last$ = 12                                            ; size = 4
__Diff$ = 16                                            ; size = 4
?_Add_coll@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXPBD0H@Z PROC ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_coll, COMDAT
; _this$ = ecx

; 4034 :        {     // add collation element to bracket expression

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 0c   sub         esp, 12                        ; 0000000cH
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 4035 :        _Node_class<_Elem, _RxTraits> *_Node =
; 4036 :              (_Node_class<_Elem, _RxTraits> *)_Current;

  00009 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000c 8b 48 04   mov         ecx, DWORD PTR [eax+4]
  0000f 89 4d f8   mov         DWORD PTR __Node$[ebp], ecx

; 4037 :        _Sequence<_Elem> **_Cur = &_Node->_Coll;

  00012 8b 55 f8   mov         edx, DWORD PTR __Node$[ebp]
  00015 83 c2 14   add         edx, 20                        ; 00000014H
  00018 89 55 f4   mov         DWORD PTR __Cur$[ebp], edx

; 4038 :        _Char_to_elts(_First, _Last, _Diff, _Cur);

  0001b 8b 45 f4   mov         eax, DWORD PTR __Cur$[ebp]
  0001e 50                 push    eax
  0001f 8b 4d 10   mov         ecx, DWORD PTR __Diff$[ebp]
  00022 51                 push    ecx
  00023 8b 55 0c   mov         edx, DWORD PTR __Last$[ebp]
  00026 52                 push    edx
  00027 8b 45 08   mov         eax, DWORD PTR __First$[ebp]
  0002a 50                 push    eax
  0002b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0002e e8 00 00 00 00     call    ?_Char_to_elts@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEXPBD0HPAPAU?$_Sequence@D@2@@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Char_to_elts

; 4039 :        }

  00033 8b e5        mov         esp, ebp
  00035 5d                 pop     ebp
  00036 c2 0c 00   ret         12           ; 0000000cH
?_Add_coll@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXPBD0H@Z ENDP ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_coll
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Add_equiv@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXPBD0H@Z
_TEXT   SEGMENT
__Cur$1 = -80                                     ; size = 4
tv143 = -76                                   ; size = 4
$T2 = -72                                         ; size = 4
_this$ = -68                                            ; size = 4
__Node$ = -64                                     ; size = 4
__Ch$3 = -60                                            ; size = 4
__Ex$4 = -55                                            ; size = 1
$T5 = -53                                         ; size = 1
$T6 = -52                                         ; size = 24
__Str$ = -28                                            ; size = 24
__$ArrayPad$ = -4                                 ; size = 4
__First$ = 8                                            ; size = 4
__Last$ = 12                                            ; size = 4
__Diff$ = 16                                            ; size = 4
?_Add_equiv@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXPBD0H@Z PROC ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_equiv, COMDAT
; _this$ = ecx

; 4007 :        {     // add elements of equivalence class to bracket expression

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 50   sub         esp, 80                        ; 00000050H
  00006 a1 00 00 00 00     mov     eax, DWORD PTR ___security_cookie
  0000b 33 c5        xor         eax, ebp
  0000d 89 45 fc   mov         DWORD PTR __$ArrayPad$[ebp], eax
  00010 89 4d bc   mov         DWORD PTR _this$[ebp], ecx

; 4008 :        _Node_class<_Elem, _RxTraits> *_Node =
; 4009 :              (_Node_class<_Elem, _RxTraits> *)_Current;

  00013 8b 45 bc   mov         eax, DWORD PTR _this$[ebp]
  00016 8b 48 04   mov         ecx, DWORD PTR [eax+4]
  00019 89 4d c0   mov         DWORD PTR __Node$[ebp], ecx

; 4010 :        typename _RxTraits::string_type _Str =
; 4011 :              _Traits.transform_primary(_First, _Last);

  0001c 8b 55 0c   mov         edx, DWORD PTR __Last$[ebp]
  0001f 52                 push    edx
  00020 8b 45 08   mov         eax, DWORD PTR __First$[ebp]
  00023 50                 push    eax
  00024 8d 4d e4   lea         ecx, DWORD PTR __Str$[ebp]
  00027 51                 push    ecx
  00028 8b 55 bc   mov         edx, DWORD PTR _this$[ebp]
  0002b 8b 4a 0c   mov         ecx, DWORD PTR [edx+12]
  0002e e8 00 00 00 00     call    ??$transform_primary@PBD@?$_Regex_traits@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PBD0@Z ; std::_Regex_traits<char>::transform_primary<char const *>

; 4012 :        for (unsigned int _Ch = 0; _Ch < _Bmp_max; ++_Ch)

  00033 c7 45 c4 00 00
        00 00          mov         DWORD PTR __Ch$3[ebp], 0
  0003a eb 09        jmp         SHORT $LN4@Add_equiv
$LN2@Add_equiv:
  0003c 8b 45 c4   mov         eax, DWORD PTR __Ch$3[ebp]
  0003f 83 c0 01   add         eax, 1
  00042 89 45 c4   mov         DWORD PTR __Ch$3[ebp], eax
$LN4@Add_equiv:
  00045 81 7d c4 00 01
        00 00          cmp         DWORD PTR __Ch$3[ebp], 256 ; 00000100H
  0004c 0f 83 8a 00 00
        00           jae     $LN3@Add_equiv

; 4013 :              {   // add elements
; 4014 :              _Elem _Ex = (_Elem)_Ch;

  00052 8a 4d c4   mov         cl, BYTE PTR __Ch$3[ebp]
  00055 88 4d c9   mov         BYTE PTR __Ex$4[ebp], cl

; 4015 :              if (_Traits.transform_primary(&_Ex, &_Ex + 1) == _Str)

  00058 8d 55 e4   lea         edx, DWORD PTR __Str$[ebp]
  0005b 52                 push    edx
  0005c 8d 45 ca   lea         eax, DWORD PTR __Ex$4[ebp+1]
  0005f 50                 push    eax
  00060 8d 4d c9   lea         ecx, DWORD PTR __Ex$4[ebp]
  00063 51                 push    ecx
  00064 8d 55 cc   lea         edx, DWORD PTR $T6[ebp]
  00067 52                 push    edx
  00068 8b 45 bc   mov         eax, DWORD PTR _this$[ebp]
  0006b 8b 48 0c   mov         ecx, DWORD PTR [eax+12]
  0006e e8 00 00 00 00     call    ??$transform_primary@PAD@?$_Regex_traits@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAD0@Z ; std::_Regex_traits<char>::transform_primary<char *>
  00073 50                 push    eax
  00074 e8 00 00 00 00     call    ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  00079 83 c4 08   add         esp, 8
  0007c 88 45 cb   mov         BYTE PTR $T5[ebp], al
  0007f 8d 4d cc   lea         ecx, DWORD PTR $T6[ebp]
  00082 e8 00 00 00 00     call    ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00087 0f b6 4d cb        movzx         ecx, BYTE PTR $T5[ebp]
  0008b 85 c9        test        ecx, ecx
  0008d 74 48        je  SHORT $LN5@Add_equiv

; 4016 :                  {       // insert equivalent character into bitmap
; 4017 :                  if (!_Node->_Small)

  0008f 8b 55 c0   mov         edx, DWORD PTR __Node$[ebp]
  00092 83 7a 18 00        cmp   DWORD PTR [edx+24], 0
  00096 75 30        jne         SHORT $LN6@Add_equiv

; 4018 :                          _Node->_Small = new _Bitmap;

  00098 6a 20        push        32             ; 00000020H
  0009a e8 00 00 00 00     call    ??2@YAPAXI@Z   ; operator new
  0009f 83 c4 04   add         esp, 4
  000a2 89 45 b8   mov         DWORD PTR $T2[ebp], eax
  000a5 83 7d b8 00        cmp   DWORD PTR $T2[ebp], 0
  000a9 74 0d        je  SHORT $LN9@Add_equiv
  000ab 8b 4d b8   mov         ecx, DWORD PTR $T2[ebp]
  000ae e8 00 00 00 00     call    ??0_Bitmap@std@@QAE@XZ       ; std::_Bitmap::_Bitmap
  000b3 89 45 b4   mov         DWORD PTR tv143[ebp], eax
  000b6 eb 07        jmp         SHORT $LN10@Add_equiv
$LN9@Add_equiv:
  000b8 c7 45 b4 00 00
        00 00          mov         DWORD PTR tv143[ebp], 0
$LN10@Add_equiv:
  000bf 8b 45 c0   mov         eax, DWORD PTR __Node$[ebp]
  000c2 8b 4d b4   mov         ecx, DWORD PTR tv143[ebp]
  000c5 89 48 18   mov         DWORD PTR [eax+24], ecx
$LN6@Add_equiv:

; 4019 :                  _Node->_Small->_Mark(_Ch);

  000c8 8b 55 c4   mov         edx, DWORD PTR __Ch$3[ebp]
  000cb 52                 push    edx
  000cc 8b 45 c0   mov         eax, DWORD PTR __Node$[ebp]
  000cf 8b 48 18   mov         ecx, DWORD PTR [eax+24]
  000d2 e8 00 00 00 00     call    ??$_Mark@I@_Bitmap@std@@QAEXI@Z ; std::_Bitmap::_Mark<unsigned int>
$LN5@Add_equiv:

; 4020 :                  }
; 4021 :              }

  000d7 e9 60 ff ff ff     jmp     $LN2@Add_equiv
$LN3@Add_equiv:

; 4022 :        if (_Bmp_max < static_cast<unsigned int>((numeric_limits<_Elem>::max)()))

  000dc e8 00 00 00 00     call    ?max@?$numeric_limits@D@std@@SADXZ ; std::numeric_limits<char>::max
  000e1 0f be c8   movsx       ecx, al
  000e4 81 f9 00 01 00
        00           cmp     ecx, 256             ; 00000100H
  000ea 76 21        jbe         SHORT $LN7@Add_equiv

; 4023 :              {   // map range
; 4024 :              _Sequence<_Elem> **_Cur = &_Node->_Equiv;

  000ec 8b 55 c0   mov         edx, DWORD PTR __Node$[ebp]
  000ef 83 c2 28   add         edx, 40                        ; 00000028H
  000f2 89 55 b0   mov         DWORD PTR __Cur$1[ebp], edx

; 4025 :              _Char_to_elts(_First, _Last, _Diff, _Cur);

  000f5 8b 45 b0   mov         eax, DWORD PTR __Cur$1[ebp]
  000f8 50                 push    eax
  000f9 8b 4d 10   mov         ecx, DWORD PTR __Diff$[ebp]
  000fc 51                 push    ecx
  000fd 8b 55 0c   mov         edx, DWORD PTR __Last$[ebp]
  00100 52                 push    edx
  00101 8b 45 08   mov         eax, DWORD PTR __First$[ebp]
  00104 50                 push    eax
  00105 8b 4d bc   mov         ecx, DWORD PTR _this$[ebp]
  00108 e8 00 00 00 00     call    ?_Char_to_elts@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEXPBD0HPAPAU?$_Sequence@D@2@@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Char_to_elts
$LN7@Add_equiv:

; 4026 :              }
; 4027 :        }

  0010d 8d 4d e4   lea         ecx, DWORD PTR __Str$[ebp]
  00110 e8 00 00 00 00     call    ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00115 8b 4d fc   mov         ecx, DWORD PTR __$ArrayPad$[ebp]
  00118 33 cd        xor         ecx, ebp
  0011a e8 00 00 00 00     call    @__security_check_cookie@4
  0011f 8b e5        mov         esp, ebp
  00121 5d                 pop     ebp
  00122 c2 0c 00   ret         12           ; 0000000cH
?_Add_equiv@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXPBD0H@Z ENDP ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_equiv
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Add_named_class@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXF_N@Z
_TEXT   SEGMENT
_this$ = -8                                   ; size = 4
__Node$ = -4                                            ; size = 4
__Cl$ = 8                                         ; size = 2
__Negate$ = 12                                      ; size = 1
?_Add_named_class@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXF_N@Z PROC ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_named_class, COMDAT
; _this$ = ecx

; 3959 :        {     // add contents of named class to bracket expression

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d f8   mov         DWORD PTR _this$[ebp], ecx

; 3960 :        _Node_class<_Elem, _RxTraits> *_Node =
; 3961 :              (_Node_class<_Elem, _RxTraits> *)_Current;

  00009 8b 45 f8   mov         eax, DWORD PTR _this$[ebp]
  0000c 8b 48 04   mov         ecx, DWORD PTR [eax+4]
  0000f 89 4d fc   mov         DWORD PTR __Node$[ebp], ecx

; 3962 :        _Add_elts(_Node, _Cl, _Negate);

  00012 0f b6 55 0c        movzx         edx, BYTE PTR __Negate$[ebp]
  00016 52                 push    edx
  00017 0f b7 45 08        movzx         eax, WORD PTR __Cl$[ebp]
  0001b 50                 push    eax
  0001c 8b 4d fc   mov         ecx, DWORD PTR __Node$[ebp]
  0001f 51                 push    ecx
  00020 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00023 e8 00 00 00 00     call    ?_Add_elts@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEXPAV?$_Node_class@DV?$regex_traits@D@std@@@2@F_N@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_elts

; 3963 :        if (_Bmp_max < static_cast<unsigned int>((numeric_limits<_Elem>::max)()))

  00028 e8 00 00 00 00     call    ?max@?$numeric_limits@D@std@@SADXZ ; std::numeric_limits<char>::max
  0002d 0f be d0   movsx       edx, al
  00030 81 fa 00 01 00
        00           cmp     edx, 256             ; 00000100H
  00036 76 14        jbe         SHORT $LN1@Add_named_

; 3964 :              _Node->_Classes =

  00038 8b 45 fc   mov         eax, DWORD PTR __Node$[ebp]
  0003b 0f bf 48 24        movsx         ecx, WORD PTR [eax+36]
  0003f 0f bf 55 08        movsx         edx, WORD PTR __Cl$[ebp]
  00043 0b ca        or  ecx, edx
  00045 8b 45 fc   mov         eax, DWORD PTR __Node$[ebp]
  00048 66 89 48 24        mov   WORD PTR [eax+36], cx
$LN1@Add_named_:

; 3965 :                  (_Regex_traits_base::char_class_type)(_Node->_Classes | _Cl);
; 3966 :        }

  0004c 8b e5        mov         esp, ebp
  0004e 5d                 pop     ebp
  0004f c2 08 00   ret         8
?_Add_named_class@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXF_N@Z ENDP ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_named_class
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Add_range@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXDD@Z
_TEXT   SEGMENT
tv166 = -32                                   ; size = 4
$T1 = -28                                         ; size = 4
tv142 = -24                                   ; size = 4
$T2 = -20                                         ; size = 4
__Node$ = -16                                     ; size = 4
_this$ = -12                                            ; size = 4
__E1$ = -8                                          ; size = 4
__E0$ = -4                                          ; size = 4
__E0x$ = 8                                          ; size = 1
__E1x$ = 12                                   ; size = 1
?_Add_range@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXDD@Z PROC ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_range, COMDAT
; _this$ = ecx

; 3903 :        {     // add character range to set

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 20   sub         esp, 32                        ; 00000020H
  00006 56                 push    esi
  00007 89 4d f4   mov         DWORD PTR _this$[ebp], ecx

; 3904 :        unsigned int _E0 = (typename _RxTraits::_Uelem)_E0x;

  0000a 0f b6 45 08        movzx         eax, BYTE PTR __E0x$[ebp]
  0000e 89 45 fc   mov         DWORD PTR __E0$[ebp], eax

; 3905 :        unsigned int _E1 = (typename _RxTraits::_Uelem)_E1x;

  00011 0f b6 4d 0c        movzx         ecx, BYTE PTR __E1x$[ebp]
  00015 89 4d f8   mov         DWORD PTR __E1$[ebp], ecx

; 3906 :        if (_Flags & regex_constants::icase)

  00018 68 00 01 00 00     push    256              ; 00000100H
  0001d 8b 55 f4   mov         edx, DWORD PTR _this$[ebp]
  00020 8b 42 08   mov         eax, DWORD PTR [edx+8]
  00023 50                 push    eax
  00024 e8 00 00 00 00     call    ??Iregex_constants@std@@YA?AW4syntax_option_type@01@W4201@0@Z ; std::regex_constants::operator&
  00029 83 c4 08   add         esp, 8
  0002c 85 c0        test        eax, eax
  0002e 74 2c        je  SHORT $LN8@Add_range

; 3907 :              {   // change to lowercase range
; 3908 :              _E0 = _Traits.translate_nocase((_Elem)_E0);

  00030 0f b6 4d fc        movzx         ecx, BYTE PTR __E0$[ebp]
  00034 51                 push    ecx
  00035 8b 55 f4   mov         edx, DWORD PTR _this$[ebp]
  00038 8b 4a 0c   mov         ecx, DWORD PTR [edx+12]
  0003b e8 00 00 00 00     call    ?translate_nocase@?$_Regex_traits@D@std@@QBEDD@Z ; std::_Regex_traits<char>::translate_nocase
  00040 0f be c0   movsx       eax, al
  00043 89 45 fc   mov         DWORD PTR __E0$[ebp], eax

; 3909 :              _E1 = _Traits.translate_nocase((_Elem)_E1);

  00046 0f b6 4d f8        movzx         ecx, BYTE PTR __E1$[ebp]
  0004a 51                 push    ecx
  0004b 8b 55 f4   mov         edx, DWORD PTR _this$[ebp]
  0004e 8b 4a 0c   mov         ecx, DWORD PTR [edx+12]
  00051 e8 00 00 00 00     call    ?translate_nocase@?$_Regex_traits@D@std@@QBEDD@Z ; std::_Regex_traits<char>::translate_nocase
  00056 0f be c0   movsx       eax, al
  00059 89 45 f8   mov         DWORD PTR __E1$[ebp], eax
$LN8@Add_range:

; 3910 :              }
; 3911 :        _Node_class<_Elem, _RxTraits> *_Node =
; 3912 :              (_Node_class<_Elem, _RxTraits> *)_Current;

  0005c 8b 4d f4   mov         ecx, DWORD PTR _this$[ebp]
  0005f 8b 51 04   mov         edx, DWORD PTR [ecx+4]
  00062 89 55 f0   mov         DWORD PTR __Node$[ebp], edx

; 3913 :        for (; _E0 <= _E1 && _E1 < _Get_bmax(); ++_E0)

  00065 eb 09        jmp         SHORT $LN4@Add_range
$LN2@Add_range:
  00067 8b 45 fc   mov         eax, DWORD PTR __E0$[ebp]
  0006a 83 c0 01   add         eax, 1
  0006d 89 45 fc   mov         DWORD PTR __E0$[ebp], eax
$LN4@Add_range:
  00070 8b 4d fc   mov         ecx, DWORD PTR __E0$[ebp]
  00073 3b 4d f8   cmp         ecx, DWORD PTR __E1$[ebp]
  00076 77 57        ja  SHORT $LN3@Add_range
  00078 8b 4d f4   mov         ecx, DWORD PTR _this$[ebp]
  0007b e8 00 00 00 00     call    ?_Get_bmax@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@ABEIXZ ; std::_Builder<char const *,char,std::regex_traits<char> >::_Get_bmax
  00080 39 45 f8   cmp         DWORD PTR __E1$[ebp], eax
  00083 73 4a        jae         SHORT $LN3@Add_range

; 3914 :              {   // set a bit
; 3915 :              if (!_Node->_Small)

  00085 8b 55 f0   mov         edx, DWORD PTR __Node$[ebp]
  00088 83 7a 18 00        cmp   DWORD PTR [edx+24], 0
  0008c 75 30        jne         SHORT $LN9@Add_range

; 3916 :                  _Node->_Small = new _Bitmap;

  0008e 6a 20        push        32             ; 00000020H
  00090 e8 00 00 00 00     call    ??2@YAPAXI@Z   ; operator new
  00095 83 c4 04   add         esp, 4
  00098 89 45 ec   mov         DWORD PTR $T2[ebp], eax
  0009b 83 7d ec 00        cmp   DWORD PTR $T2[ebp], 0
  0009f 74 0d        je  SHORT $LN16@Add_range
  000a1 8b 4d ec   mov         ecx, DWORD PTR $T2[ebp]
  000a4 e8 00 00 00 00     call    ??0_Bitmap@std@@QAE@XZ       ; std::_Bitmap::_Bitmap
  000a9 89 45 e8   mov         DWORD PTR tv142[ebp], eax
  000ac eb 07        jmp         SHORT $LN17@Add_range
$LN16@Add_range:
  000ae c7 45 e8 00 00
        00 00          mov         DWORD PTR tv142[ebp], 0
$LN17@Add_range:
  000b5 8b 45 f0   mov         eax, DWORD PTR __Node$[ebp]
  000b8 8b 4d e8   mov         ecx, DWORD PTR tv142[ebp]
  000bb 89 48 18   mov         DWORD PTR [eax+24], ecx
$LN9@Add_range:

; 3917 :              _Node->_Small->_Mark(_E0);

  000be 8b 55 fc   mov         edx, DWORD PTR __E0$[ebp]
  000c1 52                 push    edx
  000c2 8b 45 f0   mov         eax, DWORD PTR __Node$[ebp]
  000c5 8b 48 18   mov         ecx, DWORD PTR [eax+24]
  000c8 e8 00 00 00 00     call    ??$_Mark@I@_Bitmap@std@@QAEXI@Z ; std::_Bitmap::_Mark<unsigned int>

; 3918 :              }

  000cd eb 98        jmp         SHORT $LN2@Add_range
$LN3@Add_range:

; 3919 :        if (_E1 < _E0)

  000cf 8b 4d f8   mov         ecx, DWORD PTR __E1$[ebp]
  000d2 3b 4d fc   cmp         ecx, DWORD PTR __E0$[ebp]
  000d5 73 05        jae         SHORT $LN10@Add_range
  000d7 e9 8f 00 00 00     jmp     $LN1@Add_range
$LN10@Add_range:

; 3920 :              ;
; 3921 :        else if (_E1 - _E0 < _Get_tmax())

  000dc 8b 75 f8   mov         esi, DWORD PTR __E1$[ebp]
  000df 2b 75 fc   sub         esi, DWORD PTR __E0$[ebp]
  000e2 8b 4d f4   mov         ecx, DWORD PTR _this$[ebp]
  000e5 e8 00 00 00 00     call    ?_Get_tmax@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@ABEIXZ ; std::_Builder<char const *,char,std::regex_traits<char> >::_Get_tmax
  000ea 3b f0        cmp         esi, eax
  000ec 73 24        jae         SHORT $LN12@Add_range

; 3922 :              for (; _E0 <= _E1; ++_E0)

  000ee eb 09        jmp         SHORT $LN7@Add_range
$LN5@Add_range:
  000f0 8b 55 fc   mov         edx, DWORD PTR __E0$[ebp]
  000f3 83 c2 01   add         edx, 1
  000f6 89 55 fc   mov         DWORD PTR __E0$[ebp], edx
$LN7@Add_range:
  000f9 8b 45 fc   mov         eax, DWORD PTR __E0$[ebp]
  000fc 3b 45 f8   cmp         eax, DWORD PTR __E1$[ebp]
  000ff 77 0f        ja  SHORT $LN6@Add_range

; 3923 :                  _Add_char_to_array((_Elem)_E0);

  00101 0f b6 4d fc        movzx         ecx, BYTE PTR __E0$[ebp]
  00105 51                 push    ecx
  00106 8b 4d f4   mov         ecx, DWORD PTR _this$[ebp]
  00109 e8 00 00 00 00     call    ?_Add_char_to_array@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEXD@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_char_to_array
  0010e eb e0        jmp         SHORT $LN5@Add_range
$LN6@Add_range:

; 3924 :        else

  00110 eb 59        jmp         SHORT $LN1@Add_range
$LN12@Add_range:

; 3925 :              {   // store remaining range as pair
; 3926 :              if (!_Node->_Ranges)

  00112 8b 55 f0   mov         edx, DWORD PTR __Node$[ebp]
  00115 83 7a 20 00        cmp   DWORD PTR [edx+32], 0
  00119 75 30        jne         SHORT $LN14@Add_range

; 3927 :                  _Node->_Ranges = new _Buf<_Elem>;

  0011b 6a 0c        push        12             ; 0000000cH
  0011d e8 00 00 00 00     call    ??2@YAPAXI@Z   ; operator new
  00122 83 c4 04   add         esp, 4
  00125 89 45 e4   mov         DWORD PTR $T1[ebp], eax
  00128 83 7d e4 00        cmp   DWORD PTR $T1[ebp], 0
  0012c 74 0d        je  SHORT $LN18@Add_range
  0012e 8b 4d e4   mov         ecx, DWORD PTR $T1[ebp]
  00131 e8 00 00 00 00     call    ??0?$_Buf@D@std@@QAE@XZ      ; std::_Buf<char>::_Buf<char>
  00136 89 45 e0   mov         DWORD PTR tv166[ebp], eax
  00139 eb 07        jmp         SHORT $LN19@Add_range
$LN18@Add_range:
  0013b c7 45 e0 00 00
        00 00          mov         DWORD PTR tv166[ebp], 0
$LN19@Add_range:
  00142 8b 45 f0   mov         eax, DWORD PTR __Node$[ebp]
  00145 8b 4d e0   mov         ecx, DWORD PTR tv166[ebp]
  00148 89 48 20   mov         DWORD PTR [eax+32], ecx
$LN14@Add_range:

; 3928 :              _Node->_Ranges->_Insert((_Elem)_E0);

  0014b 0f b6 55 fc        movzx         edx, BYTE PTR __E0$[ebp]
  0014f 52                 push    edx
  00150 8b 45 f0   mov         eax, DWORD PTR __Node$[ebp]
  00153 8b 48 20   mov         ecx, DWORD PTR [eax+32]
  00156 e8 00 00 00 00     call    ?_Insert@?$_Buf@D@std@@QAEXD@Z ; std::_Buf<char>::_Insert

; 3929 :              _Node->_Ranges->_Insert((_Elem)_E1);

  0015b 0f b6 4d f8        movzx         ecx, BYTE PTR __E1$[ebp]
  0015f 51                 push    ecx
  00160 8b 55 f0   mov         edx, DWORD PTR __Node$[ebp]
  00163 8b 4a 20   mov         ecx, DWORD PTR [edx+32]
  00166 e8 00 00 00 00     call    ?_Insert@?$_Buf@D@std@@QAEXD@Z ; std::_Buf<char>::_Insert
$LN1@Add_range:

; 3930 :              }
; 3931 :        }

  0016b 5e                 pop     esi
  0016c 8b e5        mov         esp, ebp
  0016e 5d                 pop     ebp
  0016f c2 08 00   ret         8
?_Add_range@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXDD@Z ENDP ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_range
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Add_char_to_class@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXD@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Ch$ = 8                                         ; size = 1
?_Add_char_to_class@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXD@Z PROC ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_char_to_class, COMDAT
; _this$ = ecx

; 3891 :        {     // add character to bracket expression

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 3892 :        if (static_cast<typename _RxTraits::_Uelem>(_Ch) < _Bmp_max)

  00007 0f b6 45 08        movzx         eax, BYTE PTR __Ch$[ebp]
  0000b 3d 00 01 00 00     cmp     eax, 256             ; 00000100H
  00010 73 0f        jae         SHORT $LN2@Add_char_t

; 3893 :              _Add_char_to_bitmap(_Ch);

  00012 0f b6 4d 08        movzx         ecx, BYTE PTR __Ch$[ebp]
  00016 51                 push    ecx
  00017 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001a e8 00 00 00 00     call    ?_Add_char_to_bitmap@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEXD@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_char_to_bitmap

; 3894 :        else

  0001f eb 0d        jmp         SHORT $LN1@Add_char_t
$LN2@Add_char_t:

; 3895 :              _Add_char_to_array(_Ch);

  00021 0f b6 55 08        movzx         edx, BYTE PTR __Ch$[ebp]
  00025 52                 push    edx
  00026 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00029 e8 00 00 00 00     call    ?_Add_char_to_array@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEXD@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_char_to_array
$LN1@Add_char_t:

; 3896 :        }

  0002e 8b e5        mov         esp, ebp
  00030 5d                 pop     ebp
  00031 c2 04 00   ret         4
?_Add_char_to_class@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXD@Z ENDP ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_char_to_class
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Add_class@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXXZ
_TEXT   SEGMENT
_this$ = -12                                            ; size = 4
tv79 = -8                                         ; size = 4
$T1 = -4                                                ; size = 4
?_Add_class@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXXZ PROC ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_class, COMDAT
; _this$ = ecx

; 3854 :        {     // add bracket expression node

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 0c   sub         esp, 12                        ; 0000000cH
  00006 89 4d f4   mov         DWORD PTR _this$[ebp], ecx

; 3855 :        _Link_node(new _Node_class<_Elem, _RxTraits>);

  00009 6a 2c        push        44             ; 0000002cH
  0000b e8 00 00 00 00     call    ??2@YAPAXI@Z   ; operator new
  00010 83 c4 04   add         esp, 4
  00013 89 45 fc   mov         DWORD PTR $T1[ebp], eax
  00016 83 7d fc 00        cmp   DWORD PTR $T1[ebp], 0
  0001a 74 11        je  SHORT $LN3@Add_class
  0001c 6a 00        push        0
  0001e 6a 07        push        7
  00020 8b 4d fc   mov         ecx, DWORD PTR $T1[ebp]
  00023 e8 00 00 00 00     call    ??0?$_Node_class@DV?$regex_traits@D@std@@@std@@QAE@W4_Node_type@1@W4_Node_flags@1@@Z ; std::_Node_class<char,std::regex_traits<char> >::_Node_class<char,std::regex_traits<char> >
  00028 89 45 f8   mov         DWORD PTR tv79[ebp], eax
  0002b eb 07        jmp         SHORT $LN4@Add_class
$LN3@Add_class:
  0002d c7 45 f8 00 00
        00 00          mov         DWORD PTR tv79[ebp], 0
$LN4@Add_class:
  00034 8b 45 f8   mov         eax, DWORD PTR tv79[ebp]
  00037 50                 push    eax
  00038 8b 4d f4   mov         ecx, DWORD PTR _this$[ebp]
  0003b e8 00 00 00 00     call    ?_Link_node@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEPAV_Node_base@2@PAV32@@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Link_node

; 3856 :        }

  00040 8b e5        mov         esp, ebp
  00042 5d                 pop     ebp
  00043 c3                 ret     0
?_Add_class@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXXZ ENDP ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_class
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Add_char@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXD@Z
_TEXT   SEGMENT
__Node$ = -8                                            ; size = 4
_this$ = -4                                   ; size = 4
__Ch$ = 8                                         ; size = 1
?_Add_char@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXD@Z PROC ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_char, COMDAT
; _this$ = ecx

; 3839 :        {     // append character

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 3840 :        if (_Current->_Kind != _N_str || _Current->_Flags & _Fl_final)

  00009 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000c 8b 48 04   mov         ecx, DWORD PTR [eax+4]
  0000f 83 79 04 06        cmp   DWORD PTR [ecx+4], 6
  00013 75 0e        jne         SHORT $LN3@Add_char
  00015 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  00018 8b 42 04   mov         eax, DWORD PTR [edx+4]
  0001b 8b 48 08   mov         ecx, DWORD PTR [eax+8]
  0001e 83 e1 04   and         ecx, 4
  00021 74 08        je  SHORT $LN2@Add_char
$LN3@Add_char:

; 3841 :              _Add_str_node();

  00023 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00026 e8 00 00 00 00     call    ?_Add_str_node@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_str_node
$LN2@Add_char:

; 3842 :        if (_Flags & regex_constants::icase)

  0002b 68 00 01 00 00     push    256              ; 00000100H
  00030 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  00033 8b 42 08   mov         eax, DWORD PTR [edx+8]
  00036 50                 push    eax
  00037 e8 00 00 00 00     call    ??Iregex_constants@std@@YA?AW4syntax_option_type@01@W4201@0@Z ; std::regex_constants::operator&
  0003c 83 c4 08   add         esp, 8
  0003f 85 c0        test        eax, eax
  00041 74 15        je  SHORT $LN4@Add_char

; 3843 :              _Ch = _Traits.translate_nocase(_Ch);

  00043 0f b6 4d 08        movzx         ecx, BYTE PTR __Ch$[ebp]
  00047 51                 push    ecx
  00048 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  0004b 8b 4a 0c   mov         ecx, DWORD PTR [edx+12]
  0004e e8 00 00 00 00     call    ?translate_nocase@?$_Regex_traits@D@std@@QBEDD@Z ; std::_Regex_traits<char>::translate_nocase
  00053 88 45 08   mov         BYTE PTR __Ch$[ebp], al
  00056 eb 2b        jmp         SHORT $LN5@Add_char
$LN4@Add_char:

; 3844 :        else if (_Flags & regex_constants::collate)

  00058 68 00 08 00 00     push    2048       ; 00000800H
  0005d 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00060 8b 48 08   mov         ecx, DWORD PTR [eax+8]
  00063 51                 push    ecx
  00064 e8 00 00 00 00     call    ??Iregex_constants@std@@YA?AW4syntax_option_type@01@W4201@0@Z ; std::regex_constants::operator&
  00069 83 c4 08   add         esp, 8
  0006c 85 c0        test        eax, eax
  0006e 74 13        je  SHORT $LN5@Add_char

; 3845 :              _Ch = _Traits.translate(_Ch);

  00070 0f b6 55 08        movzx         edx, BYTE PTR __Ch$[ebp]
  00074 52                 push    edx
  00075 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00078 8b 48 0c   mov         ecx, DWORD PTR [eax+12]
  0007b e8 00 00 00 00     call    ?translate@?$_Regex_traits@D@std@@QBEDD@Z ; std::_Regex_traits<char>::translate
  00080 88 45 08   mov         BYTE PTR __Ch$[ebp], al
$LN5@Add_char:

; 3846 :        _Node_str<_Elem> *_Node = (_Node_str<_Elem> *)_Current;

  00083 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00086 8b 51 04   mov         edx, DWORD PTR [ecx+4]
  00089 89 55 f8   mov         DWORD PTR __Node$[ebp], edx

; 3847 :        _Node->_Data._Insert(_Ch);

  0008c 0f b6 45 08        movzx         eax, BYTE PTR __Ch$[ebp]
  00090 50                 push    eax
  00091 8b 4d f8   mov         ecx, DWORD PTR __Node$[ebp]
  00094 83 c1 14   add         ecx, 20                        ; 00000014H
  00097 e8 00 00 00 00     call    ?_Insert@?$_Buf@D@std@@QAEXD@Z ; std::_Buf<char>::_Insert

; 3848 :        }

  0009c 8b e5        mov         esp, ebp
  0009e 5d                 pop     ebp
  0009f c2 04 00   ret         4
?_Add_char@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXD@Z ENDP ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_char
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Add_dot@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Add_dot@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXXZ PROC ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_dot, COMDAT
; _this$ = ecx

; 3823 :        {     // add dot node

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 3824 :        _New_node(_N_dot);

  00007 6a 05        push        5
  00009 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000c e8 00 00 00 00     call    ?_New_node@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEPAV_Node_base@2@W4_Node_type@2@@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_New_node

; 3825 :        }

  00011 8b e5        mov         esp, ebp
  00013 5d                 pop     ebp
  00014 c3                 ret     0
?_Add_dot@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXXZ ENDP ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_dot
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Add_wbound@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Add_wbound@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXXZ PROC ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_wbound, COMDAT
; _this$ = ecx

; 3815 :        {     // add wbound node

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 3816 :        _New_node(_N_wbound);

  00007 6a 04        push        4
  00009 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000c e8 00 00 00 00     call    ?_New_node@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEPAV_Node_base@2@W4_Node_type@2@@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_New_node

; 3817 :        }

  00011 8b e5        mov         esp, ebp
  00013 5d                 pop     ebp
  00014 c3                 ret     0
?_Add_wbound@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXXZ ENDP ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_wbound
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Add_eol@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Add_eol@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXXZ PROC ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_eol, COMDAT
; _this$ = ecx

; 3807 :        {     // add eol node

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 3808 :        _New_node(_N_eol);

  00007 6a 03        push        3
  00009 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000c e8 00 00 00 00     call    ?_New_node@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEPAV_Node_base@2@W4_Node_type@2@@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_New_node

; 3809 :        }

  00011 8b e5        mov         esp, ebp
  00013 5d                 pop     ebp
  00014 c3                 ret     0
?_Add_eol@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXXZ ENDP ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_eol
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Add_bol@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Add_bol@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXXZ PROC ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_bol, COMDAT
; _this$ = ecx

; 3799 :        {     // add bol node

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 3800 :        _New_node(_N_bol);

  00007 6a 02        push        2
  00009 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000c e8 00 00 00 00     call    ?_New_node@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@AAEPAV_Node_base@2@W4_Node_type@2@@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_New_node

; 3801 :        }

  00011 8b e5        mov         esp, ebp
  00013 5d                 pop     ebp
  00014 c3                 ret     0
?_Add_bol@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXXZ ENDP ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_bol
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Getmark@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QBEPAV_Node_base@2@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Getmark@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QBEPAV_Node_base@2@XZ PROC ; std::_Builder<char const *,char,std::regex_traits<char> >::_Getmark, COMDAT
; _this$ = ecx

; 3737 :        {     // return current node

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 3738 :        return (_Current);

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a 8b 40 04   mov         eax, DWORD PTR [eax+4]

; 3739 :        }

  0000d 8b e5        mov         esp, ebp
  0000f 5d                 pop     ebp
  00010 c3                 ret     0
?_Getmark@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QBEPAV_Node_base@2@XZ ENDP ; std::_Builder<char const *,char,std::regex_traits<char> >::_Getmark
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Discard_pattern@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Discard_pattern@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXXZ PROC ; std::_Builder<char const *,char,std::regex_traits<char> >::_Discard_pattern, COMDAT
; _this$ = ecx

; 4194 :        {     // free memory

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 4195 :        _Destroy_node(_Root);

  00007 6a 00        push        0
  00009 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000c 8b 08        mov         ecx, DWORD PTR [eax]
  0000e 51                 push    ecx
  0000f e8 00 00 00 00     call    ?_Destroy_node@std@@YAXPAV_Node_base@1@0@Z ; std::_Destroy_node
  00014 83 c4 08   add         esp, 8

; 4196 :        _Root = 0;

  00017 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  0001a c7 02 00 00 00
        00           mov     DWORD PTR [edx], 0

; 4197 :        }

  00020 8b e5        mov         esp, ebp
  00022 5d                 pop     ebp
  00023 c3                 ret     0
?_Discard_pattern@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXXZ ENDP ; std::_Builder<char const *,char,std::regex_traits<char> >::_Discard_pattern
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Setlong@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Setlong@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXXZ PROC ; std::_Builder<char const *,char,std::regex_traits<char> >::_Setlong, COMDAT
; _this$ = ecx

; 3713 :        {     // set flag

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 3714 :        _Root->_Flags |= _Fl_longest;

  00007 6a 08        push        8
  00009 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000c 8b 08        mov         ecx, DWORD PTR [eax]
  0000e 83 c1 08   add         ecx, 8
  00011 51                 push    ecx
  00012 e8 00 00 00 00     call    ??_5std@@YA?AW4_Node_flags@0@AAW410@W410@@Z ; std::operator|=
  00017 83 c4 08   add         esp, 8

; 3715 :        }

  0001a 8b e5        mov         esp, ebp
  0001c 5d                 pop     ebp
  0001d c3                 ret     0
?_Setlong@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXXZ ENDP ; std::_Builder<char const *,char,std::regex_traits<char> >::_Setlong
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Beg_expr@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QBE_NXZ
_TEXT   SEGMENT
tv80 = -8                                         ; size = 4
_this$ = -4                                   ; size = 4
?_Beg_expr@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QBE_NXZ PROC ; std::_Builder<char const *,char,std::regex_traits<char> >::_Beg_expr, COMDAT
; _this$ = ecx

; 3756 :        {     // test for beginning of expression or subexpression

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 3757 :        return (_Beg_expr(_Current)

  00009 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000c 8b 48 04   mov         ecx, DWORD PTR [eax+4]
  0000f 51                 push    ecx
  00010 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00013 e8 00 00 00 00     call    ?_Beg_expr@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@ABE_NPAV_Node_base@2@@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Beg_expr
  00018 0f b6 d0   movzx       edx, al
  0001b 85 d2        test        edx, edx
  0001d 75 2e        jne         SHORT $LN4@Beg_expr
  0001f 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00022 8b 48 04   mov         ecx, DWORD PTR [eax+4]
  00025 83 79 04 02        cmp   DWORD PTR [ecx+4], 2
  00029 75 19        jne         SHORT $LN3@Beg_expr
  0002b 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  0002e 8b 42 04   mov         eax, DWORD PTR [edx+4]
  00031 8b 48 10   mov         ecx, DWORD PTR [eax+16]
  00034 51                 push    ecx
  00035 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00038 e8 00 00 00 00     call    ?_Beg_expr@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@ABE_NPAV_Node_base@2@@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Beg_expr
  0003d 0f b6 d0   movzx       edx, al
  00040 85 d2        test        edx, edx
  00042 75 09        jne         SHORT $LN4@Beg_expr
$LN3@Beg_expr:
  00044 c7 45 f8 00 00
        00 00          mov         DWORD PTR tv80[ebp], 0
  0004b eb 07        jmp         SHORT $LN5@Beg_expr
$LN4@Beg_expr:
  0004d c7 45 f8 01 00
        00 00          mov         DWORD PTR tv80[ebp], 1
$LN5@Beg_expr:
  00054 8a 45 f8   mov         al, BYTE PTR tv80[ebp]

; 3758 :              || (_Current->_Kind == _N_bol && _Beg_expr(_Current->_Prev)));
; 3759 :        }

  00057 8b e5        mov         esp, ebp
  00059 5d                 pop     ebp
  0005a c3                 ret     0
?_Beg_expr@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QBE_NXZ ENDP ; std::_Builder<char const *,char,std::regex_traits<char> >::_Beg_expr
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ??0?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAE@ABV?$regex_traits@D@1@W4syntax_option_type@regex_constants@1@@Z
_TEXT   SEGMENT
tv93 = -20                                          ; size = 4
tv87 = -16                                          ; size = 4
tv73 = -12                                          ; size = 4
$T1 = -8                                                ; size = 4
_this$ = -4                                   ; size = 4
__Tr$ = 8                                         ; size = 4
__Fx$ = 12                                          ; size = 4
??0?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAE@ABV?$regex_traits@D@1@W4syntax_option_type@regex_constants@1@@Z PROC ; std::_Builder<char const *,char,std::regex_traits<char> >::_Builder<char const *,char,std::regex_traits<char> >, COMDAT
; _this$ = ecx

; 3706 :        {     // construct

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 14   sub         esp, 20                        ; 00000014H
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 3700 :        : _Root(new _Root_node),

  00009 6a 24        push        36             ; 00000024H
  0000b e8 00 00 00 00     call    ??2@YAPAXI@Z   ; operator new
  00010 83 c4 04   add         esp, 4
  00013 89 45 f8   mov         DWORD PTR $T1[ebp], eax
  00016 83 7d f8 00        cmp   DWORD PTR $T1[ebp], 0
  0001a 74 0d        je  SHORT $LN3@Builder
  0001c 8b 4d f8   mov         ecx, DWORD PTR $T1[ebp]
  0001f e8 00 00 00 00     call    ??0_Root_node@std@@QAE@XZ ; std::_Root_node::_Root_node
  00024 89 45 f4   mov         DWORD PTR tv73[ebp], eax
  00027 eb 07        jmp         SHORT $LN4@Builder
$LN3@Builder:
  00029 c7 45 f4 00 00
        00 00          mov         DWORD PTR tv73[ebp], 0
$LN4@Builder:
  00030 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00033 8b 4d f4   mov         ecx, DWORD PTR tv73[ebp]
  00036 89 08        mov         DWORD PTR [eax], ecx

; 3701 :              _Current(_Root),

  00038 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  0003b 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0003e 8b 08        mov         ecx, DWORD PTR [eax]
  00040 89 4a 04   mov         DWORD PTR [edx+4], ecx

; 3702 :              _Flags(_Fx),

  00043 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  00046 8b 45 0c   mov         eax, DWORD PTR __Fx$[ebp]
  00049 89 42 08   mov         DWORD PTR [edx+8], eax

; 3703 :              _Traits(_Tr),

  0004c 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0004f 8b 55 08   mov         edx, DWORD PTR __Tr$[ebp]
  00052 89 51 0c   mov         DWORD PTR [ecx+12], edx

; 3704 :              _Bmax(static_cast<int>(_Fx & regex_constants::collate ? 0U : _Bmp_max)),

  00055 68 00 08 00 00     push    2048       ; 00000800H
  0005a 8b 45 0c   mov         eax, DWORD PTR __Fx$[ebp]
  0005d 50                 push    eax
  0005e e8 00 00 00 00     call    ??Iregex_constants@std@@YA?AW4syntax_option_type@01@W4201@0@Z ; std::regex_constants::operator&
  00063 83 c4 08   add         esp, 8
  00066 85 c0        test        eax, eax
  00068 74 09        je  SHORT $LN5@Builder
  0006a c7 45 f0 00 00
        00 00          mov         DWORD PTR tv87[ebp], 0
  00071 eb 07        jmp         SHORT $LN6@Builder
$LN5@Builder:
  00073 c7 45 f0 00 01
        00 00          mov         DWORD PTR tv87[ebp], 256 ; 00000100H
$LN6@Builder:
  0007a 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0007d 8b 55 f0   mov         edx, DWORD PTR tv87[ebp]
  00080 89 51 10   mov         DWORD PTR [ecx+16], edx

; 3705 :              _Tmax(static_cast<int>(_Fx & regex_constants::collate ? 0U : _ARRAY_THRESHOLD))

  00083 68 00 08 00 00     push    2048       ; 00000800H
  00088 8b 45 0c   mov         eax, DWORD PTR __Fx$[ebp]
  0008b 50                 push    eax
  0008c e8 00 00 00 00     call    ??Iregex_constants@std@@YA?AW4syntax_option_type@01@W4201@0@Z ; std::regex_constants::operator&
  00091 83 c4 08   add         esp, 8
  00094 85 c0        test        eax, eax
  00096 74 09        je  SHORT $LN7@Builder
  00098 c7 45 ec 00 00
        00 00          mov         DWORD PTR tv93[ebp], 0
  0009f eb 07        jmp         SHORT $LN8@Builder
$LN7@Builder:
  000a1 c7 45 ec 04 00
        00 00          mov         DWORD PTR tv93[ebp], 4
$LN8@Builder:
  000a8 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000ab 8b 55 ec   mov         edx, DWORD PTR tv93[ebp]
  000ae 89 51 14   mov         DWORD PTR [ecx+20], edx

; 3707 :        }

  000b1 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  000b4 8b e5        mov         esp, ebp
  000b6 5d                 pop     ebp
  000b7 c2 08 00   ret         8
??0?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAE@ABV?$regex_traits@D@1@W4syntax_option_type@regex_constants@1@@Z ENDP ; std::_Builder<char const *,char,std::regex_traits<char> >::_Builder<char const *,char,std::regex_traits<char> >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Disjunction@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ
_TEXT   SEGMENT
__Pos2$ = -20                                     ; size = 4
__Pos3$1 = -16                                      ; size = 4
__Pos3$2 = -12                                      ; size = 4
__Pos1$ = -8                                            ; size = 4
_this$ = -4                                   ; size = 4
?_Disjunction@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ PROC ; std::_Parser<char const *,char,std::regex_traits<char> >::_Disjunction, COMDAT
; _this$ = ecx

; 5719 :        {     // check for valid disjunction

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 14   sub         esp, 20                        ; 00000014H
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 5720 :        _Node_base *_Pos1 = _Nfa._Getmark();

  00009 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000c 83 c1 24   add         ecx, 36                        ; 00000024H
  0000f e8 00 00 00 00     call    ?_Getmark@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QBEPAV_Node_base@2@XZ ; std::_Builder<char const *,char,std::regex_traits<char> >::_Getmark
  00014 89 45 f8   mov         DWORD PTR __Pos1$[ebp], eax

; 5721 :        if (_Alternative())

  00017 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001a e8 00 00 00 00     call    ?_Alternative@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_NXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Alternative
  0001f 0f b6 c0   movzx       eax, al
  00022 85 c0        test        eax, eax
  00024 74 02        je  SHORT $LN4@Disjunctio
  00026 eb 2d        jmp         SHORT $LN5@Disjunctio
$LN4@Disjunctio:

; 5722 :              ;
; 5723 :        else if (_Mchar != _Meta_bar)

  00028 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0002b 83 79 4c 7c        cmp   DWORD PTR [ecx+76], 124    ; 0000007cH
  0002f 74 07        je  SHORT $LN6@Disjunctio

; 5724 :              return;     // zero-length alternative not followed by '|'

  00031 e9 83 00 00 00     jmp     $LN1@Disjunctio

; 5725 :        else

  00036 eb 1d        jmp         SHORT $LN5@Disjunctio
$LN6@Disjunctio:

; 5726 :              {   // zero-length leading alternative
; 5727 :              _Node_base *_Pos3 = _Nfa._Begin_group();

  00038 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0003b 83 c1 24   add         ecx, 36                        ; 00000024H
  0003e e8 00 00 00 00     call    ?_Begin_group@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Node_base@2@XZ ; std::_Builder<char const *,char,std::regex_traits<char> >::_Begin_group
  00043 89 45 f4   mov         DWORD PTR __Pos3$2[ebp], eax

; 5728 :              _Nfa._End_group(_Pos3);

  00046 8b 55 f4   mov         edx, DWORD PTR __Pos3$2[ebp]
  00049 52                 push    edx
  0004a 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0004d 83 c1 24   add         ecx, 36                        ; 00000024H
  00050 e8 00 00 00 00     call    ?_End_group@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXPAV_Node_base@2@@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_End_group
$LN5@Disjunctio:

; 5729 :              }
; 5730 :
; 5731 :        _Node_base *_Pos2 = _Nfa._Begin_if(_Pos1);

  00055 8b 45 f8   mov         eax, DWORD PTR __Pos1$[ebp]
  00058 50                 push    eax
  00059 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0005c 83 c1 24   add         ecx, 36                        ; 00000024H
  0005f e8 00 00 00 00     call    ?_Begin_if@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Node_base@2@PAV32@@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Begin_if
  00064 89 45 ec   mov         DWORD PTR __Pos2$[ebp], eax
$LN2@Disjunctio:

; 5732 :        while (_Mchar == _Meta_bar)

  00067 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0006a 83 79 4c 7c        cmp   DWORD PTR [ecx+76], 124    ; 0000007cH
  0006e 75 49        jne         SHORT $LN1@Disjunctio

; 5733 :              {   // append terms as long as we keep finding | characters
; 5734 :              _Next();

  00070 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00073 e8 00 00 00 00     call    ?_Next@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Next

; 5735 :              if (!_Alternative())

  00078 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0007b e8 00 00 00 00     call    ?_Alternative@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_NXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Alternative
  00080 0f b6 d0   movzx       edx, al
  00083 85 d2        test        edx, edx
  00085 75 1d        jne         SHORT $LN8@Disjunctio

; 5736 :                  {       // zero-length trailing alternative
; 5737 :                  _Node_base *_Pos3 = _Nfa._Begin_group();

  00087 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0008a 83 c1 24   add         ecx, 36                        ; 00000024H
  0008d e8 00 00 00 00     call    ?_Begin_group@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Node_base@2@XZ ; std::_Builder<char const *,char,std::regex_traits<char> >::_Begin_group
  00092 89 45 f0   mov         DWORD PTR __Pos3$1[ebp], eax

; 5738 :                  _Nfa._End_group(_Pos3);

  00095 8b 45 f0   mov         eax, DWORD PTR __Pos3$1[ebp]
  00098 50                 push    eax
  00099 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0009c 83 c1 24   add         ecx, 36                        ; 00000024H
  0009f e8 00 00 00 00     call    ?_End_group@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXPAV_Node_base@2@@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_End_group
$LN8@Disjunctio:

; 5739 :                  }
; 5740 :              _Nfa._Else_if(_Pos1, _Pos2);

  000a4 8b 4d ec   mov         ecx, DWORD PTR __Pos2$[ebp]
  000a7 51                 push    ecx
  000a8 8b 55 f8   mov         edx, DWORD PTR __Pos1$[ebp]
  000ab 52                 push    edx
  000ac 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000af 83 c1 24   add         ecx, 36                        ; 00000024H
  000b2 e8 00 00 00 00     call    ?_Else_if@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXPAV_Node_base@2@0@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Else_if

; 5741 :              }

  000b7 eb ae        jmp         SHORT $LN2@Disjunctio
$LN1@Disjunctio:

; 5742 :        }

  000b9 8b e5        mov         esp, ebp
  000bb 5d                 pop     ebp
  000bc c3                 ret     0
?_Disjunction@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ENDP ; std::_Parser<char const *,char,std::regex_traits<char> >::_Disjunction
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Alternative@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_NXZ
_TEXT   SEGMENT
_this$ = -8                                   ; size = 4
__Found$ = -2                                     ; size = 1
__Quant$1 = -1                                      ; size = 1
?_Alternative@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_NXZ PROC ; std::_Parser<char const *,char,std::regex_traits<char> >::_Alternative, COMDAT
; _this$ = ecx

; 5637 :        {     // check for valid alternative

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d f8   mov         DWORD PTR _this$[ebp], ecx

; 5638 :        bool _Found = false;

  00009 c6 45 fe 00        mov   BYTE PTR __Found$[ebp], 0
$LN4@Alternativ:

; 5639 :        for (; ; )
; 5640 :              {   // concatenate valid elements
; 5641 :              bool _Quant = true;

  0000d c6 45 ff 01        mov   BYTE PTR __Quant$1[ebp], 1

; 5642 :              if (_Mchar == _Meta_eos || _Mchar == _Meta_bar
; 5643 :                  || (_Mchar == _Meta_rpar && _Disj_count != 0))

  00011 8b 45 f8   mov         eax, DWORD PTR _this$[ebp]
  00014 83 78 4c ff        cmp   DWORD PTR [eax+76], -1
  00018 74 1b        je  SHORT $LN7@Alternativ
  0001a 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  0001d 83 79 4c 7c        cmp   DWORD PTR [ecx+76], 124    ; 0000007cH
  00021 74 12        je  SHORT $LN7@Alternativ
  00023 8b 55 f8   mov         edx, DWORD PTR _this$[ebp]
  00026 83 7a 4c 29        cmp   DWORD PTR [edx+76], 41     ; 00000029H
  0002a 75 16        jne         SHORT $LN5@Alternativ
  0002c 8b 45 f8   mov         eax, DWORD PTR _this$[ebp]
  0002f 83 78 10 00        cmp   DWORD PTR [eax+16], 0
  00033 74 0d        je  SHORT $LN5@Alternativ
$LN7@Alternativ:

; 5644 :                  return (_Found);

  00035 8a 45 fe   mov         al, BYTE PTR __Found$[ebp]
  00038 e9 27 02 00 00     jmp     $LN1@Alternativ
  0003d e9 09 02 00 00     jmp     $LN6@Alternativ
$LN5@Alternativ:

; 5645 :              else if (_Mchar == _Meta_rpar && !(_L_flags & _L_paren_bal))

  00042 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00045 83 79 4c 29        cmp   DWORD PTR [ecx+76], 41     ; 00000029H
  00049 75 1c        jne         SHORT $LN8@Alternativ
  0004b 8b 55 f8   mov         edx, DWORD PTR _this$[ebp]
  0004e 8b 42 50   mov         eax, DWORD PTR [edx+80]
  00051 25 00 00 00 10     and     eax, 268435456   ; 10000000H
  00056 75 0f        jne         SHORT $LN8@Alternativ

; 5646 :                  _Error(regex_constants::error_paren);

  00058 6a 05        push        5
  0005a 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  0005d e8 00 00 00 00     call    ?_Error@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_Error
  00062 e9 e4 01 00 00     jmp     $LN6@Alternativ
$LN8@Alternativ:

; 5647 :              else if (_Mchar == _Meta_dot)

  00067 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  0006a 83 79 4c 2e        cmp   DWORD PTR [ecx+76], 46     ; 0000002eH
  0006e 75 18        jne         SHORT $LN10@Alternativ

; 5648 :                  {       // add dot node
; 5649 :                  _Nfa._Add_dot();

  00070 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00073 83 c1 24   add         ecx, 36                        ; 00000024H
  00076 e8 00 00 00 00     call    ?_Add_dot@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXXZ ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_dot

; 5650 :                  _Next();

  0007b 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  0007e e8 00 00 00 00     call    ?_Next@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Next
  00083 e9 c3 01 00 00     jmp     $LN6@Alternativ
$LN10@Alternativ:

; 5651 :                  }
; 5652 :              else if (_Mchar == _Meta_esc)

  00088 8b 55 f8   mov         edx, DWORD PTR _this$[ebp]
  0008b 83 7a 4c 5c        cmp   DWORD PTR [edx+76], 92     ; 0000005cH
  0008f 0f 85 86 00 00
        00           jne     $LN12@Alternativ

; 5653 :                  {       // check for valid escape sequence
; 5654 :                  _Next();

  00095 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00098 e8 00 00 00 00     call    ?_Next@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Next

; 5655 :                  if ((_L_flags & _L_asrt_wrd) && _Char == _Esc_word)

  0009d 8b 45 f8   mov         eax, DWORD PTR _this$[ebp]
  000a0 8b 48 50   mov         ecx, DWORD PTR [eax+80]
  000a3 81 e1 80 00 00
        00           and     ecx, 128             ; 00000080H
  000a9 74 25        je  SHORT $LN14@Alternativ
  000ab 8b 55 f8   mov         edx, DWORD PTR _this$[ebp]
  000ae 0f be 42 48        movsx         eax, BYTE PTR [edx+72]
  000b2 83 f8 62   cmp         eax, 98                        ; 00000062H
  000b5 75 19        jne         SHORT $LN14@Alternativ

; 5656 :                          {       // add word assert
; 5657 :                          _Nfa._Add_wbound();

  000b7 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  000ba 83 c1 24   add         ecx, 36                        ; 00000024H
  000bd e8 00 00 00 00     call    ?_Add_wbound@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXXZ ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_wbound

; 5658 :                          _Next();

  000c2 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  000c5 e8 00 00 00 00     call    ?_Next@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Next

; 5659 :                          _Quant = false;

  000ca c6 45 ff 00        mov   BYTE PTR __Quant$1[ebp], 0
  000ce eb 46        jmp         SHORT $LN15@Alternativ
$LN14@Alternativ:

; 5660 :                          }
; 5661 :                  else if ((_L_flags & _L_asrt_wrd) && _Char == _Esc_not_word)

  000d0 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  000d3 8b 51 50   mov         edx, DWORD PTR [ecx+80]
  000d6 81 e2 80 00 00
        00           and     edx, 128             ; 00000080H
  000dc 74 30        je  SHORT $LN16@Alternativ
  000de 8b 45 f8   mov         eax, DWORD PTR _this$[ebp]
  000e1 0f be 48 48        movsx         ecx, BYTE PTR [eax+72]
  000e5 83 f9 42   cmp         ecx, 66                        ; 00000042H
  000e8 75 24        jne         SHORT $LN16@Alternativ

; 5662 :                          {       // add not-word assert
; 5663 :                          _Nfa._Add_wbound();

  000ea 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  000ed 83 c1 24   add         ecx, 36                        ; 00000024H
  000f0 e8 00 00 00 00     call    ?_Add_wbound@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXXZ ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_wbound

; 5664 :                          _Nfa._Negate();

  000f5 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  000f8 83 c1 24   add         ecx, 36                        ; 00000024H
  000fb e8 00 00 00 00     call    ?_Negate@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXXZ ; std::_Builder<char const *,char,std::regex_traits<char> >::_Negate

; 5665 :                          _Next();

  00100 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00103 e8 00 00 00 00     call    ?_Next@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Next

; 5666 :                          _Quant = false;

  00108 c6 45 ff 00        mov   BYTE PTR __Quant$1[ebp], 0

; 5667 :                          }
; 5668 :                  else

  0010c eb 08        jmp         SHORT $LN15@Alternativ
$LN16@Alternativ:

; 5669 :                          _AtomEscape();

  0010e 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00111 e8 00 00 00 00     call    ?_AtomEscape@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_AtomEscape
$LN15@Alternativ:
  00116 e9 30 01 00 00     jmp     $LN6@Alternativ
$LN12@Alternativ:

; 5670 :                  }
; 5671 :              else if (_Mchar == _Meta_lsq)

  0011b 8b 55 f8   mov         edx, DWORD PTR _this$[ebp]
  0011e 83 7a 4c 5b        cmp   DWORD PTR [edx+76], 91     ; 0000005bH
  00122 75 21        jne         SHORT $LN18@Alternativ

; 5672 :                  {       // add bracket expression
; 5673 :                  _Next();

  00124 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00127 e8 00 00 00 00     call    ?_Next@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Next

; 5674 :                  _CharacterClass();

  0012c 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  0012f e8 00 00 00 00     call    ?_CharacterClass@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_CharacterClass

; 5675 :                  _Expect(_Meta_rsq, regex_constants::error_brack);

  00134 6a 04        push        4
  00136 6a 5d        push        93             ; 0000005dH
  00138 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  0013b e8 00 00 00 00     call    ?_Expect@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXW4_Meta_type@2@W4error_type@regex_constants@2@@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_Expect
  00140 e9 06 01 00 00     jmp     $LN6@Alternativ
$LN18@Alternativ:

; 5676 :                  }
; 5677 :              else if (_Mchar == _Meta_lpar)

  00145 8b 45 f8   mov         eax, DWORD PTR _this$[ebp]
  00148 83 78 4c 28        cmp   DWORD PTR [eax+76], 40     ; 00000028H
  0014c 75 24        jne         SHORT $LN20@Alternativ

; 5678 :                  {       // check for valid group
; 5679 :                  _Next();

  0014e 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00151 e8 00 00 00 00     call    ?_Next@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Next

; 5680 :                  _Quant = _Wrapped_disjunction();

  00156 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00159 e8 00 00 00 00     call    ?_Wrapped_disjunction@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_NXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Wrapped_disjunction
  0015e 88 45 ff   mov         BYTE PTR __Quant$1[ebp], al

; 5681 :                  _Expect(_Meta_rpar, regex_constants::error_paren);

  00161 6a 05        push        5
  00163 6a 29        push        41             ; 00000029H
  00165 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00168 e8 00 00 00 00     call    ?_Expect@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXW4_Meta_type@2@W4error_type@regex_constants@2@@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_Expect
  0016d e9 d9 00 00 00     jmp     $LN6@Alternativ
$LN20@Alternativ:

; 5682 :                  }
; 5683 :              else if (_Mchar == _Meta_caret)

  00172 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00175 83 79 4c 5e        cmp   DWORD PTR [ecx+76], 94     ; 0000005eH
  00179 75 1c        jne         SHORT $LN22@Alternativ

; 5684 :                  {       // add bol node
; 5685 :                  _Nfa._Add_bol();

  0017b 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  0017e 83 c1 24   add         ecx, 36                        ; 00000024H
  00181 e8 00 00 00 00     call    ?_Add_bol@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXXZ ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_bol

; 5686 :                  _Next();

  00186 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00189 e8 00 00 00 00     call    ?_Next@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Next

; 5687 :                  _Quant = false;

  0018e c6 45 ff 00        mov   BYTE PTR __Quant$1[ebp], 0
  00192 e9 b4 00 00 00     jmp     $LN6@Alternativ
$LN22@Alternativ:

; 5688 :                  }
; 5689 :              else if (_Mchar == _Meta_dlr)

  00197 8b 55 f8   mov         edx, DWORD PTR _this$[ebp]
  0019a 83 7a 4c 24        cmp   DWORD PTR [edx+76], 36     ; 00000024H
  0019e 75 1c        jne         SHORT $LN24@Alternativ

; 5690 :                  {       // add eol node
; 5691 :                  _Nfa._Add_eol();

  001a0 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  001a3 83 c1 24   add         ecx, 36                        ; 00000024H
  001a6 e8 00 00 00 00     call    ?_Add_eol@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXXZ ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_eol

; 5692 :                  _Next();

  001ab 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  001ae e8 00 00 00 00     call    ?_Next@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Next

; 5693 :                  _Quant = false;

  001b3 c6 45 ff 00        mov   BYTE PTR __Quant$1[ebp], 0

; 5694 :                  }
; 5695 :              else if (_Mchar == _Meta_star

  001b7 e9 8f 00 00 00     jmp     $LN6@Alternativ
$LN24@Alternativ:

; 5696 :                  || _Mchar == _Meta_plus
; 5697 :                  || _Mchar == _Meta_query
; 5698 :                  || _Mchar == _Meta_lbr)

  001bc 8b 45 f8   mov         eax, DWORD PTR _this$[ebp]
  001bf 83 78 4c 2a        cmp   DWORD PTR [eax+76], 42     ; 0000002aH
  001c3 74 1b        je  SHORT $LN28@Alternativ
  001c5 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  001c8 83 79 4c 2b        cmp   DWORD PTR [ecx+76], 43     ; 0000002bH
  001cc 74 12        je  SHORT $LN28@Alternativ
  001ce 8b 55 f8   mov         edx, DWORD PTR _this$[ebp]
  001d1 83 7a 4c 3f        cmp   DWORD PTR [edx+76], 63     ; 0000003fH
  001d5 74 09        je  SHORT $LN28@Alternativ
  001d7 8b 45 f8   mov         eax, DWORD PTR _this$[ebp]
  001da 83 78 4c 7b        cmp   DWORD PTR [eax+76], 123    ; 0000007bH
  001de 75 0c        jne         SHORT $LN26@Alternativ
$LN28@Alternativ:

; 5699 :                  _Error(regex_constants::error_badrepeat);

  001e0 6a 0a        push        10             ; 0000000aH
  001e2 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  001e5 e8 00 00 00 00     call    ?_Error@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_Error
  001ea eb 5f        jmp         SHORT $LN6@Alternativ
$LN26@Alternativ:

; 5700 :              else if (_Mchar == _Meta_rbr && !(_L_flags & _L_paren_bal))

  001ec 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  001ef 83 79 4c 7d        cmp   DWORD PTR [ecx+76], 125    ; 0000007dH
  001f3 75 19        jne         SHORT $LN29@Alternativ
  001f5 8b 55 f8   mov         edx, DWORD PTR _this$[ebp]
  001f8 8b 42 50   mov         eax, DWORD PTR [edx+80]
  001fb 25 00 00 00 10     and     eax, 268435456   ; 10000000H
  00200 75 0c        jne         SHORT $LN29@Alternativ

; 5701 :                  _Error(regex_constants::error_brace);

  00202 6a 06        push        6
  00204 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00207 e8 00 00 00 00     call    ?_Error@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_Error
  0020c eb 3d        jmp         SHORT $LN6@Alternativ
$LN29@Alternativ:

; 5702 :              else if (_Mchar == _Meta_rsq && !(_L_flags & _L_paren_bal))

  0020e 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00211 83 79 4c 5d        cmp   DWORD PTR [ecx+76], 93     ; 0000005dH
  00215 75 19        jne         SHORT $LN31@Alternativ
  00217 8b 55 f8   mov         edx, DWORD PTR _this$[ebp]
  0021a 8b 42 50   mov         eax, DWORD PTR [edx+80]
  0021d 25 00 00 00 10     and     eax, 268435456   ; 10000000H
  00222 75 0c        jne         SHORT $LN31@Alternativ

; 5703 :                  _Error(regex_constants::error_brack);

  00224 6a 04        push        4
  00226 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00229 e8 00 00 00 00     call    ?_Error@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_Error

; 5704 :              else

  0022e eb 1b        jmp         SHORT $LN6@Alternativ
$LN31@Alternativ:

; 5705 :                  {       // add character
; 5706 :                  _Nfa._Add_char(_Char);

  00230 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00233 0f b6 51 48        movzx         edx, BYTE PTR [ecx+72]
  00237 52                 push    edx
  00238 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  0023b 83 c1 24   add         ecx, 36                        ; 00000024H
  0023e e8 00 00 00 00     call    ?_Add_char@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXD@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_char

; 5707 :                  _Next();

  00243 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00246 e8 00 00 00 00     call    ?_Next@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Next
$LN6@Alternativ:

; 5708 :                  }
; 5709 :              if (_Quant)

  0024b 0f b6 45 ff        movzx         eax, BYTE PTR __Quant$1[ebp]
  0024f 85 c0        test        eax, eax
  00251 74 08        je  SHORT $LN33@Alternativ

; 5710 :                  _Quantifier();

  00253 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00256 e8 00 00 00 00     call    ?_Quantifier@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Quantifier
$LN33@Alternativ:

; 5711 :              _Found = true;

  0025b c6 45 fe 01        mov   BYTE PTR __Found$[ebp], 1

; 5712 :              }

  0025f e9 a9 fd ff ff     jmp     $LN4@Alternativ
$LN1@Alternativ:

; 5713 :        }

  00264 8b e5        mov         esp, ebp
  00266 5d                 pop     ebp
  00267 c3                 ret     0
?_Alternative@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_NXZ ENDP ; std::_Parser<char const *,char,std::regex_traits<char> >::_Alternative
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Quantifier@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ
_TEXT   SEGMENT
__Min$ = -12                                            ; size = 4
__Max$ = -8                                   ; size = 4
_this$ = -4                                   ; size = 4
?_Quantifier@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ PROC ; std::_Parser<char const *,char,std::regex_traits<char> >::_Quantifier, COMDAT
; _this$ = ecx

; 5590 :        {     // check for quantifier following atom

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 0c   sub         esp, 12                        ; 0000000cH
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 5591 :        int _Min = 0;

  00009 c7 45 f4 00 00
        00 00          mov         DWORD PTR __Min$[ebp], 0

; 5592 :        int _Max = -1;

  00010 c7 45 f8 ff ff
        ff ff          mov         DWORD PTR __Max$[ebp], -1

; 5593 :        if (_Mchar == _Meta_star)

  00017 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0001a 83 78 4c 2a        cmp   DWORD PTR [eax+76], 42     ; 0000002aH
  0001e 75 05        jne         SHORT $LN2@Quantifier
  00020 e9 ce 00 00 00     jmp     $LN3@Quantifier
$LN2@Quantifier:

; 5594 :              ;
; 5595 :        else if (_Mchar == _Meta_plus)

  00025 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00028 83 79 4c 2b        cmp   DWORD PTR [ecx+76], 43     ; 0000002bH
  0002c 75 0c        jne         SHORT $LN4@Quantifier

; 5596 :              _Min = 1;

  0002e c7 45 f4 01 00
        00 00          mov         DWORD PTR __Min$[ebp], 1
  00035 e9 b9 00 00 00     jmp     $LN3@Quantifier
$LN4@Quantifier:

; 5597 :        else if (_Mchar == _Meta_query)

  0003a 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  0003d 83 7a 4c 3f        cmp   DWORD PTR [edx+76], 63     ; 0000003fH
  00041 75 0c        jne         SHORT $LN6@Quantifier

; 5598 :              _Max = 1;

  00043 c7 45 f8 01 00
        00 00          mov         DWORD PTR __Max$[ebp], 1
  0004a e9 a4 00 00 00     jmp     $LN3@Quantifier
$LN6@Quantifier:

; 5599 :        else if (_Mchar == _Meta_lbr)

  0004f 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00052 83 78 4c 7b        cmp   DWORD PTR [eax+76], 123    ; 0000007bH
  00056 0f 85 95 00 00
        00           jne     $LN8@Quantifier

; 5600 :              {   // check for valid bracketed value
; 5601 :              _Next();

  0005c 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0005f e8 00 00 00 00     call    ?_Next@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Next

; 5602 :              if (!_DecimalDigits())

  00064 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00067 e8 00 00 00 00     call    ?_DecimalDigits@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_NXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_DecimalDigits
  0006c 0f b6 c8   movzx       ecx, al
  0006f 85 c9        test        ecx, ecx
  00071 75 0a        jne         SHORT $LN10@Quantifier

; 5603 :                  _Error(regex_constants::error_badbrace);

  00073 6a 07        push        7
  00075 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00078 e8 00 00 00 00     call    ?_Error@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_Error
$LN10@Quantifier:

; 5604 :              _Min = _Val;

  0007d 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  00080 8b 42 44   mov         eax, DWORD PTR [edx+68]
  00083 89 45 f4   mov         DWORD PTR __Min$[ebp], eax

; 5605 :              if (_Mchar != _Meta_comma)

  00086 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00089 83 79 4c 2c        cmp   DWORD PTR [ecx+76], 44     ; 0000002cH
  0008d 74 08        je  SHORT $LN11@Quantifier

; 5606 :                  _Max = _Min;

  0008f 8b 55 f4   mov         edx, DWORD PTR __Min$[ebp]
  00092 89 55 f8   mov         DWORD PTR __Max$[ebp], edx

; 5607 :              else

  00095 eb 37        jmp         SHORT $LN12@Quantifier
$LN11@Quantifier:

; 5608 :                  {       // check for decimal constant following comma
; 5609 :                  _Next();

  00097 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0009a e8 00 00 00 00     call    ?_Next@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Next

; 5610 :                  if (_Mchar == _Meta_rbr)

  0009f 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  000a2 83 78 4c 7d        cmp   DWORD PTR [eax+76], 125    ; 0000007dH
  000a6 75 02        jne         SHORT $LN13@Quantifier
  000a8 eb 24        jmp         SHORT $LN12@Quantifier
$LN13@Quantifier:

; 5611 :                          ;
; 5612 :                  else if (!_DecimalDigits())

  000aa 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000ad e8 00 00 00 00     call    ?_DecimalDigits@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_NXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_DecimalDigits
  000b2 0f b6 c8   movzx       ecx, al
  000b5 85 c9        test        ecx, ecx
  000b7 75 0c        jne         SHORT $LN15@Quantifier

; 5613 :                          _Error(regex_constants::error_badbrace);

  000b9 6a 07        push        7
  000bb 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000be e8 00 00 00 00     call    ?_Error@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_Error

; 5614 :                  else

  000c3 eb 09        jmp         SHORT $LN12@Quantifier
$LN15@Quantifier:

; 5615 :                          _Max = _Val;

  000c5 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  000c8 8b 42 44   mov         eax, DWORD PTR [edx+68]
  000cb 89 45 f8   mov         DWORD PTR __Max$[ebp], eax
$LN12@Quantifier:

; 5616 :                  }
; 5617 :              if (_Mchar != _Meta_rbr || (_Max != -1 && _Max < _Min))

  000ce 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000d1 83 79 4c 7d        cmp   DWORD PTR [ecx+76], 125    ; 0000007dH
  000d5 75 0e        jne         SHORT $LN18@Quantifier
  000d7 83 7d f8 ff        cmp   DWORD PTR __Max$[ebp], -1
  000db 74 12        je  SHORT $LN17@Quantifier
  000dd 8b 55 f8   mov         edx, DWORD PTR __Max$[ebp]
  000e0 3b 55 f4   cmp         edx, DWORD PTR __Min$[ebp]
  000e3 7d 0a        jge         SHORT $LN17@Quantifier
$LN18@Quantifier:

; 5618 :                  _Error(regex_constants::error_badbrace);

  000e5 6a 07        push        7
  000e7 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000ea e8 00 00 00 00     call    ?_Error@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_Error
$LN17@Quantifier:

; 5619 :              }
; 5620 :        else

  000ef eb 02        jmp         SHORT $LN3@Quantifier
$LN8@Quantifier:

; 5621 :              return;

  000f1 eb 5e        jmp         SHORT $LN1@Quantifier
$LN3@Quantifier:

; 5622 :        _Nfa._Mark_final();

  000f3 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000f6 83 c1 24   add         ecx, 36                        ; 00000024H
  000f9 e8 00 00 00 00     call    ?_Mark_final@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXXZ ; std::_Builder<char const *,char,std::regex_traits<char> >::_Mark_final

; 5623 :        _Next();

  000fe 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00101 e8 00 00 00 00     call    ?_Next@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Next

; 5624 :        if ((_L_flags & _L_ngr_rep) && _Mchar == _Meta_query)

  00106 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00109 8b 48 50   mov         ecx, DWORD PTR [eax+80]
  0010c 81 e1 00 04 00
        00           and     ecx, 1024          ; 00000400H
  00112 74 28        je  SHORT $LN19@Quantifier
  00114 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  00117 83 7a 4c 3f        cmp   DWORD PTR [edx+76], 63     ; 0000003fH
  0011b 75 1f        jne         SHORT $LN19@Quantifier

; 5625 :              {   // add non-greedy repeat node
; 5626 :              _Next();

  0011d 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00120 e8 00 00 00 00     call    ?_Next@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Next

; 5627 :              _Nfa._Add_rep(_Min, _Max, false);

  00125 6a 00        push        0
  00127 8b 45 f8   mov         eax, DWORD PTR __Max$[ebp]
  0012a 50                 push    eax
  0012b 8b 4d f4   mov         ecx, DWORD PTR __Min$[ebp]
  0012e 51                 push    ecx
  0012f 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00132 83 c1 24   add         ecx, 36                        ; 00000024H
  00135 e8 00 00 00 00     call    ?_Add_rep@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXHH_N@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_rep

; 5628 :              }
; 5629 :        else

  0013a eb 15        jmp         SHORT $LN1@Quantifier
$LN19@Quantifier:

; 5630 :              _Nfa._Add_rep(_Min, _Max, true);

  0013c 6a 01        push        1
  0013e 8b 55 f8   mov         edx, DWORD PTR __Max$[ebp]
  00141 52                 push    edx
  00142 8b 45 f4   mov         eax, DWORD PTR __Min$[ebp]
  00145 50                 push    eax
  00146 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00149 83 c1 24   add         ecx, 36                        ; 00000024H
  0014c e8 00 00 00 00     call    ?_Add_rep@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXHH_N@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_rep
$LN1@Quantifier:

; 5631 :        }

  00151 8b e5        mov         esp, ebp
  00153 5d                 pop     ebp
  00154 c3                 ret     0
?_Quantifier@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ENDP ; std::_Parser<char const *,char,std::regex_traits<char> >::_Quantifier
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Wrapped_disjunction@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_NXZ
_TEXT   SEGMENT
__Ch$1 = -8                                   ; size = 4
_this$ = -4                                   ; size = 4
?_Wrapped_disjunction@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_NXZ PROC ; std::_Parser<char const *,char,std::regex_traits<char> >::_Wrapped_disjunction, COMDAT
; _this$ = ecx

; 5382 :        {     // add disjunction inside group

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 5383 :        ++_Disj_count;

  00009 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000c 8b 48 10   mov         ecx, DWORD PTR [eax+16]
  0000f 83 c1 01   add         ecx, 1
  00012 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  00015 89 4a 10   mov         DWORD PTR [edx+16], ecx

; 5384 :        if (!(_L_flags & _L_empty_grp) && _Mchar == _Meta_rpar)

  00018 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0001b 8b 48 50   mov         ecx, DWORD PTR [eax+80]
  0001e 81 e1 00 00 00
        08           and     ecx, 134217728   ; 08000000H
  00024 75 18        jne         SHORT $LN2@Wrapped_di
  00026 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  00029 83 7a 4c 29        cmp   DWORD PTR [edx+76], 41     ; 00000029H
  0002d 75 0f        jne         SHORT $LN2@Wrapped_di

; 5385 :              _Error(regex_constants::error_paren);

  0002f 6a 05        push        5
  00031 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00034 e8 00 00 00 00     call    ?_Error@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_Error
  00039 e9 c1 00 00 00     jmp     $LN3@Wrapped_di
$LN2@Wrapped_di:

; 5386 :        else if ((_L_flags & _L_nc_grp) && _Mchar == _Meta_query)

  0003e 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00041 8b 48 50   mov         ecx, DWORD PTR [eax+80]
  00044 83 e1 20   and         ecx, 32                        ; 00000020H
  00047 0f 84 88 00 00
        00           je      $LN4@Wrapped_di
  0004d 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  00050 83 7a 4c 3f        cmp   DWORD PTR [edx+76], 63     ; 0000003fH
  00054 75 7f        jne         SHORT $LN4@Wrapped_di

; 5387 :              {   // check for valid ECMAScript (?x ... ) group
; 5388 :              _Next();

  00056 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00059 e8 00 00 00 00     call    ?_Next@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Next

; 5389 :              _Meta_type _Ch =_Mchar;

  0005e 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00061 8b 48 4c   mov         ecx, DWORD PTR [eax+76]
  00064 89 4d f8   mov         DWORD PTR __Ch$1[ebp], ecx

; 5390 :              _Next();

  00067 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0006a e8 00 00 00 00     call    ?_Next@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Next

; 5391 :              if (_Ch == _Meta_colon)

  0006f 83 7d f8 3a        cmp   DWORD PTR __Ch$1[ebp], 58 ; 0000003aH
  00073 75 0a        jne         SHORT $LN6@Wrapped_di

; 5392 :                  _Do_noncapture_group();

  00075 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00078 e8 00 00 00 00     call    ?_Do_noncapture_group@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Do_noncapture_group
  0007d eb 54        jmp         SHORT $LN7@Wrapped_di
$LN6@Wrapped_di:

; 5393 :              else if (_Ch == _Meta_exc)

  0007f 83 7d f8 21        cmp   DWORD PTR __Ch$1[ebp], 33 ; 00000021H
  00083 75 1f        jne         SHORT $LN8@Wrapped_di

; 5394 :                  {       // process assert group, negating
; 5395 :                  _Do_assert_group(true);

  00085 6a 01        push        1
  00087 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0008a e8 00 00 00 00     call    ?_Do_assert_group@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEX_N@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_Do_assert_group

; 5396 :                  --_Disj_count;

  0008f 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  00092 8b 42 10   mov         eax, DWORD PTR [edx+16]
  00095 83 e8 01   sub         eax, 1
  00098 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0009b 89 41 10   mov         DWORD PTR [ecx+16], eax

; 5397 :                  return (false);

  0009e 32 c0        xor         al, al
  000a0 eb 6e        jmp         SHORT $LN1@Wrapped_di
  000a2 eb 2f        jmp         SHORT $LN7@Wrapped_di
$LN8@Wrapped_di:

; 5398 :                  }
; 5399 :              else if (_Ch == _Meta_equal)

  000a4 83 7d f8 3d        cmp   DWORD PTR __Ch$1[ebp], 61 ; 0000003dH
  000a8 75 1f        jne         SHORT $LN10@Wrapped_di

; 5400 :                  {       // process assert group
; 5401 :                  _Do_assert_group(false);

  000aa 6a 00        push        0
  000ac 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000af e8 00 00 00 00     call    ?_Do_assert_group@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEX_N@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_Do_assert_group

; 5402 :                  --_Disj_count;

  000b4 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  000b7 8b 42 10   mov         eax, DWORD PTR [edx+16]
  000ba 83 e8 01   sub         eax, 1
  000bd 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000c0 89 41 10   mov         DWORD PTR [ecx+16], eax

; 5403 :                  return (false);

  000c3 32 c0        xor         al, al
  000c5 eb 49        jmp         SHORT $LN1@Wrapped_di

; 5404 :                  }
; 5405 :              else

  000c7 eb 0a        jmp         SHORT $LN7@Wrapped_di
$LN10@Wrapped_di:

; 5406 :                  _Error(regex_constants::error_syntax);

  000c9 6a 0e        push        14             ; 0000000eH
  000cb 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000ce e8 00 00 00 00     call    ?_Error@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_Error
$LN7@Wrapped_di:
  000d3 eb 2a        jmp         SHORT $LN3@Wrapped_di
$LN4@Wrapped_di:

; 5407 :              }
; 5408 :        else if (_Flags & regex_constants::nosubs)

  000d5 68 00 02 00 00     push    512              ; 00000200H
  000da 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  000dd 8b 42 40   mov         eax, DWORD PTR [edx+64]
  000e0 50                 push    eax
  000e1 e8 00 00 00 00     call    ??Iregex_constants@std@@YA?AW4syntax_option_type@01@W4201@0@Z ; std::regex_constants::operator&
  000e6 83 c4 08   add         esp, 8
  000e9 85 c0        test        eax, eax
  000eb 74 0a        je  SHORT $LN12@Wrapped_di

; 5409 :              _Do_noncapture_group();

  000ed 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000f0 e8 00 00 00 00     call    ?_Do_noncapture_group@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Do_noncapture_group

; 5410 :        else

  000f5 eb 08        jmp         SHORT $LN3@Wrapped_di
$LN12@Wrapped_di:

; 5411 :              _Do_capture_group();

  000f7 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000fa e8 00 00 00 00     call    ?_Do_capture_group@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Do_capture_group
$LN3@Wrapped_di:

; 5412 :              --_Disj_count;

  000ff 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00102 8b 51 10   mov         edx, DWORD PTR [ecx+16]
  00105 83 ea 01   sub         edx, 1
  00108 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0010b 89 50 10   mov         DWORD PTR [eax+16], edx

; 5413 :        return (true);

  0010e b0 01        mov         al, 1
$LN1@Wrapped_di:

; 5414 :        }

  00110 8b e5        mov         esp, ebp
  00112 5d                 pop     ebp
  00113 c3                 ret     0
?_Wrapped_disjunction@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_NXZ ENDP ; std::_Parser<char const *,char,std::regex_traits<char> >::_Wrapped_disjunction
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Do_assert_group@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEX_N@Z
_TEXT   SEGMENT
__Pos1$ = -8                                            ; size = 4
_this$ = -4                                   ; size = 4
__Neg$ = 8                                          ; size = 1
?_Do_assert_group@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEX_N@Z PROC ; std::_Parser<char const *,char,std::regex_traits<char> >::_Do_assert_group, COMDAT
; _this$ = ecx

; 5372 :        {     // add assert group

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 5373 :        _Node_base *_Pos1 = _Nfa._Begin_assert_group(_Neg);

  00009 0f b6 45 08        movzx         eax, BYTE PTR __Neg$[ebp]
  0000d 50                 push    eax
  0000e 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00011 83 c1 24   add         ecx, 36                        ; 00000024H
  00014 e8 00 00 00 00     call    ?_Begin_assert_group@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Node_base@2@_N@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Begin_assert_group
  00019 89 45 f8   mov         DWORD PTR __Pos1$[ebp], eax

; 5374 :        _Disjunction();

  0001c 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001f e8 00 00 00 00     call    ?_Disjunction@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Disjunction

; 5375 :        _Nfa._End_assert_group(_Pos1);

  00024 8b 4d f8   mov         ecx, DWORD PTR __Pos1$[ebp]
  00027 51                 push    ecx
  00028 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0002b 83 c1 24   add         ecx, 36                        ; 00000024H
  0002e e8 00 00 00 00     call    ?_End_assert_group@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXPAV_Node_base@2@@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_End_assert_group

; 5376 :        }

  00033 8b e5        mov         esp, ebp
  00035 5d                 pop     ebp
  00036 c2 04 00   ret         4
?_Do_assert_group@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEX_N@Z ENDP ; std::_Parser<char const *,char,std::regex_traits<char> >::_Do_assert_group
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Do_noncapture_group@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ
_TEXT   SEGMENT
__Pos1$ = -8                                            ; size = 4
_this$ = -4                                   ; size = 4
?_Do_noncapture_group@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ PROC ; std::_Parser<char const *,char,std::regex_traits<char> >::_Do_noncapture_group, COMDAT
; _this$ = ecx

; 5362 :        {     // add non-capture group

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 5363 :        _Node_base *_Pos1 = _Nfa._Begin_group();

  00009 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000c 83 c1 24   add         ecx, 36                        ; 00000024H
  0000f e8 00 00 00 00     call    ?_Begin_group@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Node_base@2@XZ ; std::_Builder<char const *,char,std::regex_traits<char> >::_Begin_group
  00014 89 45 f8   mov         DWORD PTR __Pos1$[ebp], eax

; 5364 :        _Disjunction();

  00017 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001a e8 00 00 00 00     call    ?_Disjunction@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Disjunction

; 5365 :        _Nfa._End_group(_Pos1);

  0001f 8b 45 f8   mov         eax, DWORD PTR __Pos1$[ebp]
  00022 50                 push    eax
  00023 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00026 83 c1 24   add         ecx, 36                        ; 00000024H
  00029 e8 00 00 00 00     call    ?_End_group@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXPAV_Node_base@2@@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_End_group

; 5366 :        }

  0002e 8b e5        mov         esp, ebp
  00030 5d                 pop     ebp
  00031 c3                 ret     0
?_Do_noncapture_group@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ENDP ; std::_Parser<char const *,char,std::regex_traits<char> >::_Do_noncapture_group
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Do_capture_group@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ
_TEXT   SEGMENT
$T1 = -20                                         ; size = 8
__Pos1$ = -12                                     ; size = 4
tv69 = -8                                         ; size = 4
_this$ = -4                                   ; size = 4
?_Do_capture_group@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ PROC ; std::_Parser<char const *,char,std::regex_traits<char> >::_Do_capture_group, COMDAT
; _this$ = ecx

; 5348 :        {     // add capture group

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 14   sub         esp, 20                        ; 00000014H
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 5349 : //     if (_MAX_GRP <= ++_Grp_idx)
; 5350 : //       _Error(regex_constants::error_complexity);
; 5351 :        _Node_base *_Pos1 = _Nfa._Begin_capture_group(++_Grp_idx);

  00009 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000c 8b 48 0c   mov         ecx, DWORD PTR [eax+12]
  0000f 83 c1 01   add         ecx, 1
  00012 89 4d f8   mov         DWORD PTR tv69[ebp], ecx
  00015 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  00018 8b 45 f8   mov         eax, DWORD PTR tv69[ebp]
  0001b 89 42 0c   mov         DWORD PTR [edx+12], eax
  0001e 8b 4d f8   mov         ecx, DWORD PTR tv69[ebp]
  00021 51                 push    ecx
  00022 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00025 83 c1 24   add         ecx, 36                        ; 00000024H
  00028 e8 00 00 00 00     call    ?_Begin_capture_group@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Node_base@2@I@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Begin_capture_group
  0002d 89 45 f4   mov         DWORD PTR __Pos1$[ebp], eax

; 5352 :        _Disjunction();

  00030 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00033 e8 00 00 00 00     call    ?_Disjunction@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Disjunction

; 5353 :        _Nfa._End_group(_Pos1);

  00038 8b 55 f4   mov         edx, DWORD PTR __Pos1$[ebp]
  0003b 52                 push    edx
  0003c 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0003f 83 c1 24   add         ecx, 36                        ; 00000024H
  00042 e8 00 00 00 00     call    ?_End_group@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXPAV_Node_base@2@@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_End_group

; 5354 :        _Finished_grps.resize(_Grp_idx + 1);

  00047 6a 00        push        0
  00049 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0004c 8b 48 0c   mov         ecx, DWORD PTR [eax+12]
  0004f 83 c1 01   add         ecx, 1
  00052 51                 push    ecx
  00053 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00056 83 c1 14   add         ecx, 20                        ; 00000014H
  00059 e8 00 00 00 00     call    ?resize@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI_N@Z ; std::vector<bool,std::allocator<bool> >::resize

; 5355 :        _Finished_grps[((_Node_capture *)_Pos1)->_Idx] = true;

  0005e 6a 01        push        1
  00060 8b 55 f4   mov         edx, DWORD PTR __Pos1$[ebp]
  00063 8b 42 14   mov         eax, DWORD PTR [edx+20]
  00066 50                 push    eax
  00067 8d 4d ec   lea         ecx, DWORD PTR $T1[ebp]
  0006a 51                 push    ecx
  0006b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0006e 83 c1 14   add         ecx, 20                        ; 00000014H
  00071 e8 00 00 00 00     call    ??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
  00076 8b c8        mov         ecx, eax
  00078 e8 00 00 00 00     call    ??4?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@_N@Z ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator=

; 5356 :        }

  0007d 8b e5        mov         esp, ebp
  0007f 5d                 pop     ebp
  00080 c3                 ret     0
?_Do_capture_group@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ENDP ; std::_Parser<char const *,char,std::regex_traits<char> >::_Do_capture_group
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_AtomEscape@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ
_TEXT   SEGMENT
$T1 = -12                                         ; size = 8
_this$ = -4                                   ; size = 4
?_AtomEscape@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ PROC ; std::_Parser<char const *,char,std::regex_traits<char> >::_AtomEscape, COMDAT
; _this$ = ecx

; 5562 :        {     // check for valid atom escape

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 0c   sub         esp, 12                        ; 0000000cH
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 5563 :        if ((_L_flags & _L_bckr) && _DecimalDigits())

  00009 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000c 8b 48 50   mov         ecx, DWORD PTR [eax+80]
  0000f 81 e1 00 01 00
        00           and     ecx, 256             ; 00000100H
  00015 0f 84 c6 00 00
        00           je      $LN2@AtomEscape
  0001b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001e e8 00 00 00 00     call    ?_DecimalDigits@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_NXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_DecimalDigits
  00023 0f b6 d0   movzx       edx, al
  00026 85 d2        test        edx, edx
  00028 0f 84 b3 00 00
        00           je      $LN2@AtomEscape

; 5564 :              {   // check for valid back reference
; 5565 :              if (_Val == 0)

  0002e 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00031 83 78 44 00        cmp   DWORD PTR [eax+68], 0
  00035 75 2f        jne         SHORT $LN4@AtomEscape

; 5566 :                  {       // handle \0
; 5567 :                  if (!(_L_flags & _L_bzr_chr))

  00037 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0003a 8b 51 50   mov         edx, DWORD PTR [ecx+80]
  0003d 81 e2 00 00 10
        00           and     edx, 1048576         ; 00100000H
  00043 75 0c        jne         SHORT $LN6@AtomEscape

; 5568 :                          _Error(regex_constants::error_escape);

  00045 6a 02        push        2
  00047 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0004a e8 00 00 00 00     call    ?_Error@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_Error

; 5569 :                  else

  0004f eb 13        jmp         SHORT $LN7@AtomEscape
$LN6@AtomEscape:

; 5570 :                          _Nfa._Add_char((_Elem)_Val);

  00051 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00054 0f b6 48 44        movzx         ecx, BYTE PTR [eax+68]
  00058 51                 push    ecx
  00059 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0005c 83 c1 24   add         ecx, 36                        ; 00000024H
  0005f e8 00 00 00 00     call    ?_Add_char@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXD@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_char
$LN7@AtomEscape:

; 5571 :                  }
; 5572 :              else if (((_L_flags & _L_lim_bckr) && _BRE_MAX_GRP < _Val)

  00064 eb 79        jmp         SHORT $LN5@AtomEscape
$LN4@AtomEscape:

; 5573 :                  || _Grp_idx < _Val
; 5574 :                  || _Finished_grps.size() <= static_cast<size_t>(_Val)
; 5575 :                  || !_Finished_grps[_Val])

  00066 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  00069 8b 42 50   mov         eax, DWORD PTR [edx+80]
  0006c 25 00 02 00 00     and     eax, 512             ; 00000200H
  00071 74 09        je  SHORT $LN11@AtomEscape
  00073 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00076 83 79 44 09        cmp   DWORD PTR [ecx+68], 9
  0007a 77 45        ja  SHORT $LN10@AtomEscape
$LN11@AtomEscape:
  0007c 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  0007f 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00082 8b 4a 0c   mov         ecx, DWORD PTR [edx+12]
  00085 3b 48 44   cmp         ecx, DWORD PTR [eax+68]
  00088 7c 37        jl  SHORT $LN10@AtomEscape
  0008a 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0008d 83 c1 14   add         ecx, 20                        ; 00000014H
  00090 e8 00 00 00 00     call    ?size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<bool,std::allocator<bool> >::size
  00095 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  00098 3b 42 44   cmp         eax, DWORD PTR [edx+68]
  0009b 76 24        jbe         SHORT $LN10@AtomEscape
  0009d 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  000a0 8b 48 44   mov         ecx, DWORD PTR [eax+68]
  000a3 51                 push    ecx
  000a4 8d 55 f4   lea         edx, DWORD PTR $T1[ebp]
  000a7 52                 push    edx
  000a8 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000ab 83 c1 14   add         ecx, 20                        ; 00000014H
  000ae e8 00 00 00 00     call    ??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
  000b3 8b c8        mov         ecx, eax
  000b5 e8 00 00 00 00     call    ??B?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE_NXZ ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator bool
  000ba 0f b6 c0   movzx       eax, al
  000bd 85 c0        test        eax, eax
  000bf 75 0c        jne         SHORT $LN8@AtomEscape
$LN10@AtomEscape:

; 5576 :                  _Error(regex_constants::error_backref);

  000c1 6a 03        push        3
  000c3 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000c6 e8 00 00 00 00     call    ?_Error@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_Error

; 5577 :              else

  000cb eb 12        jmp         SHORT $LN5@AtomEscape
$LN8@AtomEscape:

; 5578 :                  _Nfa._Add_backreference(_Val);

  000cd 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000d0 8b 51 44   mov         edx, DWORD PTR [ecx+68]
  000d3 52                 push    edx
  000d4 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000d7 83 c1 24   add         ecx, 36                        ; 00000024H
  000da e8 00 00 00 00     call    ?_Add_backreference@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXI@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_backreference
$LN5@AtomEscape:
  000df eb 4d        jmp         SHORT $LN1@AtomEscape
$LN2@AtomEscape:

; 5579 :              }
; 5580 :        else if (_CharacterEscape())

  000e1 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000e4 e8 00 00 00 00     call    ?_CharacterEscape@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_NXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_CharacterEscape
  000e9 0f b6 c0   movzx       eax, al
  000ec 85 c0        test        eax, eax
  000ee 74 15        je  SHORT $LN12@AtomEscape

; 5581 :              _Nfa._Add_char((_Elem)_Val);

  000f0 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000f3 0f b6 51 44        movzx         edx, BYTE PTR [ecx+68]
  000f7 52                 push    edx
  000f8 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000fb 83 c1 24   add         ecx, 36                        ; 00000024H
  000fe e8 00 00 00 00     call    ?_Add_char@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXD@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_char
  00103 eb 29        jmp         SHORT $LN1@AtomEscape
$LN12@AtomEscape:

; 5582 :        else if (!(_L_flags & _L_esc_wsd) || !_CharacterClassEscape(true))

  00105 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00108 8b 48 50   mov         ecx, DWORD PTR [eax+80]
  0010b 81 e1 00 00 02
        00           and     ecx, 131072            ; 00020000H
  00111 74 11        je  SHORT $LN15@AtomEscape
  00113 6a 01        push        1
  00115 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00118 e8 00 00 00 00     call    ?_CharacterClassEscape@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_N_N@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_CharacterClassEscape
  0011d 0f b6 d0   movzx       edx, al
  00120 85 d2        test        edx, edx
  00122 75 0a        jne         SHORT $LN1@AtomEscape
$LN15@AtomEscape:

; 5583 :              _Error(regex_constants::error_escape);

  00124 6a 02        push        2
  00126 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00129 e8 00 00 00 00     call    ?_Error@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_Error
$LN1@AtomEscape:

; 5584 :        }

  0012e 8b e5        mov         esp, ebp
  00130 5d                 pop     ebp
  00131 c3                 ret     0
?_AtomEscape@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ENDP ; std::_Parser<char const *,char,std::regex_traits<char> >::_AtomEscape
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_CharacterEscape@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_NXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_CharacterEscape@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_NXZ PROC ; std::_Parser<char const *,char,std::regex_traits<char> >::_CharacterEscape, COMDAT
; _this$ = ecx

; 5518 :        {     // check for valid character escape

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 5519 :        if (_Mchar == _Meta_eos)

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a 83 78 4c ff        cmp   DWORD PTR [eax+76], -1
  0000e 75 0a        jne         SHORT $LN2@CharacterE

; 5520 :              _Error(regex_constants::error_escape);

  00010 6a 02        push        2
  00012 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00015 e8 00 00 00 00     call    ?_Error@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_Error
$LN2@CharacterE:

; 5521 :
; 5522 :        if ((_L_flags & _L_esc_ffn && _Do_ffn(_Char))
; 5523 :              || (_L_flags & _L_esc_ffnx && _Do_ffnx(_Char)))

  0001a 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001d 8b 51 50   mov         edx, DWORD PTR [ecx+80]
  00020 81 e2 00 00 01
        00           and     edx, 65536       ; 00010000H
  00026 74 17        je  SHORT $LN6@CharacterE
  00028 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0002b 0f b6 48 48        movzx         ecx, BYTE PTR [eax+72]
  0002f 51                 push    ecx
  00030 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00033 e8 00 00 00 00     call    ?_Do_ffn@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_ND@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_Do_ffn
  00038 0f b6 d0   movzx       edx, al
  0003b 85 d2        test        edx, edx
  0003d 75 25        jne         SHORT $LN5@CharacterE
$LN6@CharacterE:
  0003f 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00042 8b 48 50   mov         ecx, DWORD PTR [eax+80]
  00045 81 e1 00 80 00
        00           and     ecx, 32768       ; 00008000H
  0004b 74 24        je  SHORT $LN3@CharacterE
  0004d 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  00050 0f b6 42 48        movzx         eax, BYTE PTR [edx+72]
  00054 50                 push    eax
  00055 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00058 e8 00 00 00 00     call    ?_Do_ffnx@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_ND@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_Do_ffnx
  0005d 0f b6 c8   movzx       ecx, al
  00060 85 c9        test        ecx, ecx
  00062 74 0d        je  SHORT $LN3@CharacterE
$LN5@CharacterE:

; 5524 :              _Next();

  00064 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00067 e8 00 00 00 00     call    ?_Next@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Next
  0006c e9 0c 01 00 00     jmp     $LN4@CharacterE
$LN3@CharacterE:

; 5525 :        else if (_Char == _Esc_ctrl && (_L_flags & _L_esc_ctrl))

  00071 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  00074 0f be 42 48        movsx         eax, BYTE PTR [edx+72]
  00078 83 f8 63   cmp         eax, 99                        ; 00000063H
  0007b 75 69        jne         SHORT $LN7@CharacterE
  0007d 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00080 8b 51 50   mov         edx, DWORD PTR [ecx+80]
  00083 81 e2 00 00 04
        00           and     edx, 262144            ; 00040000H
  00089 74 5b        je  SHORT $LN7@CharacterE

; 5526 :              {   // handle control escape sequence
; 5527 :              _Next();

  0008b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0008e e8 00 00 00 00     call    ?_Next@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Next

; 5528 :              if (!_Traits.isctype(_Char, _RxTraits::_Ch_alpha))

  00093 68 03 01 00 00     push    259              ; 00000103H
  00098 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0009b 0f b6 48 48        movzx         ecx, BYTE PTR [eax+72]
  0009f 51                 push    ecx
  000a0 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  000a3 8b 4a 3c   mov         ecx, DWORD PTR [edx+60]
  000a6 e8 00 00 00 00     call    ?isctype@?$_Regex_traits@D@std@@QBE_NDF@Z ; std::_Regex_traits<char>::isctype
  000ab 0f b6 c0   movzx       eax, al
  000ae 85 c0        test        eax, eax
  000b0 75 0a        jne         SHORT $LN9@CharacterE

; 5529 :                  _Error(regex_constants::error_escape);

  000b2 6a 02        push        2
  000b4 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000b7 e8 00 00 00 00     call    ?_Error@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_Error
$LN9@CharacterE:

; 5530 :              _Val = (char)(_Char % 32);

  000bc 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000bf 0f be 51 48        movsx         edx, BYTE PTR [ecx+72]
  000c3 81 e2 1f 00 00
        80           and     edx, -2147483617       ; 8000001fH
  000c9 79 05        jns         SHORT $LN19@CharacterE
  000cb 4a                 dec     edx
  000cc 83 ca e0   or  edx, -32   ; ffffffe0H
  000cf 42                 inc     edx
$LN19@CharacterE:
  000d0 0f be c2   movsx       eax, dl
  000d3 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000d6 89 41 44   mov         DWORD PTR [ecx+68], eax

; 5531 :              _Next();

  000d9 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000dc e8 00 00 00 00     call    ?_Next@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Next
  000e1 e9 97 00 00 00     jmp     $LN4@CharacterE
$LN7@CharacterE:

; 5532 :              }
; 5533 :        else if (_Char == _Esc_hex && (_L_flags & _L_esc_hex))

  000e6 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  000e9 0f be 42 48        movsx         eax, BYTE PTR [edx+72]
  000ed 83 f8 78   cmp         eax, 120             ; 00000078H
  000f0 75 22        jne         SHORT $LN10@CharacterE
  000f2 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000f5 8b 51 50   mov         edx, DWORD PTR [ecx+80]
  000f8 81 e2 00 10 00
        00           and     edx, 4096          ; 00001000H
  000fe 74 14        je  SHORT $LN10@CharacterE

; 5534 :              {   // handle hexadecimal escape sequence
; 5535 :              _Next();

  00100 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00103 e8 00 00 00 00     call    ?_Next@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Next

; 5536 :              _HexDigits(2);

  00108 6a 02        push        2
  0010a 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0010d e8 00 00 00 00     call    ?_HexDigits@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXH@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_HexDigits
  00112 eb 69        jmp         SHORT $LN4@CharacterE
$LN10@CharacterE:

; 5537 :              }
; 5538 :        else if (_Char == _Esc_uni && (_L_flags & _L_esc_uni))

  00114 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00117 0f be 48 48        movsx         ecx, BYTE PTR [eax+72]
  0011b 83 f9 75   cmp         ecx, 117             ; 00000075H
  0011e 75 21        jne         SHORT $LN12@CharacterE
  00120 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  00123 8b 42 50   mov         eax, DWORD PTR [edx+80]
  00126 25 00 08 00 00     and     eax, 2048          ; 00000800H
  0012b 74 14        je  SHORT $LN12@CharacterE

; 5539 :              {   // handle unicode escape sequence
; 5540 :              _Next();

  0012d 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00130 e8 00 00 00 00     call    ?_Next@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Next

; 5541 :              _HexDigits(4);

  00135 6a 04        push        4
  00137 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0013a e8 00 00 00 00     call    ?_HexDigits@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXH@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_HexDigits
  0013f eb 3c        jmp         SHORT $LN4@CharacterE
$LN12@CharacterE:

; 5542 :              }
; 5543 :        else if ((_L_flags & _L_esc_oct) && _OctalDigits())

  00141 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00144 8b 51 50   mov         edx, DWORD PTR [ecx+80]
  00147 81 e2 00 20 00
        00           and     edx, 8192          ; 00002000H
  0014d 74 24        je  SHORT $LN14@CharacterE
  0014f 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00152 e8 00 00 00 00     call    ?_OctalDigits@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_NXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_OctalDigits
  00157 0f b6 c0   movzx       eax, al
  0015a 85 c0        test        eax, eax
  0015c 74 15        je  SHORT $LN14@CharacterE

; 5544 :              {   // handle octal escape sequence
; 5545 :              if (_Val == 0)

  0015e 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00161 83 79 44 00        cmp   DWORD PTR [ecx+68], 0
  00165 75 0a        jne         SHORT $LN16@CharacterE

; 5546 :                  _Error(regex_constants::error_escape);

  00167 6a 02        push        2
  00169 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0016c e8 00 00 00 00     call    ?_Error@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_Error
$LN16@CharacterE:

; 5547 :              }
; 5548 :        else

  00171 eb 0a        jmp         SHORT $LN4@CharacterE
$LN14@CharacterE:

; 5549 :              return (_IdentityEscape());

  00173 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00176 e8 00 00 00 00     call    ?_IdentityEscape@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_NXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_IdentityEscape
  0017b eb 29        jmp         SHORT $LN1@CharacterE
$LN4@CharacterE:

; 5550 :
; 5551 :        if ((numeric_limits<typename _RxTraits::_Uelem>::max)()
; 5552 :              < (unsigned int)_Val)

  0017d e8 00 00 00 00     call    ?max@?$numeric_limits@E@std@@SAEXZ ; std::numeric_limits<unsigned char>::max
  00182 0f b6 d0   movzx       edx, al
  00185 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00188 3b 50 44   cmp         edx, DWORD PTR [eax+68]
  0018b 73 0a        jae         SHORT $LN17@CharacterE

; 5553 :              _Error(regex_constants::error_escape);

  0018d 6a 02        push        2
  0018f 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00192 e8 00 00 00 00     call    ?_Error@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_Error
$LN17@CharacterE:

; 5554 :        _Val = (_Elem)_Val;

  00197 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0019a 0f be 51 44        movsx         edx, BYTE PTR [ecx+68]
  0019e 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  001a1 89 50 44   mov         DWORD PTR [eax+68], edx

; 5555 :        return (true);

  001a4 b0 01        mov         al, 1
$LN1@CharacterE:

; 5556 :        }

  001a6 8b e5        mov         esp, ebp
  001a8 5d                 pop     ebp
  001a9 c3                 ret     0
?_CharacterEscape@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_NXZ ENDP ; std::_Parser<char const *,char,std::regex_traits<char> >::_CharacterEscape
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Do_ffnx@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_ND@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Ch$ = 8                                         ; size = 1
?_Do_ffnx@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_ND@Z PROC ; std::_Parser<char const *,char,std::regex_traits<char> >::_Do_ffnx, COMDAT
; _this$ = ecx

; 5504 :        {     // check for the remaining file format escape characters

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 5505 :        if (_Ch == _Esc_ctrl_a)

  00007 0f be 45 08        movsx         eax, BYTE PTR __Ch$[ebp]
  0000b 83 f8 61   cmp         eax, 97                        ; 00000061H
  0000e 75 0c        jne         SHORT $LN2@Do_ffnx

; 5506 :              _Val = '\a';

  00010 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00013 c7 41 44 07 00
        00 00          mov         DWORD PTR [ecx+68], 7
  0001a eb 19        jmp         SHORT $LN3@Do_ffnx
$LN2@Do_ffnx:

; 5507 :        else if (_Ch == _Esc_ctrl_b)

  0001c 0f be 55 08        movsx         edx, BYTE PTR __Ch$[ebp]
  00020 83 fa 62   cmp         edx, 98                        ; 00000062H
  00023 75 0c        jne         SHORT $LN4@Do_ffnx

; 5508 :              _Val = '\b';

  00025 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00028 c7 40 44 08 00
        00 00          mov         DWORD PTR [eax+68], 8

; 5509 :        else

  0002f eb 04        jmp         SHORT $LN3@Do_ffnx
$LN4@Do_ffnx:

; 5510 :              return (false);

  00031 32 c0        xor         al, al
  00033 eb 02        jmp         SHORT $LN1@Do_ffnx
$LN3@Do_ffnx:

; 5511 :        return (true);

  00035 b0 01        mov         al, 1
$LN1@Do_ffnx:

; 5512 :        }

  00037 8b e5        mov         esp, ebp
  00039 5d                 pop     ebp
  0003a c2 04 00   ret         4
?_Do_ffnx@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_ND@Z ENDP ; std::_Parser<char const *,char,std::regex_traits<char> >::_Do_ffnx
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Do_ffn@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_ND@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Ch$ = 8                                         ; size = 1
?_Do_ffn@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_ND@Z PROC ; std::_Parser<char const *,char,std::regex_traits<char> >::_Do_ffn, COMDAT
; _this$ = ecx

; 5484 :        {     // check for limited file format escape characters

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 5485 :        if (_Ch == _Esc_ctrl_f)

  00007 0f be 45 08        movsx         eax, BYTE PTR __Ch$[ebp]
  0000b 83 f8 66   cmp         eax, 102             ; 00000066H
  0000e 75 0c        jne         SHORT $LN2@Do_ffn

; 5486 :              _Val = '\f';

  00010 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00013 c7 41 44 0c 00
        00 00          mov         DWORD PTR [ecx+68], 12 ; 0000000cH
  0001a eb 58        jmp         SHORT $LN3@Do_ffn
$LN2@Do_ffn:

; 5487 :        else if (_Ch == _Esc_ctrl_n)

  0001c 0f be 55 08        movsx         edx, BYTE PTR __Ch$[ebp]
  00020 83 fa 6e   cmp         edx, 110             ; 0000006eH
  00023 75 0c        jne         SHORT $LN4@Do_ffn

; 5488 :              _Val = '\n';

  00025 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00028 c7 40 44 0a 00
        00 00          mov         DWORD PTR [eax+68], 10 ; 0000000aH
  0002f eb 43        jmp         SHORT $LN3@Do_ffn
$LN4@Do_ffn:

; 5489 :        else if (_Ch == _Esc_ctrl_r)

  00031 0f be 4d 08        movsx         ecx, BYTE PTR __Ch$[ebp]
  00035 83 f9 72   cmp         ecx, 114             ; 00000072H
  00038 75 0c        jne         SHORT $LN6@Do_ffn

; 5490 :              _Val = '\r';

  0003a 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  0003d c7 42 44 0d 00
        00 00          mov         DWORD PTR [edx+68], 13 ; 0000000dH
  00044 eb 2e        jmp         SHORT $LN3@Do_ffn
$LN6@Do_ffn:

; 5491 :        else if (_Ch == _Esc_ctrl_t)

  00046 0f be 45 08        movsx         eax, BYTE PTR __Ch$[ebp]
  0004a 83 f8 74   cmp         eax, 116             ; 00000074H
  0004d 75 0c        jne         SHORT $LN8@Do_ffn

; 5492 :              _Val = '\t';

  0004f 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00052 c7 41 44 09 00
        00 00          mov         DWORD PTR [ecx+68], 9
  00059 eb 19        jmp         SHORT $LN3@Do_ffn
$LN8@Do_ffn:

; 5493 :        else if (_Ch == _Esc_ctrl_v)

  0005b 0f be 55 08        movsx         edx, BYTE PTR __Ch$[ebp]
  0005f 83 fa 76   cmp         edx, 118             ; 00000076H
  00062 75 0c        jne         SHORT $LN10@Do_ffn

; 5494 :              _Val = '\v';

  00064 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00067 c7 40 44 0b 00
        00 00          mov         DWORD PTR [eax+68], 11 ; 0000000bH

; 5495 :        else

  0006e eb 04        jmp         SHORT $LN3@Do_ffn
$LN10@Do_ffn:

; 5496 :              return (false);

  00070 32 c0        xor         al, al
  00072 eb 02        jmp         SHORT $LN1@Do_ffn
$LN3@Do_ffn:

; 5497 :        return (true);

  00074 b0 01        mov         al, 1
$LN1@Do_ffn:

; 5498 :        }

  00076 8b e5        mov         esp, ebp
  00078 5d                 pop     ebp
  00079 c2 04 00   ret         4
?_Do_ffn@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_ND@Z ENDP ; std::_Parser<char const *,char,std::regex_traits<char> >::_Do_ffn
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_IsIdentityEscape@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@ABE_NXZ
_TEXT   SEGMENT
tv83 = -20                                          ; size = 4
tv78 = -16                                          ; size = 4
tv74 = -12                                          ; size = 4
tv69 = -8                                         ; size = 4
_this$ = -4                                   ; size = 4
?_IsIdentityEscape@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@ABE_NXZ PROC ; std::_Parser<char const *,char,std::regex_traits<char> >::_IsIdentityEscape, COMDAT
; _this$ = ecx

; 5420 :        {     // check for valid identity escape

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 14   sub         esp, 20                        ; 00000014H
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 5421 :        if (_L_flags & _L_ident_ECMA)

  00009 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000c 8b 48 50   mov         ecx, DWORD PTR [eax+80]
  0000f 81 e1 00 00 40
        00           and     ecx, 4194304         ; 00400000H
  00015 74 32        je  SHORT $LN6@IsIdentity

; 5422 :              // ECMAScript identity escape characters
; 5423 :              switch (_Char)

  00017 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  0001a 0f be 42 48        movsx         eax, BYTE PTR [edx+72]
  0001e 89 45 f8   mov         DWORD PTR tv69[ebp], eax
  00021 8b 4d f8   mov         ecx, DWORD PTR tv69[ebp]
  00024 83 e9 44   sub         ecx, 68                        ; 00000044H
  00027 89 4d f8   mov         DWORD PTR tv69[ebp], ecx
  0002a 83 7d f8 33        cmp   DWORD PTR tv69[ebp], 51    ; 00000033H
  0002e 77 15        ja  SHORT $LN8@IsIdentity
  00030 8b 55 f8   mov         edx, DWORD PTR tv69[ebp]
  00033 0f b6 82 00 00
        00 00          movzx       eax, BYTE PTR $LN18@IsIdentity[edx]
  0003a ff 24 85 00 00
        00 00          jmp         DWORD PTR $LN20@IsIdentity[eax*4]
$LN7@IsIdentity:

; 5424 :                  {
; 5425 :                  case 'c':       // ASCII control character
; 5426 :                  case 'd':       // digit
; 5427 :                  case 'D':
; 5428 :                  case 's':       // whitespace
; 5429 :                  case 'S':
; 5430 :                  case 'w':       // word character
; 5431 :                  case 'W':
; 5432 :                          return (false);

  00041 32 c0        xor         al, al
  00043 eb 79        jmp         SHORT $LN1@IsIdentity
$LN8@IsIdentity:

; 5433 :                  default:
; 5434 :                          return (true);

  00045 b0 01        mov         al, 1
  00047 eb 75        jmp         SHORT $LN1@IsIdentity
$LN6@IsIdentity:

; 5435 :                  }
; 5436 :
; 5437 :        switch (_Char)

  00049 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0004c 0f be 51 48        movsx         edx, BYTE PTR [ecx+72]
  00050 89 55 f4   mov         DWORD PTR tv74[ebp], edx
  00053 8b 45 f4   mov         eax, DWORD PTR tv74[ebp]
  00056 83 e8 22   sub         eax, 34                        ; 00000022H
  00059 89 45 f4   mov         DWORD PTR tv74[ebp], eax
  0005c 83 7d f4 5b        cmp   DWORD PTR tv74[ebp], 91    ; 0000005bH
  00060 77 5a        ja  SHORT $LN12@IsIdentity
  00062 8b 4d f4   mov         ecx, DWORD PTR tv74[ebp]
  00065 0f b6 91 00 00
        00 00          movzx       edx, BYTE PTR $LN19@IsIdentity[ecx]
  0006c ff 24 95 00 00
        00 00          jmp         DWORD PTR $LN21@IsIdentity[edx*4]
$LN9@IsIdentity:

; 5438 :              {
; 5439 :              case _Meta_dot:
; 5440 :              case _Meta_lsq:
; 5441 :              case _Meta_esc:
; 5442 :              case _Meta_star:
; 5443 :              case _Meta_bar:
; 5444 :              case _Meta_caret:
; 5445 :              case _Meta_dlr:
; 5446 :                  // BRE, ERE, awk identity escape characters
; 5447 :                  return (true);

  00073 b0 01        mov         al, 1
  00075 eb 47        jmp         SHORT $LN1@IsIdentity
$LN10@IsIdentity:

; 5448 :              case _Meta_lpar:
; 5449 :              case _Meta_rpar:
; 5450 :              case _Meta_plus:
; 5451 :              case _Meta_query:
; 5452 :              case _Meta_lbr:
; 5453 :              case _Meta_rbr:
; 5454 :                  // additional ERE identity escape characters
; 5455 :                  return ((_L_flags & _L_ident_ERE) != 0);

  00077 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0007a 8b 48 50   mov         ecx, DWORD PTR [eax+80]
  0007d 81 e1 00 00 80
        00           and     ecx, 8388608         ; 00800000H
  00083 74 09        je  SHORT $LN14@IsIdentity
  00085 c7 45 f0 01 00
        00 00          mov         DWORD PTR tv78[ebp], 1
  0008c eb 07        jmp         SHORT $LN15@IsIdentity
$LN14@IsIdentity:
  0008e c7 45 f0 00 00
        00 00          mov         DWORD PTR tv78[ebp], 0
$LN15@IsIdentity:
  00095 8a 45 f0   mov         al, BYTE PTR tv78[ebp]
  00098 eb 24        jmp         SHORT $LN1@IsIdentity
$LN11@IsIdentity:

; 5456 :              case '"':
; 5457 :              case '/':
; 5458 :                  // additional awk identity escape characters
; 5459 :                  return ((_L_flags & _L_ident_awk) != 0);

  0009a 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  0009d 8b 42 50   mov         eax, DWORD PTR [edx+80]
  000a0 25 00 00 00 01     and     eax, 16777216      ; 01000000H
  000a5 74 09        je  SHORT $LN16@IsIdentity
  000a7 c7 45 ec 01 00
        00 00          mov         DWORD PTR tv83[ebp], 1
  000ae eb 07        jmp         SHORT $LN17@IsIdentity
$LN16@IsIdentity:
  000b0 c7 45 ec 00 00
        00 00          mov         DWORD PTR tv83[ebp], 0
$LN17@IsIdentity:
  000b7 8a 45 ec   mov         al, BYTE PTR tv83[ebp]
  000ba eb 02        jmp         SHORT $LN1@IsIdentity
$LN12@IsIdentity:

; 5460 :              default:
; 5461 :                  return (false);

  000bc 32 c0        xor         al, al
$LN1@IsIdentity:

; 5462 :              }
; 5463 :        }

  000be 8b e5        mov         esp, ebp
  000c0 5d                 pop     ebp
  000c1 c3                 ret     0
  000c2 66 90        npad        2
$LN20@IsIdentity:
  000c4 00 00 00 00        DD    $LN7@IsIdentity
  000c8 00 00 00 00        DD    $LN8@IsIdentity
$LN18@IsIdentity:
  000cc 00                 DB      0
  000cd 01                 DB      1
  000ce 01                 DB      1
  000cf 01                 DB      1
  000d0 01                 DB      1
  000d1 01                 DB      1
  000d2 01                 DB      1
  000d3 01                 DB      1
  000d4 01                 DB      1
  000d5 01                 DB      1
  000d6 01                 DB      1
  000d7 01                 DB      1
  000d8 01                 DB      1
  000d9 01                 DB      1
  000da 01                 DB      1
  000db 00                 DB      0
  000dc 01                 DB      1
  000dd 01                 DB      1
  000de 01                 DB      1
  000df 00                 DB      0
  000e0 01                 DB      1
  000e1 01                 DB      1
  000e2 01                 DB      1
  000e3 01                 DB      1
  000e4 01                 DB      1
  000e5 01                 DB      1
  000e6 01                 DB      1
  000e7 01                 DB      1
  000e8 01                 DB      1
  000e9 01                 DB      1
  000ea 01                 DB      1
  000eb 00                 DB      0
  000ec 00                 DB      0
  000ed 01                 DB      1
  000ee 01                 DB      1
  000ef 01                 DB      1
  000f0 01                 DB      1
  000f1 01                 DB      1
  000f2 01                 DB      1
  000f3 01                 DB      1
  000f4 01                 DB      1
  000f5 01                 DB      1
  000f6 01                 DB      1
  000f7 01                 DB      1
  000f8 01                 DB      1
  000f9 01                 DB      1
  000fa 01                 DB      1
  000fb 00                 DB      0
  000fc 01                 DB      1
  000fd 01                 DB      1
  000fe 01                 DB      1
  000ff 00                 DB      0
$LN21@IsIdentity:
  00100 00 00 00 00        DD    $LN11@IsIdentity
  00104 00 00 00 00        DD    $LN9@IsIdentity
  00108 00 00 00 00        DD    $LN10@IsIdentity
  0010c 00 00 00 00        DD    $LN12@IsIdentity
$LN19@IsIdentity:
  00110 00                 DB      0
  00111 03                 DB      3
  00112 01                 DB      1
  00113 03                 DB      3
  00114 03                 DB      3
  00115 03                 DB      3
  00116 02                 DB      2
  00117 02                 DB      2
  00118 01                 DB      1
  00119 02                 DB      2
  0011a 03                 DB      3
  0011b 03                 DB      3
  0011c 01                 DB      1
  0011d 00                 DB      0
  0011e 03                 DB      3
  0011f 03                 DB      3
  00120 03                 DB      3
  00121 03                 DB      3
  00122 03                 DB      3
  00123 03                 DB      3
  00124 03                 DB      3
  00125 03                 DB      3
  00126 03                 DB      3
  00127 03                 DB      3
  00128 03                 DB      3
  00129 03                 DB      3
  0012a 03                 DB      3
  0012b 03                 DB      3
  0012c 03                 DB      3
  0012d 02                 DB      2
  0012e 03                 DB      3
  0012f 03                 DB      3
  00130 03                 DB      3
  00131 03                 DB      3
  00132 03                 DB      3
  00133 03                 DB      3
  00134 03                 DB      3
  00135 03                 DB      3
  00136 03                 DB      3
  00137 03                 DB      3
  00138 03                 DB      3
  00139 03                 DB      3
  0013a 03                 DB      3
  0013b 03                 DB      3
  0013c 03                 DB      3
  0013d 03                 DB      3
  0013e 03                 DB      3
  0013f 03                 DB      3
  00140 03                 DB      3
  00141 03                 DB      3
  00142 03                 DB      3
  00143 03                 DB      3
  00144 03                 DB      3
  00145 03                 DB      3
  00146 03                 DB      3
  00147 03                 DB      3
  00148 03                 DB      3
  00149 01                 DB      1
  0014a 01                 DB      1
  0014b 03                 DB      3
  0014c 01                 DB      1
  0014d 03                 DB      3
  0014e 03                 DB      3
  0014f 03                 DB      3
  00150 03                 DB      3
  00151 03                 DB      3
  00152 03                 DB      3
  00153 03                 DB      3
  00154 03                 DB      3
  00155 03                 DB      3
  00156 03                 DB      3
  00157 03                 DB      3
  00158 03                 DB      3
  00159 03                 DB      3
  0015a 03                 DB      3
  0015b 03                 DB      3
  0015c 03                 DB      3
  0015d 03                 DB      3
  0015e 03                 DB      3
  0015f 03                 DB      3
  00160 03                 DB      3
  00161 03                 DB      3
  00162 03                 DB      3
  00163 03                 DB      3
  00164 03                 DB      3
  00165 03                 DB      3
  00166 03                 DB      3
  00167 03                 DB      3
  00168 03                 DB      3
  00169 02                 DB      2
  0016a 01                 DB      1
  0016b 02                 DB      2
?_IsIdentityEscape@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@ABE_NXZ ENDP ; std::_Parser<char const *,char,std::regex_traits<char> >::_IsIdentityEscape
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_IdentityEscape@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_NXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_IdentityEscape@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_NXZ PROC ; std::_Parser<char const *,char,std::regex_traits<char> >::_IdentityEscape, COMDAT
; _this$ = ecx

; 5469 :        {     // check whether an escape is valid, and process it if so

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 5470 :        if (_IsIdentityEscape())

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_IsIdentityEscape@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@ABE_NXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_IsIdentityEscape
  0000f 0f b6 c0   movzx       eax, al
  00012 85 c0        test        eax, eax
  00014 74 1b        je  SHORT $LN2@IdentityEs

; 5471 :              {
; 5472 :              _Val = _Char;

  00016 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00019 0f be 51 48        movsx         edx, BYTE PTR [ecx+72]
  0001d 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00020 89 50 44   mov         DWORD PTR [eax+68], edx

; 5473 :              _Next();

  00023 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00026 e8 00 00 00 00     call    ?_Next@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Next

; 5474 :              return (true);

  0002b b0 01        mov         al, 1
  0002d eb 04        jmp         SHORT $LN1@IdentityEs

; 5475 :              }
; 5476 :        else

  0002f eb 02        jmp         SHORT $LN1@IdentityEs
$LN2@IdentityEs:

; 5477 :              return (false);

  00031 32 c0        xor         al, al
$LN1@IdentityEs:

; 5478 :        }

  00033 8b e5        mov         esp, ebp
  00035 5d                 pop     ebp
  00036 c3                 ret     0
?_IdentityEscape@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_NXZ ENDP ; std::_Parser<char const *,char,std::regex_traits<char> >::_IdentityEscape
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_CharacterClass@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_CharacterClass@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ PROC ; std::_Parser<char const *,char,std::regex_traits<char> >::_CharacterClass, COMDAT
; _this$ = ecx

; 5329 :        {     // add bracket expression

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 5330 :        _Nfa._Add_class();

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a 83 c1 24   add         ecx, 36                        ; 00000024H
  0000d e8 00 00 00 00     call    ?_Add_class@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXXZ ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_class

; 5331 :        if (_Mchar == _Meta_caret)

  00012 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00015 83 78 4c 5e        cmp   DWORD PTR [eax+76], 94     ; 0000005eH
  00019 75 13        jne         SHORT $LN2@CharacterC

; 5332 :              {   // negate bracket expression
; 5333 :              _Nfa._Negate();

  0001b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001e 83 c1 24   add         ecx, 36                        ; 00000024H
  00021 e8 00 00 00 00     call    ?_Negate@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXXZ ; std::_Builder<char const *,char,std::regex_traits<char> >::_Negate

; 5334 :              _Next();

  00026 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00029 e8 00 00 00 00     call    ?_Next@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Next
$LN2@CharacterC:

; 5335 :              }
; 5336 :        if ((_L_flags & _L_brk_rstr) && _Mchar == _Meta_rsq)

  0002e 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00031 8b 51 50   mov         edx, DWORD PTR [ecx+80]
  00034 81 e2 00 00 00
        20           and     edx, 536870912   ; 20000000H
  0003a 74 1e        je  SHORT $LN3@CharacterC
  0003c 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0003f 83 78 4c 5d        cmp   DWORD PTR [eax+76], 93     ; 0000005dH
  00043 75 15        jne         SHORT $LN3@CharacterC

; 5337 :              {   // insert initial ] when not special
; 5338 :              _Nfa._Add_char_to_class(_Meta_rsq);

  00045 6a 5d        push        93             ; 0000005dH
  00047 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0004a 83 c1 24   add         ecx, 36                        ; 00000024H
  0004d e8 00 00 00 00     call    ?_Add_char_to_class@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXD@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_char_to_class

; 5339 :              _Next();

  00052 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00055 e8 00 00 00 00     call    ?_Next@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Next
$LN3@CharacterC:

; 5340 :              }
; 5341 :        _ClassRanges();

  0005a 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0005d e8 00 00 00 00     call    ?_ClassRanges@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_ClassRanges

; 5342 :        }

  00062 8b e5        mov         esp, ebp
  00064 5d                 pop     ebp
  00065 c3                 ret     0
?_CharacterClass@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ENDP ; std::_Parser<char const *,char,std::regex_traits<char> >::_CharacterClass
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_ClassRanges@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ
_TEXT   SEGMENT
__Ret$ = -12                                            ; size = 4
_this$ = -8                                   ; size = 4
__Chr1$1 = -1                                     ; size = 1
?_ClassRanges@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ PROC ; std::_Parser<char const *,char,std::regex_traits<char> >::_ClassRanges, COMDAT
; _this$ = ecx

; 5287 :        {     // check for valid class ranges

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 0c   sub         esp, 12                        ; 0000000cH
  00006 89 4d f8   mov         DWORD PTR _this$[ebp], ecx
$LN4@ClassRange:

; 5288 :        _Prs_ret _Ret;
; 5289 :
; 5290 :        for (; ; )
; 5291 :              {   // process characters through end of bracket expression
; 5292 :              if ((_Ret = _ClassAtom()) == _Prs_none)

  00009 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  0000c e8 00 00 00 00     call    ?_ClassAtom@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE?AW4_Prs_ret@2@XZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_ClassAtom
  00011 89 45 f4   mov         DWORD PTR __Ret$[ebp], eax
  00014 83 7d f4 00        cmp   DWORD PTR __Ret$[ebp], 0
  00018 75 0a        jne         SHORT $LN5@ClassRange

; 5293 :                  return;

  0001a e9 30 01 00 00     jmp     $LN1@ClassRange
  0001f e9 26 01 00 00     jmp     $LN6@ClassRange
$LN5@ClassRange:

; 5294 :              else if (_Ret == _Prs_set)

  00024 83 7d f4 02        cmp   DWORD PTR __Ret$[ebp], 2
  00028 75 05        jne         SHORT $LN7@ClassRange
  0002a e9 1b 01 00 00     jmp     $LN6@ClassRange
$LN7@ClassRange:

; 5295 :                  ;
; 5296 :              else if (_Val == 0 && !(_L_flags & _L_bzr_chr))

  0002f 8b 45 f8   mov         eax, DWORD PTR _this$[ebp]
  00032 83 78 44 00        cmp   DWORD PTR [eax+68], 0
  00036 75 1d        jne         SHORT $LN9@ClassRange
  00038 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  0003b 8b 51 50   mov         edx, DWORD PTR [ecx+80]
  0003e 81 e2 00 00 10
        00           and     edx, 1048576         ; 00100000H
  00044 75 0f        jne         SHORT $LN9@ClassRange

; 5297 :                  _Error(regex_constants::error_escape);

  00046 6a 02        push        2
  00048 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  0004b e8 00 00 00 00     call    ?_Error@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_Error
  00050 e9 f5 00 00 00     jmp     $LN6@ClassRange
$LN9@ClassRange:

; 5298 :              else if (_Mchar == _Meta_dash)

  00055 8b 45 f8   mov         eax, DWORD PTR _this$[ebp]
  00058 83 78 4c 2d        cmp   DWORD PTR [eax+76], 45     ; 0000002dH
  0005c 0f 85 d5 00 00
        00           jne     $LN11@ClassRange

; 5299 :                  {       // check for valid range
; 5300 :                  _Next();

  00062 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00065 e8 00 00 00 00     call    ?_Next@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Next

; 5301 :                  _Elem _Chr1 = (_Elem)_Val;

  0006a 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  0006d 8a 51 44   mov         dl, BYTE PTR [ecx+68]
  00070 88 55 ff   mov         BYTE PTR __Chr1$1[ebp], dl

; 5302 :                  if ((_Ret = _ClassAtom()) == _Prs_none)

  00073 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00076 e8 00 00 00 00     call    ?_ClassAtom@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE?AW4_Prs_ret@2@XZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_ClassAtom
  0007b 89 45 f4   mov         DWORD PTR __Ret$[ebp], eax
  0007e 83 7d f4 00        cmp   DWORD PTR __Ret$[ebp], 0
  00082 75 27        jne         SHORT $LN13@ClassRange

; 5303 :                          {       // treat - as ordinary character
; 5304 :                          _Nfa._Add_char_to_class((_Elem)_Val);

  00084 8b 45 f8   mov         eax, DWORD PTR _this$[ebp]
  00087 0f b6 48 44        movzx         ecx, BYTE PTR [eax+68]
  0008b 51                 push    ecx
  0008c 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  0008f 83 c1 24   add         ecx, 36                        ; 00000024H
  00092 e8 00 00 00 00     call    ?_Add_char_to_class@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXD@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_char_to_class

; 5305 :                          _Nfa._Add_char_to_class(_Meta_dash);

  00097 6a 2d        push        45             ; 0000002dH
  00099 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  0009c 83 c1 24   add         ecx, 36                        ; 00000024H
  0009f e8 00 00 00 00     call    ?_Add_char_to_class@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXD@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_char_to_class

; 5306 :                          return;

  000a4 e9 a6 00 00 00     jmp     $LN1@ClassRange
  000a9 eb 59        jmp         SHORT $LN14@ClassRange
$LN13@ClassRange:

; 5307 :                          }
; 5308 :                  else if (_Ret == _Prs_set)

  000ab 83 7d f4 02        cmp   DWORD PTR __Ret$[ebp], 2
  000af 75 0c        jne         SHORT $LN15@ClassRange

; 5309 :                          _Error(regex_constants::error_range);   // set follows dash

  000b1 6a 08        push        8
  000b3 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  000b6 e8 00 00 00 00     call    ?_Error@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_Error
  000bb eb 47        jmp         SHORT $LN14@ClassRange
$LN15@ClassRange:

; 5310 :                  else if (_Flags & regex_constants::collate)

  000bd 68 00 08 00 00     push    2048       ; 00000800H
  000c2 8b 55 f8   mov         edx, DWORD PTR _this$[ebp]
  000c5 8b 42 40   mov         eax, DWORD PTR [edx+64]
  000c8 50                 push    eax
  000c9 e8 00 00 00 00     call    ??Iregex_constants@std@@YA?AW4syntax_option_type@01@W4201@0@Z ; std::regex_constants::operator&
  000ce 83 c4 08   add         esp, 8
  000d1 85 c0        test        eax, eax
  000d3 74 2f        je  SHORT $LN14@ClassRange

; 5311 :                          {       // translate ends of range
; 5312 :                          _Val = _Traits.translate((_Elem)_Val);

  000d5 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  000d8 0f b6 51 44        movzx         edx, BYTE PTR [ecx+68]
  000dc 52                 push    edx
  000dd 8b 45 f8   mov         eax, DWORD PTR _this$[ebp]
  000e0 8b 48 3c   mov         ecx, DWORD PTR [eax+60]
  000e3 e8 00 00 00 00     call    ?translate@?$_Regex_traits@D@std@@QBEDD@Z ; std::_Regex_traits<char>::translate
  000e8 0f be c8   movsx       ecx, al
  000eb 8b 55 f8   mov         edx, DWORD PTR _this$[ebp]
  000ee 89 4a 44   mov         DWORD PTR [edx+68], ecx

; 5313 :                          _Chr1 = _Traits.translate(_Chr1);

  000f1 0f b6 45 ff        movzx         eax, BYTE PTR __Chr1$1[ebp]
  000f5 50                 push    eax
  000f6 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  000f9 8b 49 3c   mov         ecx, DWORD PTR [ecx+60]
  000fc e8 00 00 00 00     call    ?translate@?$_Regex_traits@D@std@@QBEDD@Z ; std::_Regex_traits<char>::translate
  00101 88 45 ff   mov         BYTE PTR __Chr1$1[ebp], al
$LN14@ClassRange:

; 5314 :                          }
; 5315 :                  if ((typename _RxTraits::_Uelem)_Val
; 5316 :                          < (typename _RxTraits::_Uelem)_Chr1)

  00104 8b 55 f8   mov         edx, DWORD PTR _this$[ebp]
  00107 0f b6 42 44        movzx         eax, BYTE PTR [edx+68]
  0010b 0f b6 4d ff        movzx         ecx, BYTE PTR __Chr1$1[ebp]
  0010f 3b c1        cmp         eax, ecx
  00111 7d 0a        jge         SHORT $LN18@ClassRange

; 5317 :                          _Error(regex_constants::error_range);

  00113 6a 08        push        8
  00115 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00118 e8 00 00 00 00     call    ?_Error@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_Error
$LN18@ClassRange:

; 5318 :                  _Nfa._Add_range(_Chr1, (_Elem)_Val);

  0011d 8b 55 f8   mov         edx, DWORD PTR _this$[ebp]
  00120 0f b6 42 44        movzx         eax, BYTE PTR [edx+68]
  00124 50                 push    eax
  00125 0f b6 4d ff        movzx         ecx, BYTE PTR __Chr1$1[ebp]
  00129 51                 push    ecx
  0012a 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  0012d 83 c1 24   add         ecx, 36                        ; 00000024H
  00130 e8 00 00 00 00     call    ?_Add_range@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXDD@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_range

; 5319 :                  }
; 5320 :              else

  00135 eb 13        jmp         SHORT $LN6@ClassRange
$LN11@ClassRange:

; 5321 :                  _Nfa._Add_char_to_class((_Elem)_Val);

  00137 8b 55 f8   mov         edx, DWORD PTR _this$[ebp]
  0013a 0f b6 42 44        movzx         eax, BYTE PTR [edx+68]
  0013e 50                 push    eax
  0013f 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00142 83 c1 24   add         ecx, 36                        ; 00000024H
  00145 e8 00 00 00 00     call    ?_Add_char_to_class@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXD@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_char_to_class
$LN6@ClassRange:

; 5322 :              }

  0014a e9 ba fe ff ff     jmp     $LN4@ClassRange
$LN1@ClassRange:

; 5323 :        }

  0014f 8b e5        mov         esp, ebp
  00151 5d                 pop     ebp
  00152 c3                 ret     0
?_ClassRanges@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ENDP ; std::_Parser<char const *,char,std::regex_traits<char> >::_ClassRanges
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_ClassAtom@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE?AW4_Prs_ret@2@XZ
_TEXT   SEGMENT
__St$1 = -8                                   ; size = 4
_this$ = -4                                   ; size = 4
?_ClassAtom@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE?AW4_Prs_ret@2@XZ PROC ; std::_Parser<char const *,char,std::regex_traits<char> >::_ClassAtom, COMDAT
; _this$ = ecx

; 5240 :        {     // check for class atom

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 5241 :        if (_Mchar == _Meta_esc)

  00009 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000c 83 78 4c 5c        cmp   DWORD PTR [eax+76], 92     ; 0000005cH
  00010 0f 85 9b 00 00
        00           jne     $LN2@ClassAtom

; 5242 :              {   // check for valid escape sequence
; 5243 :              _Next();

  00016 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00019 e8 00 00 00 00     call    ?_Next@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Next

; 5244 :              if (_L_flags & _L_grp_esc)

  0001e 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00021 8b 51 50   mov         edx, DWORD PTR [ecx+80]
  00024 81 e2 00 00 20
        00           and     edx, 2097152         ; 00200000H
  0002a 74 11        je  SHORT $LN4@ClassAtom

; 5245 :                  return (_ClassEscape(false));

  0002c 6a 00        push        0
  0002e 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00031 e8 00 00 00 00     call    ?_ClassEscape@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE?AW4_Prs_ret@2@_N@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_ClassEscape
  00036 e9 0d 01 00 00     jmp     $LN1@ClassAtom

; 5246 :              else if ((_L_flags & _L_esc_ffn && _Do_ffn(_Char))

  0003b eb 5b        jmp         SHORT $LN5@ClassAtom
$LN4@ClassAtom:

; 5247 :                  || (_L_flags & _L_esc_ffnx && _Do_ffnx(_Char)))

  0003d 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00040 8b 48 50   mov         ecx, DWORD PTR [eax+80]
  00043 81 e1 00 00 01
        00           and     ecx, 65536       ; 00010000H
  00049 74 17        je  SHORT $LN8@ClassAtom
  0004b 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  0004e 0f b6 42 48        movzx         eax, BYTE PTR [edx+72]
  00052 50                 push    eax
  00053 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00056 e8 00 00 00 00     call    ?_Do_ffn@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_ND@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_Do_ffn
  0005b 0f b6 c8   movzx       ecx, al
  0005e 85 c9        test        ecx, ecx
  00060 75 24        jne         SHORT $LN7@ClassAtom
$LN8@ClassAtom:
  00062 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  00065 8b 42 50   mov         eax, DWORD PTR [edx+80]
  00068 25 00 80 00 00     and     eax, 32768       ; 00008000H
  0006d 74 29        je  SHORT $LN5@ClassAtom
  0006f 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00072 0f b6 51 48        movzx         edx, BYTE PTR [ecx+72]
  00076 52                 push    edx
  00077 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0007a e8 00 00 00 00     call    ?_Do_ffnx@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_ND@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_Do_ffnx
  0007f 0f b6 c0   movzx       eax, al
  00082 85 c0        test        eax, eax
  00084 74 12        je  SHORT $LN5@ClassAtom
$LN7@ClassAtom:

; 5248 :                  {       // advance to next character
; 5249 :                  _Next();

  00086 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00089 e8 00 00 00 00     call    ?_Next@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Next

; 5250 :                  return (_Prs_chr);

  0008e b8 01 00 00 00     mov     eax, 1
  00093 e9 b0 00 00 00     jmp     $LN1@ClassAtom
$LN5@ClassAtom:

; 5251 :                  }
; 5252 :              _Val = _Meta_esc;

  00098 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0009b c7 41 44 5c 00
        00 00          mov         DWORD PTR [ecx+68], 92 ; 0000005cH

; 5253 :              return (_Prs_chr);

  000a2 b8 01 00 00 00     mov     eax, 1
  000a7 e9 9c 00 00 00     jmp     $LN1@ClassAtom
  000ac e9 97 00 00 00     jmp     $LN1@ClassAtom
$LN2@ClassAtom:

; 5254 :              }
; 5255 :        else if (_Mchar == _Meta_lsq)

  000b1 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  000b4 83 7a 4c 5b        cmp   DWORD PTR [edx+76], 91     ; 0000005bH
  000b8 75 5c        jne         SHORT $LN9@ClassAtom

; 5256 :              {   // check for valid delimited expression
; 5257 :              _Next();

  000ba 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000bd e8 00 00 00 00     call    ?_Next@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Next

; 5258 :              if (_Mchar == _Meta_colon
; 5259 :                  || _Mchar == _Meta_equal
; 5260 :                  || _Mchar == _Meta_dot)

  000c2 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  000c5 83 78 4c 3a        cmp   DWORD PTR [eax+76], 58     ; 0000003aH
  000c9 74 12        je  SHORT $LN13@ClassAtom
  000cb 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000ce 83 79 4c 3d        cmp   DWORD PTR [ecx+76], 61     ; 0000003dH
  000d2 74 09        je  SHORT $LN13@ClassAtom
  000d4 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  000d7 83 7a 4c 2e        cmp   DWORD PTR [edx+76], 46     ; 0000002eH
  000db 75 26        jne         SHORT $LN11@ClassAtom
$LN13@ClassAtom:

; 5261 :                  {       // handle delimited expression
; 5262 :                  _Meta_type _St = _Mchar;

  000dd 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  000e0 8b 48 4c   mov         ecx, DWORD PTR [eax+76]
  000e3 89 4d f8   mov         DWORD PTR __St$1[ebp], ecx

; 5263 :                  _Next();

  000e6 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000e9 e8 00 00 00 00     call    ?_Next@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Next

; 5264 :                  _Do_ex_class(_St);

  000ee 8b 55 f8   mov         edx, DWORD PTR __St$1[ebp]
  000f1 52                 push    edx
  000f2 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000f5 e8 00 00 00 00     call    ?_Do_ex_class@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXW4_Meta_type@2@@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_Do_ex_class

; 5265 :                  return (_Prs_set);

  000fa b8 02 00 00 00     mov     eax, 2
  000ff eb 47        jmp         SHORT $LN1@ClassAtom

; 5266 :                  }
; 5267 :              else

  00101 eb 11        jmp         SHORT $LN12@ClassAtom
$LN11@ClassAtom:

; 5268 :                  {       // handle ordinary [
; 5269 :                  _Val = _Meta_lsq;

  00103 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00106 c7 40 44 5b 00
        00 00          mov         DWORD PTR [eax+68], 91 ; 0000005bH

; 5270 :                  return (_Prs_chr);

  0010d b8 01 00 00 00     mov     eax, 1
  00112 eb 34        jmp         SHORT $LN1@ClassAtom
$LN12@ClassAtom:

; 5271 :                  }

  00114 eb 32        jmp         SHORT $LN1@ClassAtom
$LN9@ClassAtom:

; 5272 :              }
; 5273 :        else if (_Mchar == _Meta_rsq || _Mchar == _Meta_eos)

  00116 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00119 83 79 4c 5d        cmp   DWORD PTR [ecx+76], 93     ; 0000005dH
  0011d 74 09        je  SHORT $LN16@ClassAtom
  0011f 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  00122 83 7a 4c ff        cmp   DWORD PTR [edx+76], -1
  00126 75 06        jne         SHORT $LN14@ClassAtom
$LN16@ClassAtom:

; 5274 :              return (_Prs_none);

  00128 33 c0        xor         eax, eax
  0012a eb 1c        jmp         SHORT $LN1@ClassAtom

; 5275 :        else

  0012c eb 1a        jmp         SHORT $LN1@ClassAtom
$LN14@ClassAtom:

; 5276 :              {   // handle ordinary character
; 5277 :              _Val = _Char;

  0012e 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00131 0f be 48 48        movsx         ecx, BYTE PTR [eax+72]
  00135 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  00138 89 4a 44   mov         DWORD PTR [edx+68], ecx

; 5278 :              _Next();

  0013b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0013e e8 00 00 00 00     call    ?_Next@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Next

; 5279 :              return (_Prs_chr);

  00143 b8 01 00 00 00     mov     eax, 1
$LN1@ClassAtom:

; 5280 :              }
; 5281 :        }

  00148 8b e5        mov         esp, ebp
  0014a 5d                 pop     ebp
  0014b c3                 ret     0
?_ClassAtom@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE?AW4_Prs_ret@2@XZ ENDP ; std::_Parser<char const *,char,std::regex_traits<char> >::_ClassAtom
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_ClassEscape@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE?AW4_Prs_ret@2@_N@Z
_TEXT   SEGMENT
tv92 = -8                                         ; size = 4
_this$ = -4                                   ; size = 4
__Addit$ = 8                                            ; size = 1
?_ClassEscape@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE?AW4_Prs_ret@2@_N@Z PROC ; std::_Parser<char const *,char,std::regex_traits<char> >::_ClassEscape, COMDAT
; _this$ = ecx

; 5217 :        {     // check for class escape

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 5218 :        if ((_L_flags & _L_esc_bsl)
; 5219 :              && _Char == _Esc_bsl)

  00009 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000c 8b 48 50   mov         ecx, DWORD PTR [eax+80]
  0000f 81 e1 00 40 00
        00           and     ecx, 16384       ; 00004000H
  00015 74 27        je  SHORT $LN2@ClassEscap
  00017 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  0001a 0f be 42 48        movsx         eax, BYTE PTR [edx+72]
  0001e 83 f8 5c   cmp         eax, 92                        ; 0000005cH
  00021 75 1b        jne         SHORT $LN2@ClassEscap

; 5220 :              {   // handle escape backslash if allowed
; 5221 :              _Val = _Esc_bsl;

  00023 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00026 c7 41 44 5c 00
        00 00          mov         DWORD PTR [ecx+68], 92 ; 0000005cH

; 5222 :              _Next();

  0002d 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00030 e8 00 00 00 00     call    ?_Next@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Next

; 5223 :              return (_Prs_chr);

  00035 b8 01 00 00 00     mov     eax, 1
  0003a eb 77        jmp         SHORT $LN1@ClassEscap
  0003c eb 53        jmp         SHORT $LN3@ClassEscap
$LN2@ClassEscap:

; 5224 :              }
; 5225 :        else if ((_L_flags & _L_esc_wsd) && _CharacterClassEscape(_Addit))

  0003e 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  00041 8b 42 50   mov         eax, DWORD PTR [edx+80]
  00044 25 00 00 02 00     and     eax, 131072            ; 00020000H
  00049 74 1d        je  SHORT $LN4@ClassEscap
  0004b 0f b6 4d 08        movzx         ecx, BYTE PTR __Addit$[ebp]
  0004f 51                 push    ecx
  00050 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00053 e8 00 00 00 00     call    ?_CharacterClassEscape@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_N_N@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_CharacterClassEscape
  00058 0f b6 d0   movzx       edx, al
  0005b 85 d2        test        edx, edx
  0005d 74 09        je  SHORT $LN4@ClassEscap

; 5226 :              return (_Prs_set);

  0005f b8 02 00 00 00     mov     eax, 2
  00064 eb 4d        jmp         SHORT $LN1@ClassEscap
  00066 eb 29        jmp         SHORT $LN3@ClassEscap
$LN4@ClassEscap:

; 5227 :        else if (_DecimalDigits())

  00068 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0006b e8 00 00 00 00     call    ?_DecimalDigits@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_NXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_DecimalDigits
  00070 0f b6 c0   movzx       eax, al
  00073 85 c0        test        eax, eax
  00075 74 1a        je  SHORT $LN3@ClassEscap

; 5228 :              {   // check for invalid value
; 5229 :              if (_Val != 0)

  00077 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0007a 83 79 44 00        cmp   DWORD PTR [ecx+68], 0
  0007e 74 0a        je  SHORT $LN7@ClassEscap

; 5230 :                  _Error(regex_constants::error_escape);

  00080 6a 02        push        2
  00082 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00085 e8 00 00 00 00     call    ?_Error@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_Error
$LN7@ClassEscap:

; 5231 :              return (_Prs_chr);

  0008a b8 01 00 00 00     mov     eax, 1
  0008f eb 22        jmp         SHORT $LN1@ClassEscap
$LN3@ClassEscap:

; 5232 :              }
; 5233 :        return (_CharacterEscape() ? _Prs_chr : _Prs_none);

  00091 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00094 e8 00 00 00 00     call    ?_CharacterEscape@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_NXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_CharacterEscape
  00099 0f b6 d0   movzx       edx, al
  0009c 85 d2        test        edx, edx
  0009e 74 09        je  SHORT $LN9@ClassEscap
  000a0 c7 45 f8 01 00
        00 00          mov         DWORD PTR tv92[ebp], 1
  000a7 eb 07        jmp         SHORT $LN10@ClassEscap
$LN9@ClassEscap:
  000a9 c7 45 f8 00 00
        00 00          mov         DWORD PTR tv92[ebp], 0
$LN10@ClassEscap:
  000b0 8b 45 f8   mov         eax, DWORD PTR tv92[ebp]
$LN1@ClassEscap:

; 5234 :        }

  000b3 8b e5        mov         esp, ebp
  000b5 5d                 pop     ebp
  000b6 c2 04 00   ret         4
?_ClassEscape@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE?AW4_Prs_ret@2@_N@Z ENDP ; std::_Parser<char const *,char,std::regex_traits<char> >::_ClassEscape
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_CharacterClassEscape@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_N_N@Z
_TEXT   SEGMENT
__Ch0$ = -16                                            ; size = 4
_this$ = -12                                            ; size = 4
__Cls$ = -8                                   ; size = 2
tv79 = -1                                         ; size = 1
__Addit$ = 8                                            ; size = 1
?_CharacterClassEscape@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_N_N@Z PROC ; std::_Parser<char const *,char,std::regex_traits<char> >::_CharacterClassEscape, COMDAT
; _this$ = ecx

; 5197 :        {     // check for character class escape

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 10   sub         esp, 16                        ; 00000010H
  00006 89 4d f4   mov         DWORD PTR _this$[ebp], ecx

; 5198 :        typename _RxTraits::char_class_type _Cls;
; 5199 :        _FwdIt _Ch0 = _Pat;

  00009 8b 45 f4   mov         eax, DWORD PTR _this$[ebp]
  0000c 8b 08        mov         ecx, DWORD PTR [eax]
  0000e 89 4d f0   mov         DWORD PTR __Ch0$[ebp], ecx

; 5200 :        if (_Ch0 == _End
; 5201 :              || (_Cls = _Traits.lookup_classname(_Pat, ++_Ch0,

  00011 8b 55 f4   mov         edx, DWORD PTR _this$[ebp]
  00014 8b 45 f0   mov         eax, DWORD PTR __Ch0$[ebp]
  00017 3b 42 08   cmp         eax, DWORD PTR [edx+8]
  0001a 74 51        je  SHORT $LN3@CharacterC
  0001c 68 00 01 00 00     push    256              ; 00000100H
  00021 8b 4d f4   mov         ecx, DWORD PTR _this$[ebp]
  00024 8b 51 40   mov         edx, DWORD PTR [ecx+64]
  00027 52                 push    edx
  00028 e8 00 00 00 00     call    ??Iregex_constants@std@@YA?AW4syntax_option_type@01@W4201@0@Z ; std::regex_constants::operator&
  0002d 83 c4 08   add         esp, 8
  00030 85 c0        test        eax, eax
  00032 74 06        je  SHORT $LN6@CharacterC
  00034 c6 45 ff 01        mov   BYTE PTR tv79[ebp], 1
  00038 eb 04        jmp         SHORT $LN7@CharacterC
$LN6@CharacterC:
  0003a c6 45 ff 00        mov   BYTE PTR tv79[ebp], 0
$LN7@CharacterC:
  0003e 8b 45 f0   mov         eax, DWORD PTR __Ch0$[ebp]
  00041 83 c0 01   add         eax, 1
  00044 89 45 f0   mov         DWORD PTR __Ch0$[ebp], eax
  00047 0f b6 4d ff        movzx         ecx, BYTE PTR tv79[ebp]
  0004b 51                 push    ecx
  0004c 8b 55 f0   mov         edx, DWORD PTR __Ch0$[ebp]
  0004f 52                 push    edx
  00050 8b 45 f4   mov         eax, DWORD PTR _this$[ebp]
  00053 8b 08        mov         ecx, DWORD PTR [eax]
  00055 51                 push    ecx
  00056 8b 55 f4   mov         edx, DWORD PTR _this$[ebp]
  00059 8b 4a 3c   mov         ecx, DWORD PTR [edx+60]
  0005c e8 00 00 00 00     call    ??$lookup_classname@PBD@?$_Regex_traits@D@std@@QBEFPBD0_N@Z ; std::_Regex_traits<char>::lookup_classname<char const *>
  00061 66 89 45 f8        mov   WORD PTR __Cls$[ebp], ax
  00065 0f bf 45 f8        movsx         eax, WORD PTR __Cls$[ebp]
  00069 85 c0        test        eax, eax
  0006b 75 04        jne         SHORT $LN2@CharacterC
$LN3@CharacterC:

; 5202 :                  (_Flags & regex_constants::icase) != 0)) == 0)
; 5203 :              return (false);

  0006d 32 c0        xor         al, al
  0006f eb 46        jmp         SHORT $LN1@CharacterC
$LN2@CharacterC:

; 5204 :
; 5205 :        if (_Addit)

  00071 0f b6 4d 08        movzx         ecx, BYTE PTR __Addit$[ebp]
  00075 85 c9        test        ecx, ecx
  00077 74 0b        je  SHORT $LN4@CharacterC

; 5206 :              _Nfa._Add_class();

  00079 8b 4d f4   mov         ecx, DWORD PTR _this$[ebp]
  0007c 83 c1 24   add         ecx, 36                        ; 00000024H
  0007f e8 00 00 00 00     call    ?_Add_class@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXXZ ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_class
$LN4@CharacterC:

; 5207 :        _Nfa._Add_named_class(_Cls,

  00084 6a 01        push        1
  00086 8b 55 f4   mov         edx, DWORD PTR _this$[ebp]
  00089 0f b6 42 48        movzx         eax, BYTE PTR [edx+72]
  0008d 50                 push    eax
  0008e 8b 4d f4   mov         ecx, DWORD PTR _this$[ebp]
  00091 8b 49 3c   mov         ecx, DWORD PTR [ecx+60]
  00094 e8 00 00 00 00     call    ?isctype@?$_Regex_traits@D@std@@QBE_NDF@Z ; std::_Regex_traits<char>::isctype
  00099 0f b6 d0   movzx       edx, al
  0009c 52                 push    edx
  0009d 0f b7 45 f8        movzx         eax, WORD PTR __Cls$[ebp]
  000a1 50                 push    eax
  000a2 8b 4d f4   mov         ecx, DWORD PTR _this$[ebp]
  000a5 83 c1 24   add         ecx, 36                        ; 00000024H
  000a8 e8 00 00 00 00     call    ?_Add_named_class@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXF_N@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_named_class

; 5208 :              _Traits.isctype(_Char, _RxTraits::_Ch_upper));
; 5209 :        _Next();

  000ad 8b 4d f4   mov         ecx, DWORD PTR _this$[ebp]
  000b0 e8 00 00 00 00     call    ?_Next@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Next

; 5210 :        return (true);

  000b5 b0 01        mov         al, 1
$LN1@CharacterC:

; 5211 :        }

  000b7 8b e5        mov         esp, ebp
  000b9 5d                 pop     ebp
  000ba c2 04 00   ret         4
?_CharacterClassEscape@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_N_N@Z ENDP ; std::_Parser<char const *,char,std::regex_traits<char> >::_CharacterClassEscape
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Do_ex_class@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXW4_Meta_type@2@@Z
_TEXT   SEGMENT
__Errtype$ = -36                                        ; size = 4
tv69 = -32                                          ; size = 4
tv68 = -28                                          ; size = 4
tv67 = -24                                          ; size = 4
__Diff$ = -20                                     ; size = 4
__Beg$ = -16                                            ; size = 4
_this$ = -12                                            ; size = 4
__Cls$1 = -8                                            ; size = 2
tv130 = -1                                          ; size = 1
__End_arg$ = 8                                      ; size = 4
?_Do_ex_class@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXW4_Meta_type@2@@Z PROC ; std::_Parser<char const *,char,std::regex_traits<char> >::_Do_ex_class, COMDAT
; _this$ = ecx

; 5149 :        {     // handle delimited expressions within bracket expression

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 24   sub         esp, 36                        ; 00000024H
  00006 89 4d f4   mov         DWORD PTR _this$[ebp], ecx

; 5150 :        regex_constants::error_type _Errtype =
; 5151 :              (_End_arg == _Meta_colon ? regex_constants::error_ctype

  00009 83 7d 08 3a        cmp   DWORD PTR __End_arg$[ebp], 58 ; 0000003aH
  0000d 75 09        jne         SHORT $LN21@Do_ex_clas
  0000f c7 45 e0 01 00
        00 00          mov         DWORD PTR tv69[ebp], 1
  00016 eb 31        jmp         SHORT $LN22@Do_ex_clas
$LN21@Do_ex_clas:
  00018 83 7d 08 3d        cmp   DWORD PTR __End_arg$[ebp], 61 ; 0000003dH
  0001c 75 09        jne         SHORT $LN19@Do_ex_clas
  0001e c7 45 e4 00 00
        00 00          mov         DWORD PTR tv68[ebp], 0
  00025 eb 1c        jmp         SHORT $LN20@Do_ex_clas
$LN19@Do_ex_clas:
  00027 83 7d 08 2e        cmp   DWORD PTR __End_arg$[ebp], 46 ; 0000002eH
  0002b 75 09        jne         SHORT $LN17@Do_ex_clas
  0002d c7 45 e8 00 00
        00 00          mov         DWORD PTR tv67[ebp], 0
  00034 eb 07        jmp         SHORT $LN18@Do_ex_clas
$LN17@Do_ex_clas:
  00036 c7 45 e8 0e 00
        00 00          mov         DWORD PTR tv67[ebp], 14        ; 0000000eH
$LN18@Do_ex_clas:
  0003d 8b 45 e8   mov         eax, DWORD PTR tv67[ebp]
  00040 89 45 e4   mov         DWORD PTR tv68[ebp], eax
$LN20@Do_ex_clas:
  00043 8b 4d e4   mov         ecx, DWORD PTR tv68[ebp]
  00046 89 4d e0   mov         DWORD PTR tv69[ebp], ecx
$LN22@Do_ex_clas:
  00049 8b 55 e0   mov         edx, DWORD PTR tv69[ebp]
  0004c 89 55 dc   mov         DWORD PTR __Errtype$[ebp], edx

; 5152 :                  : _End_arg == _Meta_equal ? regex_constants::error_collate
; 5153 :                  : _End_arg == _Meta_dot ? regex_constants::error_collate
; 5154 :                  : regex_constants::error_syntax);
; 5155 :        _FwdIt _Beg = _Pat;

  0004f 8b 45 f4   mov         eax, DWORD PTR _this$[ebp]
  00052 8b 08        mov         ecx, DWORD PTR [eax]
  00054 89 4d f0   mov         DWORD PTR __Beg$[ebp], ecx

; 5156 :        _REGEX_DIFFT(_FwdIt) _Diff = 0;

  00057 c7 45 ec 00 00
        00 00          mov         DWORD PTR __Diff$[ebp], 0
$LN2@Do_ex_clas:

; 5157 :
; 5158 :        while (_Mchar != _Meta_colon && _Mchar != _Meta_equal
; 5159 :              && _Mchar != _Meta_dot && _Mchar != _Meta_eos)

  0005e 8b 55 f4   mov         edx, DWORD PTR _this$[ebp]
  00061 83 7a 4c 3a        cmp   DWORD PTR [edx+76], 58     ; 0000003aH
  00065 74 2e        je  SHORT $LN3@Do_ex_clas
  00067 8b 45 f4   mov         eax, DWORD PTR _this$[ebp]
  0006a 83 78 4c 3d        cmp   DWORD PTR [eax+76], 61     ; 0000003dH
  0006e 74 25        je  SHORT $LN3@Do_ex_clas
  00070 8b 4d f4   mov         ecx, DWORD PTR _this$[ebp]
  00073 83 79 4c 2e        cmp   DWORD PTR [ecx+76], 46     ; 0000002eH
  00077 74 1c        je  SHORT $LN3@Do_ex_clas
  00079 8b 55 f4   mov         edx, DWORD PTR _this$[ebp]
  0007c 83 7a 4c ff        cmp   DWORD PTR [edx+76], -1
  00080 74 13        je  SHORT $LN3@Do_ex_clas

; 5160 :              {   // advance to end delimiter
; 5161 :              _Next();

  00082 8b 4d f4   mov         ecx, DWORD PTR _this$[ebp]
  00085 e8 00 00 00 00     call    ?_Next@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Next

; 5162 :              ++_Diff;

  0008a 8b 45 ec   mov         eax, DWORD PTR __Diff$[ebp]
  0008d 83 c0 01   add         eax, 1
  00090 89 45 ec   mov         DWORD PTR __Diff$[ebp], eax

; 5163 :              }

  00093 eb c9        jmp         SHORT $LN2@Do_ex_clas
$LN3@Do_ex_clas:

; 5164 :        if (_Mchar != _End_arg)

  00095 8b 4d f4   mov         ecx, DWORD PTR _this$[ebp]
  00098 8b 51 4c   mov         edx, DWORD PTR [ecx+76]
  0009b 3b 55 08   cmp         edx, DWORD PTR __End_arg$[ebp]
  0009e 74 11        je  SHORT $LN4@Do_ex_clas

; 5165 :              _Error(_Errtype);

  000a0 8b 45 dc   mov         eax, DWORD PTR __Errtype$[ebp]
  000a3 50                 push    eax
  000a4 8b 4d f4   mov         ecx, DWORD PTR _this$[ebp]
  000a7 e8 00 00 00 00     call    ?_Error@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_Error
  000ac e9 d8 00 00 00     jmp     $LN5@Do_ex_clas
$LN4@Do_ex_clas:

; 5166 :        else if (_End_arg == _Meta_colon)

  000b1 83 7d 08 3a        cmp   DWORD PTR __End_arg$[ebp], 58 ; 0000003aH
  000b5 75 66        jne         SHORT $LN6@Do_ex_clas

; 5167 :              {   // handle named character class
; 5168 :              typename _RxTraits::char_class_type _Cls =
; 5169 :                  _Traits.lookup_classname(_Beg, _Pat,

  000b7 68 00 01 00 00     push    256              ; 00000100H
  000bc 8b 4d f4   mov         ecx, DWORD PTR _this$[ebp]
  000bf 8b 51 40   mov         edx, DWORD PTR [ecx+64]
  000c2 52                 push    edx
  000c3 e8 00 00 00 00     call    ??Iregex_constants@std@@YA?AW4syntax_option_type@01@W4201@0@Z ; std::regex_constants::operator&
  000c8 83 c4 08   add         esp, 8
  000cb 85 c0        test        eax, eax
  000cd 74 06        je  SHORT $LN23@Do_ex_clas
  000cf c6 45 ff 01        mov   BYTE PTR tv130[ebp], 1
  000d3 eb 04        jmp         SHORT $LN24@Do_ex_clas
$LN23@Do_ex_clas:
  000d5 c6 45 ff 00        mov   BYTE PTR tv130[ebp], 0
$LN24@Do_ex_clas:
  000d9 0f b6 45 ff        movzx         eax, BYTE PTR tv130[ebp]
  000dd 50                 push    eax
  000de 8b 4d f4   mov         ecx, DWORD PTR _this$[ebp]
  000e1 8b 11        mov         edx, DWORD PTR [ecx]
  000e3 52                 push    edx
  000e4 8b 45 f0   mov         eax, DWORD PTR __Beg$[ebp]
  000e7 50                 push    eax
  000e8 8b 4d f4   mov         ecx, DWORD PTR _this$[ebp]
  000eb 8b 49 3c   mov         ecx, DWORD PTR [ecx+60]
  000ee e8 00 00 00 00     call    ??$lookup_classname@PBD@?$_Regex_traits@D@std@@QBEFPBD0_N@Z ; std::_Regex_traits<char>::lookup_classname<char const *>
  000f3 66 89 45 f8        mov   WORD PTR __Cls$1[ebp], ax

; 5170 :                          (_Flags & regex_constants::icase) != 0);
; 5171 :              if (!_Cls)

  000f7 0f bf 55 f8        movsx         edx, WORD PTR __Cls$1[ebp]
  000fb 85 d2        test        edx, edx
  000fd 75 0a        jne         SHORT $LN8@Do_ex_clas

; 5172 :                  _Error(regex_constants::error_ctype);

  000ff 6a 01        push        1
  00101 8b 4d f4   mov         ecx, DWORD PTR _this$[ebp]
  00104 e8 00 00 00 00     call    ?_Error@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_Error
$LN8@Do_ex_clas:

; 5173 :              _Nfa._Add_named_class(_Cls);

  00109 6a 00        push        0
  0010b 0f b7 45 f8        movzx         eax, WORD PTR __Cls$1[ebp]
  0010f 50                 push    eax
  00110 8b 4d f4   mov         ecx, DWORD PTR _this$[ebp]
  00113 83 c1 24   add         ecx, 36                        ; 00000024H
  00116 e8 00 00 00 00     call    ?_Add_named_class@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXF_N@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_named_class
  0011b eb 6c        jmp         SHORT $LN5@Do_ex_clas
$LN6@Do_ex_clas:

; 5174 :              }
; 5175 :        else if (_End_arg == _Meta_equal)

  0011d 83 7d 08 3d        cmp   DWORD PTR __End_arg$[ebp], 61 ; 0000003dH
  00121 75 31        jne         SHORT $LN9@Do_ex_clas

; 5176 :              {   // process =
; 5177 :              if (_Beg == _Pat)

  00123 8b 4d f4   mov         ecx, DWORD PTR _this$[ebp]
  00126 8b 55 f0   mov         edx, DWORD PTR __Beg$[ebp]
  00129 3b 11        cmp         edx, DWORD PTR [ecx]
  0012b 75 0c        jne         SHORT $LN11@Do_ex_clas

; 5178 :                  _Error(regex_constants::error_collate);

  0012d 6a 00        push        0
  0012f 8b 4d f4   mov         ecx, DWORD PTR _this$[ebp]
  00132 e8 00 00 00 00     call    ?_Error@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_Error

; 5179 :              else

  00137 eb 19        jmp         SHORT $LN12@Do_ex_clas
$LN11@Do_ex_clas:

; 5180 :                  _Nfa._Add_equiv(_Beg, _Pat, _Diff);

  00139 8b 45 ec   mov         eax, DWORD PTR __Diff$[ebp]
  0013c 50                 push    eax
  0013d 8b 4d f4   mov         ecx, DWORD PTR _this$[ebp]
  00140 8b 11        mov         edx, DWORD PTR [ecx]
  00142 52                 push    edx
  00143 8b 45 f0   mov         eax, DWORD PTR __Beg$[ebp]
  00146 50                 push    eax
  00147 8b 4d f4   mov         ecx, DWORD PTR _this$[ebp]
  0014a 83 c1 24   add         ecx, 36                        ; 00000024H
  0014d e8 00 00 00 00     call    ?_Add_equiv@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXPBD0H@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_equiv
$LN12@Do_ex_clas:
  00152 eb 35        jmp         SHORT $LN5@Do_ex_clas
$LN9@Do_ex_clas:

; 5181 :              }
; 5182 :        else if (_End_arg == _Meta_dot)

  00154 83 7d 08 2e        cmp   DWORD PTR __End_arg$[ebp], 46 ; 0000002eH
  00158 75 2f        jne         SHORT $LN5@Do_ex_clas

; 5183 :              {   // process .
; 5184 :              if (_Beg == _Pat)

  0015a 8b 4d f4   mov         ecx, DWORD PTR _this$[ebp]
  0015d 8b 55 f0   mov         edx, DWORD PTR __Beg$[ebp]
  00160 3b 11        cmp         edx, DWORD PTR [ecx]
  00162 75 0c        jne         SHORT $LN14@Do_ex_clas

; 5185 :                  _Error(regex_constants::error_collate);

  00164 6a 00        push        0
  00166 8b 4d f4   mov         ecx, DWORD PTR _this$[ebp]
  00169 e8 00 00 00 00     call    ?_Error@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_Error

; 5186 :              else

  0016e eb 19        jmp         SHORT $LN5@Do_ex_clas
$LN14@Do_ex_clas:

; 5187 :                  _Nfa._Add_coll(_Beg, _Pat, _Diff);

  00170 8b 45 ec   mov         eax, DWORD PTR __Diff$[ebp]
  00173 50                 push    eax
  00174 8b 4d f4   mov         ecx, DWORD PTR _this$[ebp]
  00177 8b 11        mov         edx, DWORD PTR [ecx]
  00179 52                 push    edx
  0017a 8b 45 f0   mov         eax, DWORD PTR __Beg$[ebp]
  0017d 50                 push    eax
  0017e 8b 4d f4   mov         ecx, DWORD PTR _this$[ebp]
  00181 83 c1 24   add         ecx, 36                        ; 00000024H
  00184 e8 00 00 00 00     call    ?_Add_coll@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXPBD0H@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Add_coll
$LN5@Do_ex_clas:

; 5188 :              }
; 5189 :        _Next();

  00189 8b 4d f4   mov         ecx, DWORD PTR _this$[ebp]
  0018c e8 00 00 00 00     call    ?_Next@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Next

; 5190 :        _Expect(_Meta_rsq, _Errtype);

  00191 8b 4d dc   mov         ecx, DWORD PTR __Errtype$[ebp]
  00194 51                 push    ecx
  00195 6a 5d        push        93             ; 0000005dH
  00197 8b 4d f4   mov         ecx, DWORD PTR _this$[ebp]
  0019a e8 00 00 00 00     call    ?_Expect@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXW4_Meta_type@2@W4error_type@regex_constants@2@@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_Expect

; 5191 :        }

  0019f 8b e5        mov         esp, ebp
  001a1 5d                 pop     ebp
  001a2 c2 04 00   ret         4
?_Do_ex_class@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXW4_Meta_type@2@@Z ENDP ; std::_Parser<char const *,char,std::regex_traits<char> >::_Do_ex_class
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_OctalDigits@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_NXZ
_TEXT   SEGMENT
_this$ = -8                                   ; size = 4
tv69 = -4                                         ; size = 4
?_OctalDigits@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_NXZ PROC ; std::_Parser<char const *,char,std::regex_traits<char> >::_OctalDigits, COMDAT
; _this$ = ecx

; 5141 :        {     // check for up to 3 octal digits

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d f8   mov         DWORD PTR _this$[ebp], ecx

; 5142 :        return (_Do_digits(8, 3) != 3);

  00009 6a 03        push        3
  0000b 6a 08        push        8
  0000d 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00010 e8 00 00 00 00     call    ?_Do_digits@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEHHH@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_Do_digits
  00015 83 f8 03   cmp         eax, 3
  00018 74 09        je  SHORT $LN3@OctalDigit
  0001a c7 45 fc 01 00
        00 00          mov         DWORD PTR tv69[ebp], 1
  00021 eb 07        jmp         SHORT $LN4@OctalDigit
$LN3@OctalDigit:
  00023 c7 45 fc 00 00
        00 00          mov         DWORD PTR tv69[ebp], 0
$LN4@OctalDigit:
  0002a 8a 45 fc   mov         al, BYTE PTR tv69[ebp]

; 5143 :        }

  0002d 8b e5        mov         esp, ebp
  0002f 5d                 pop     ebp
  00030 c3                 ret     0
?_OctalDigits@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_NXZ ENDP ; std::_Parser<char const *,char,std::regex_traits<char> >::_OctalDigits
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_HexDigits@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXH@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Count$ = 8                                            ; size = 4
?_HexDigits@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXH@Z PROC ; std::_Parser<char const *,char,std::regex_traits<char> >::_HexDigits, COMDAT
; _this$ = ecx

; 5132 :        {     // check for _Count hex digits

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 5133 :        if (_Do_digits(16, _Count) != 0)

  00007 8b 45 08   mov         eax, DWORD PTR __Count$[ebp]
  0000a 50                 push    eax
  0000b 6a 10        push        16             ; 00000010H
  0000d 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00010 e8 00 00 00 00     call    ?_Do_digits@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEHHH@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_Do_digits
  00015 85 c0        test        eax, eax
  00017 74 0a        je  SHORT $LN1@HexDigits

; 5134 :              _Error(regex_constants::error_escape);

  00019 6a 02        push        2
  0001b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001e e8 00 00 00 00     call    ?_Error@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_Error
$LN1@HexDigits:

; 5135 :        }

  00023 8b e5        mov         esp, ebp
  00025 5d                 pop     ebp
  00026 c2 04 00   ret         4
?_HexDigits@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXH@Z ENDP ; std::_Parser<char const *,char,std::regex_traits<char> >::_HexDigits
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_DecimalDigits@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_NXZ
_TEXT   SEGMENT
_this$ = -8                                   ; size = 4
tv69 = -4                                         ; size = 4
?_DecimalDigits@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_NXZ PROC ; std::_Parser<char const *,char,std::regex_traits<char> >::_DecimalDigits, COMDAT
; _this$ = ecx

; 5124 :        {     // check for decimal value

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d f8   mov         DWORD PTR _this$[ebp], ecx

; 5125 :        return (_Do_digits(10, INT_MAX) != INT_MAX);

  00009 68 ff ff ff 7f     push    2147483647         ; 7fffffffH
  0000e 6a 0a        push        10             ; 0000000aH
  00010 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00013 e8 00 00 00 00     call    ?_Do_digits@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEHHH@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_Do_digits
  00018 3d ff ff ff 7f     cmp     eax, 2147483647                ; 7fffffffH
  0001d 74 09        je  SHORT $LN3@DecimalDig
  0001f c7 45 fc 01 00
        00 00          mov         DWORD PTR tv69[ebp], 1
  00026 eb 07        jmp         SHORT $LN4@DecimalDig
$LN3@DecimalDig:
  00028 c7 45 fc 00 00
        00 00          mov         DWORD PTR tv69[ebp], 0
$LN4@DecimalDig:
  0002f 8a 45 fc   mov         al, BYTE PTR tv69[ebp]

; 5126 :        }

  00032 8b e5        mov         esp, ebp
  00034 5d                 pop     ebp
  00035 c3                 ret     0
?_DecimalDigits@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAE_NXZ ENDP ; std::_Parser<char const *,char,std::regex_traits<char> >::_DecimalDigits
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Do_digits@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEHHH@Z
_TEXT   SEGMENT
__Chv$ = -8                                   ; size = 4
_this$ = -4                                   ; size = 4
__Base$ = 8                                   ; size = 4
__Count$ = 12                                     ; size = 4
?_Do_digits@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEHHH@Z PROC ; std::_Parser<char const *,char,std::regex_traits<char> >::_Do_digits, COMDAT
; _this$ = ecx

; 5107 :        {     // translate digits to numeric value

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 5108 :        int _Chv;
; 5109 :        _Val = 0;

  00009 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000c c7 40 44 00 00
        00 00          mov         DWORD PTR [eax+68], 0
$LN2@Do_digits:

; 5110 :        while (_Count != 0 && (_Chv = _Traits.value(_Char, _Base)) != -1)

  00013 83 7d 0c 00        cmp   DWORD PTR __Count$[ebp], 0
  00017 74 52        je  SHORT $LN3@Do_digits
  00019 8b 4d 08   mov         ecx, DWORD PTR __Base$[ebp]
  0001c 51                 push    ecx
  0001d 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  00020 0f b6 42 48        movzx         eax, BYTE PTR [edx+72]
  00024 50                 push    eax
  00025 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00028 8b 49 3c   mov         ecx, DWORD PTR [ecx+60]
  0002b e8 00 00 00 00     call    ?value@?$regex_traits@D@std@@QBEHDH@Z ; std::regex_traits<char>::value
  00030 89 45 f8   mov         DWORD PTR __Chv$[ebp], eax
  00033 83 7d f8 ff        cmp   DWORD PTR __Chv$[ebp], -1
  00037 74 32        je  SHORT $LN3@Do_digits

; 5111 :              {   // append next digit
; 5112 :              --_Count;

  00039 8b 55 0c   mov         edx, DWORD PTR __Count$[ebp]
  0003c 83 ea 01   sub         edx, 1
  0003f 89 55 0c   mov         DWORD PTR __Count$[ebp], edx

; 5113 :              _Val *= _Base;

  00042 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00045 8b 48 44   mov         ecx, DWORD PTR [eax+68]
  00048 0f af 4d 08        imul  ecx, DWORD PTR __Base$[ebp]
  0004c 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  0004f 89 4a 44   mov         DWORD PTR [edx+68], ecx

; 5114 :              _Val += _Chv;

  00052 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00055 8b 48 44   mov         ecx, DWORD PTR [eax+68]
  00058 03 4d f8   add         ecx, DWORD PTR __Chv$[ebp]
  0005b 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  0005e 89 4a 44   mov         DWORD PTR [edx+68], ecx

; 5115 :              _Next();

  00061 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00064 e8 00 00 00 00     call    ?_Next@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Next

; 5116 :              }

  00069 eb a8        jmp         SHORT $LN2@Do_digits
$LN3@Do_digits:

; 5117 :        return (_Count);

  0006b 8b 45 0c   mov         eax, DWORD PTR __Count$[ebp]

; 5118 :        }

  0006e 8b e5        mov         esp, ebp
  00070 5d                 pop     ebp
  00071 c2 08 00   ret         8
?_Do_digits@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEHHH@Z ENDP ; std::_Parser<char const *,char,std::regex_traits<char> >::_Do_digits
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Expect@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXW4_Meta_type@2@W4error_type@regex_constants@2@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__St$ = 8                                         ; size = 4
__Code$ = 12                                            ; size = 4
?_Expect@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXW4_Meta_type@2@W4error_type@regex_constants@2@@Z PROC ; std::_Parser<char const *,char,std::regex_traits<char> >::_Expect, COMDAT
; _this$ = ecx

; 5096 :        {     // check whether current meta-character is _St

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 5097 :        if (_Mchar != _St)

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a 8b 48 4c   mov         ecx, DWORD PTR [eax+76]
  0000d 3b 4d 08   cmp         ecx, DWORD PTR __St$[ebp]
  00010 74 0c        je  SHORT $LN2@Expect

; 5098 :              _Error(_Code);

  00012 8b 55 0c   mov         edx, DWORD PTR __Code$[ebp]
  00015 52                 push    edx
  00016 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00019 e8 00 00 00 00     call    ?_Error@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_Error
$LN2@Expect:

; 5099 :        _Next();

  0001e 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00021 e8 00 00 00 00     call    ?_Next@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Next

; 5100 :        }

  00026 8b e5        mov         esp, ebp
  00028 5d                 pop     ebp
  00029 c2 08 00   ret         8
?_Expect@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXW4_Meta_type@2@W4error_type@regex_constants@2@@Z ENDP ; std::_Parser<char const *,char,std::regex_traits<char> >::_Expect
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Next@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Next@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ PROC ; std::_Parser<char const *,char,std::regex_traits<char> >::_Next, COMDAT
; _this$ = ecx

; 5081 :        {     // advance to next input character

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 5082 :        if (_Pat != _End)

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000d 8b 10        mov         edx, DWORD PTR [eax]
  0000f 3b 51 08   cmp         edx, DWORD PTR [ecx+8]
  00012 74 36        je  SHORT $LN2@Next

; 5083 :              {   // advance
; 5084 :              if (*_Pat == _Meta_esc && _Is_esc())

  00014 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00017 8b 08        mov         ecx, DWORD PTR [eax]
  00019 0f be 11   movsx       edx, BYTE PTR [ecx]
  0001c 83 fa 5c   cmp         edx, 92                        ; 0000005cH
  0001f 75 1c        jne         SHORT $LN3@Next
  00021 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00024 e8 00 00 00 00     call    ?_Is_esc@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@ABE_NXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Is_esc
  00029 0f b6 c0   movzx       eax, al
  0002c 85 c0        test        eax, eax
  0002e 74 0d        je  SHORT $LN3@Next

; 5085 :                  ++_Pat;

  00030 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00033 8b 11        mov         edx, DWORD PTR [ecx]
  00035 83 c2 01   add         edx, 1
  00038 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0003b 89 10        mov         DWORD PTR [eax], edx
$LN3@Next:

; 5086 :              ++_Pat;

  0003d 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00040 8b 11        mov         edx, DWORD PTR [ecx]
  00042 83 c2 01   add         edx, 1
  00045 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00048 89 10        mov         DWORD PTR [eax], edx
$LN2@Next:

; 5087 :              }
; 5088 :        _Trans();

  0004a 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0004d e8 00 00 00 00     call    ?_Trans@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Trans

; 5089 :        }

  00052 8b e5        mov         esp, ebp
  00054 5d                 pop     ebp
  00055 c3                 ret     0
?_Next@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ENDP ; std::_Parser<char const *,char,std::regex_traits<char> >::_Next
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Trans@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ
_TEXT   SEGMENT
tv81 = -20                                          ; size = 4
__Ch0$1 = -16                                     ; size = 4
__Ch0$2 = -12                                     ; size = 4
tv84 = -8                                         ; size = 4
_this$ = -4                                   ; size = 4
?_Trans@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ PROC ; std::_Parser<char const *,char,std::regex_traits<char> >::_Trans, COMDAT
; _this$ = ecx

; 5007 :        {     // map character to meta-character

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 14   sub         esp, 20                        ; 00000014H
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 5008 :        if (_Pat == _End)

  00009 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000c 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000f 8b 10        mov         edx, DWORD PTR [eax]
  00011 3b 51 08   cmp         edx, DWORD PTR [ecx+8]
  00014 75 13        jne         SHORT $LN4@Trans

; 5009 :              _Mchar = _Meta_eos, _Char = (_Elem)_Meta_eos;

  00016 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00019 c7 40 4c ff ff
        ff ff          mov         DWORD PTR [eax+76], -1
  00020 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00023 c6 41 48 ff        mov   BYTE PTR [ecx+72], -1

; 5010 :        else

  00027 eb 42        jmp         SHORT $LN5@Trans
$LN4@Trans:

; 5011 :              {   // map current character
; 5012 :              _Char = *_Pat;

  00029 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  0002c 8b 02        mov         eax, DWORD PTR [edx]
  0002e 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00031 8a 10        mov         dl, BYTE PTR [eax]
  00033 88 51 48   mov         BYTE PTR [ecx+72], dl

; 5013 :              _Mchar = _CSTD strchr(_Meta_map, _Char) != 0

  00036 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00039 0f be 48 48        movsx         ecx, BYTE PTR [eax+72]
  0003d 51                 push    ecx
  0003e 68 00 00 00 00     push    OFFSET ?_Meta_map@std@@3QBDB
  00043 e8 00 00 00 00     call    _strchr
  00048 83 c4 08   add         esp, 8
  0004b 85 c0        test        eax, eax
  0004d 74 0c        je  SHORT $LN25@Trans
  0004f 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  00052 0f be 42 48        movsx         eax, BYTE PTR [edx+72]
  00056 89 45 ec   mov         DWORD PTR tv81[ebp], eax
  00059 eb 07        jmp         SHORT $LN26@Trans
$LN25@Trans:
  0005b c7 45 ec 00 00
        00 00          mov         DWORD PTR tv81[ebp], 0
$LN26@Trans:
  00062 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00065 8b 55 ec   mov         edx, DWORD PTR tv81[ebp]
  00068 89 51 4c   mov         DWORD PTR [ecx+76], edx
$LN5@Trans:

; 5014 :                  ? (_Meta_type)_Char : _Meta_chr;
; 5015 :              }
; 5016 :        switch (_Char)

  0006b 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0006e 0f be 48 48        movsx         ecx, BYTE PTR [eax+72]
  00072 89 4d f8   mov         DWORD PTR tv84[ebp], ecx
  00075 8b 55 f8   mov         edx, DWORD PTR tv84[ebp]
  00078 83 ea 0a   sub         edx, 10                        ; 0000000aH
  0007b 89 55 f8   mov         DWORD PTR tv84[ebp], edx
  0007e 83 7d f8 73        cmp   DWORD PTR tv84[ebp], 115 ; 00000073H
  00082 0f 87 6b 01 00
        00           ja      $LN1@Trans
  00088 8b 45 f8   mov         eax, DWORD PTR tv84[ebp]
  0008b 0f b6 88 00 00
        00 00          movzx       ecx, BYTE PTR $LN27@Trans[eax]
  00092 ff 24 8d 00 00
        00 00          jmp         DWORD PTR $LN28@Trans[ecx*4]
$LN6@Trans:

; 5017 :              {   // handle special cases
; 5018 :              case _Meta_esc:
; 5019 :                  if (_Is_esc())

  00099 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0009c e8 00 00 00 00     call    ?_Is_esc@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@ABE_NXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Is_esc
  000a1 0f b6 d0   movzx       edx, al
  000a4 85 d2        test        edx, edx
  000a6 74 29        je  SHORT $LN7@Trans

; 5020 :                          {       // replace escape sequence
; 5021 :                          _FwdIt _Ch0 = _Pat;

  000a8 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  000ab 8b 08        mov         ecx, DWORD PTR [eax]
  000ad 89 4d f0   mov         DWORD PTR __Ch0$1[ebp], ecx

; 5022 :                          _Mchar = _Meta_type(_Char = *++_Ch0);

  000b0 8b 55 f0   mov         edx, DWORD PTR __Ch0$1[ebp]
  000b3 83 c2 01   add         edx, 1
  000b6 89 55 f0   mov         DWORD PTR __Ch0$1[ebp], edx
  000b9 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  000bc 8b 4d f0   mov         ecx, DWORD PTR __Ch0$1[ebp]
  000bf 8a 11        mov         dl, BYTE PTR [ecx]
  000c1 88 50 48   mov         BYTE PTR [eax+72], dl
  000c4 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  000c7 0f be 48 48        movsx         ecx, BYTE PTR [eax+72]
  000cb 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  000ce 89 4a 4c   mov         DWORD PTR [edx+76], ecx
$LN7@Trans:

; 5023 :                          }
; 5024 :                  break;

  000d1 e9 1d 01 00 00     jmp     $LN1@Trans
$LN8@Trans:

; 5025 :
; 5026 :              case _Meta_nl:
; 5027 :                  if ((_L_flags & _L_alt_nl) && _Disj_count == 0)

  000d6 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  000d9 8b 48 50   mov         ecx, DWORD PTR [eax+80]
  000dc 83 e1 04   and         ecx, 4
  000df 74 13        je  SHORT $LN9@Trans
  000e1 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  000e4 83 7a 10 00        cmp   DWORD PTR [edx+16], 0
  000e8 75 0a        jne         SHORT $LN9@Trans

; 5028 :                          _Mchar = _Meta_bar;

  000ea 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  000ed c7 40 4c 7c 00
        00 00          mov         DWORD PTR [eax+76], 124        ; 0000007cH
$LN9@Trans:

; 5029 :                  break;

  000f4 e9 fa 00 00 00     jmp     $LN1@Trans
$LN10@Trans:

; 5030 :
; 5031 :              case _Meta_lpar:
; 5032 :              case _Meta_rpar:
; 5033 :                  if (!(_L_flags & _L_nex_grp))

  000f9 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000fc 8b 51 50   mov         edx, DWORD PTR [ecx+80]
  000ff 83 e2 08   and         edx, 8
  00102 75 0a        jne         SHORT $LN11@Trans

; 5034 :                          _Mchar = _Meta_chr;

  00104 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00107 c7 40 4c 00 00
        00 00          mov         DWORD PTR [eax+76], 0
$LN11@Trans:

; 5035 :                  break;

  0010e e9 e0 00 00 00     jmp     $LN1@Trans
$LN12@Trans:

; 5036 :
; 5037 :              case _Meta_lbr:
; 5038 :              case _Meta_rbr:
; 5039 :                  if (!(_L_flags & _L_nex_rep))

  00113 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00116 8b 51 50   mov         edx, DWORD PTR [ecx+80]
  00119 83 e2 10   and         edx, 16                        ; 00000010H
  0011c 75 0a        jne         SHORT $LN13@Trans

; 5040 :                          _Mchar = _Meta_chr;

  0011e 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00121 c7 40 4c 00 00
        00 00          mov         DWORD PTR [eax+76], 0
$LN13@Trans:

; 5041 :                  break;

  00128 e9 c6 00 00 00     jmp     $LN1@Trans
$LN14@Trans:

; 5042 :
; 5043 :              case _Meta_star:
; 5044 :                  if ((_L_flags & _L_star_beg)
; 5045 :                          && _Nfa._Beg_expr())

  0012d 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00130 8b 51 50   mov         edx, DWORD PTR [ecx+80]
  00133 81 e2 00 00 00
        04           and     edx, 67108864      ; 04000000H
  00139 74 1c        je  SHORT $LN15@Trans
  0013b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0013e 83 c1 24   add         ecx, 36                        ; 00000024H
  00141 e8 00 00 00 00     call    ?_Beg_expr@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QBE_NXZ ; std::_Builder<char const *,char,std::regex_traits<char> >::_Beg_expr
  00146 0f b6 c0   movzx       eax, al
  00149 85 c0        test        eax, eax
  0014b 74 0a        je  SHORT $LN15@Trans

; 5046 :                          _Mchar = _Meta_chr;

  0014d 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00150 c7 41 4c 00 00
        00 00          mov         DWORD PTR [ecx+76], 0
$LN15@Trans:

; 5047 :                  break;

  00157 e9 97 00 00 00     jmp     $LN1@Trans
$LN16@Trans:

; 5048 :
; 5049 :              case _Meta_caret:
; 5050 :                  if ((_L_flags & _L_anch_rstr)
; 5051 :                          && !_Nfa._Beg_expr())

  0015c 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  0015f 8b 42 50   mov         eax, DWORD PTR [edx+80]
  00162 25 00 00 00 02     and     eax, 33554432      ; 02000000H
  00167 74 1c        je  SHORT $LN17@Trans
  00169 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0016c 83 c1 24   add         ecx, 36                        ; 00000024H
  0016f e8 00 00 00 00     call    ?_Beg_expr@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QBE_NXZ ; std::_Builder<char const *,char,std::regex_traits<char> >::_Beg_expr
  00174 0f b6 c8   movzx       ecx, al
  00177 85 c9        test        ecx, ecx
  00179 75 0a        jne         SHORT $LN17@Trans

; 5052 :                  _Mchar = _Meta_chr;

  0017b 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  0017e c7 42 4c 00 00
        00 00          mov         DWORD PTR [edx+76], 0
$LN17@Trans:

; 5053 :                  break;

  00185 eb 6c        jmp         SHORT $LN1@Trans
$LN18@Trans:

; 5054 :
; 5055 :              case _Meta_dlr:
; 5056 :                  {       // check if $ is special
; 5057 :                  _FwdIt _Ch0 = _Pat;

  00187 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0018a 8b 08        mov         ecx, DWORD PTR [eax]
  0018c 89 4d f4   mov         DWORD PTR __Ch0$2[ebp], ecx

; 5058 :                  if ((_L_flags & _L_anch_rstr)
; 5059 :                          && ++_Ch0 != _End && *_Ch0 != _Meta_nl)

  0018f 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  00192 8b 42 50   mov         eax, DWORD PTR [edx+80]
  00195 25 00 00 00 02     and     eax, 33554432      ; 02000000H
  0019a 74 29        je  SHORT $LN19@Trans
  0019c 8b 4d f4   mov         ecx, DWORD PTR __Ch0$2[ebp]
  0019f 83 c1 01   add         ecx, 1
  001a2 89 4d f4   mov         DWORD PTR __Ch0$2[ebp], ecx
  001a5 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  001a8 8b 45 f4   mov         eax, DWORD PTR __Ch0$2[ebp]
  001ab 3b 42 08   cmp         eax, DWORD PTR [edx+8]
  001ae 74 15        je  SHORT $LN19@Trans
  001b0 8b 4d f4   mov         ecx, DWORD PTR __Ch0$2[ebp]
  001b3 0f be 11   movsx       edx, BYTE PTR [ecx]
  001b6 83 fa 0a   cmp         edx, 10                        ; 0000000aH
  001b9 74 0a        je  SHORT $LN19@Trans

; 5060 :                          _Mchar = _Meta_chr;

  001bb 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  001be c7 40 4c 00 00
        00 00          mov         DWORD PTR [eax+76], 0
$LN19@Trans:

; 5061 :                  break;

  001c5 eb 2c        jmp         SHORT $LN1@Trans
$LN20@Trans:

; 5062 :                  }
; 5063 :
; 5064 :              case _Meta_plus:
; 5065 :              case _Meta_query:
; 5066 :                  if (!(_L_flags & _L_ext_rep))

  001c7 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  001ca 8b 51 50   mov         edx, DWORD PTR [ecx+80]
  001cd 83 e2 01   and         edx, 1
  001d0 75 0a        jne         SHORT $LN21@Trans

; 5067 :                          _Mchar = _Meta_chr;

  001d2 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  001d5 c7 40 4c 00 00
        00 00          mov         DWORD PTR [eax+76], 0
$LN21@Trans:

; 5068 :                  break;

  001dc eb 15        jmp         SHORT $LN1@Trans
$LN22@Trans:

; 5069 :
; 5070 :              case _Meta_bar:
; 5071 :                  if (!(_L_flags & _L_alt_pipe))

  001de 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  001e1 8b 51 50   mov         edx, DWORD PTR [ecx+80]
  001e4 83 e2 02   and         edx, 2
  001e7 75 0a        jne         SHORT $LN1@Trans

; 5072 :                          _Mchar = _Meta_chr;

  001e9 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  001ec c7 40 4c 00 00
        00 00          mov         DWORD PTR [eax+76], 0
$LN1@Trans:

; 5073 :                  break;
; 5074 :              }
; 5075 :        }

  001f3 8b e5        mov         esp, ebp
  001f5 5d                 pop     ebp
  001f6 c3                 ret     0
  001f7 90                 npad    1
$LN28@Trans:
  001f8 00 00 00 00        DD    $LN8@Trans
  001fc 00 00 00 00        DD    $LN18@Trans
  00200 00 00 00 00        DD    $LN10@Trans
  00204 00 00 00 00        DD    $LN14@Trans
  00208 00 00 00 00        DD    $LN20@Trans
  0020c 00 00 00 00        DD    $LN6@Trans
  00210 00 00 00 00        DD    $LN16@Trans
  00214 00 00 00 00        DD    $LN12@Trans
  00218 00 00 00 00        DD    $LN22@Trans
  0021c 00 00 00 00        DD    $LN1@Trans
$LN27@Trans:
  00220 00                 DB      0
  00221 09                 DB      9
  00222 09                 DB      9
  00223 09                 DB      9
  00224 09                 DB      9
  00225 09                 DB      9
  00226 09                 DB      9
  00227 09                 DB      9
  00228 09                 DB      9
  00229 09                 DB      9
  0022a 09                 DB      9
  0022b 09                 DB      9
  0022c 09                 DB      9
  0022d 09                 DB      9
  0022e 09                 DB      9
  0022f 09                 DB      9
  00230 09                 DB      9
  00231 09                 DB      9
  00232 09                 DB      9
  00233 09                 DB      9
  00234 09                 DB      9
  00235 09                 DB      9
  00236 09                 DB      9
  00237 09                 DB      9
  00238 09                 DB      9
  00239 09                 DB      9
  0023a 01                 DB      1
  0023b 09                 DB      9
  0023c 09                 DB      9
  0023d 09                 DB      9
  0023e 02                 DB      2
  0023f 02                 DB      2
  00240 03                 DB      3
  00241 04                 DB      4
  00242 09                 DB      9
  00243 09                 DB      9
  00244 09                 DB      9
  00245 09                 DB      9
  00246 09                 DB      9
  00247 09                 DB      9
  00248 09                 DB      9
  00249 09                 DB      9
  0024a 09                 DB      9
  0024b 09                 DB      9
  0024c 09                 DB      9
  0024d 09                 DB      9
  0024e 09                 DB      9
  0024f 09                 DB      9
  00250 09                 DB      9
  00251 09                 DB      9
  00252 09                 DB      9
  00253 09                 DB      9
  00254 09                 DB      9
  00255 04                 DB      4
  00256 09                 DB      9
  00257 09                 DB      9
  00258 09                 DB      9
  00259 09                 DB      9
  0025a 09                 DB      9
  0025b 09                 DB      9
  0025c 09                 DB      9
  0025d 09                 DB      9
  0025e 09                 DB      9
  0025f 09                 DB      9
  00260 09                 DB      9
  00261 09                 DB      9
  00262 09                 DB      9
  00263 09                 DB      9
  00264 09                 DB      9
  00265 09                 DB      9
  00266 09                 DB      9
  00267 09                 DB      9
  00268 09                 DB      9
  00269 09                 DB      9
  0026a 09                 DB      9
  0026b 09                 DB      9
  0026c 09                 DB      9
  0026d 09                 DB      9
  0026e 09                 DB      9
  0026f 09                 DB      9
  00270 09                 DB      9
  00271 09                 DB      9
  00272 05                 DB      5
  00273 09                 DB      9
  00274 06                 DB      6
  00275 09                 DB      9
  00276 09                 DB      9
  00277 09                 DB      9
  00278 09                 DB      9
  00279 09                 DB      9
  0027a 09                 DB      9
  0027b 09                 DB      9
  0027c 09                 DB      9
  0027d 09                 DB      9
  0027e 09                 DB      9
  0027f 09                 DB      9
  00280 09                 DB      9
  00281 09                 DB      9
  00282 09                 DB      9
  00283 09                 DB      9
  00284 09                 DB      9
  00285 09                 DB      9
  00286 09                 DB      9
  00287 09                 DB      9
  00288 09                 DB      9
  00289 09                 DB      9
  0028a 09                 DB      9
  0028b 09                 DB      9
  0028c 09                 DB      9
  0028d 09                 DB      9
  0028e 09                 DB      9
  0028f 09                 DB      9
  00290 09                 DB      9
  00291 07                 DB      7
  00292 08                 DB      8
  00293 07                 DB      7
?_Trans@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ENDP ; std::_Parser<char const *,char,std::regex_traits<char> >::_Trans
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Is_esc@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@ABE_NXZ
_TEXT   SEGMENT
tv82 = -12                                          ; size = 4
_this$ = -8                                   ; size = 4
__Ch0$ = -4                                   ; size = 4
?_Is_esc@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@ABE_NXZ PROC ; std::_Parser<char const *,char,std::regex_traits<char> >::_Is_esc, COMDAT
; _this$ = ecx

; 4985 :        {     // assumes _Pat != _End

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 0c   sub         esp, 12                        ; 0000000cH
  00006 89 4d f8   mov         DWORD PTR _this$[ebp], ecx

; 4986 :        _FwdIt _Ch0 = _Pat;

  00009 8b 45 f8   mov         eax, DWORD PTR _this$[ebp]
  0000c 8b 08        mov         ecx, DWORD PTR [eax]
  0000e 89 4d fc   mov         DWORD PTR __Ch0$[ebp], ecx

; 4987 :        return (++_Ch0 != _End

  00011 8b 55 fc   mov         edx, DWORD PTR __Ch0$[ebp]
  00014 83 c2 01   add         edx, 1
  00017 89 55 fc   mov         DWORD PTR __Ch0$[ebp], edx
  0001a 8b 45 f8   mov         eax, DWORD PTR _this$[ebp]
  0001d 8b 4d fc   mov         ecx, DWORD PTR __Ch0$[ebp]
  00020 3b 48 08   cmp         ecx, DWORD PTR [eax+8]
  00023 74 4b        je  SHORT $LN6@Is_esc
  00025 8b 55 f8   mov         edx, DWORD PTR _this$[ebp]
  00028 8b 42 50   mov         eax, DWORD PTR [edx+80]
  0002b 83 e0 08   and         eax, 8
  0002e 75 16        jne         SHORT $LN4@Is_esc
  00030 8b 4d fc   mov         ecx, DWORD PTR __Ch0$[ebp]
  00033 0f be 11   movsx       edx, BYTE PTR [ecx]
  00036 83 fa 28   cmp         edx, 40                        ; 00000028H
  00039 74 2c        je  SHORT $LN5@Is_esc
  0003b 8b 45 fc   mov         eax, DWORD PTR __Ch0$[ebp]
  0003e 0f be 08   movsx       ecx, BYTE PTR [eax]
  00041 83 f9 29   cmp         ecx, 41                        ; 00000029H
  00044 74 21        je  SHORT $LN5@Is_esc
$LN4@Is_esc:
  00046 8b 55 f8   mov         edx, DWORD PTR _this$[ebp]
  00049 8b 42 50   mov         eax, DWORD PTR [edx+80]
  0004c 83 e0 10   and         eax, 16                        ; 00000010H
  0004f 75 1f        jne         SHORT $LN6@Is_esc
  00051 8b 4d fc   mov         ecx, DWORD PTR __Ch0$[ebp]
  00054 0f be 11   movsx       edx, BYTE PTR [ecx]
  00057 83 fa 7b   cmp         edx, 123             ; 0000007bH
  0005a 74 0b        je  SHORT $LN5@Is_esc
  0005c 8b 45 fc   mov         eax, DWORD PTR __Ch0$[ebp]
  0005f 0f be 08   movsx       ecx, BYTE PTR [eax]
  00062 83 f9 7d   cmp         ecx, 125             ; 0000007dH
  00065 75 09        jne         SHORT $LN6@Is_esc
$LN5@Is_esc:
  00067 c7 45 f4 01 00
        00 00          mov         DWORD PTR tv82[ebp], 1
  0006e eb 07        jmp         SHORT $LN8@Is_esc
$LN6@Is_esc:
  00070 c7 45 f4 00 00
        00 00          mov         DWORD PTR tv82[ebp], 0
$LN8@Is_esc:
  00077 8a 45 f4   mov         al, BYTE PTR tv82[ebp]

; 4988 :              && ((!(_L_flags & _L_nex_grp)
; 4989 :                  && (*_Ch0 == _Meta_lpar || *_Ch0 == _Meta_rpar))
; 4990 :              || (!(_L_flags & _L_nex_rep)
; 4991 :                  && (*_Ch0 == _Meta_lbr || *_Ch0 == _Meta_rbr))));
; 4992 :        }

  0007a 8b e5        mov         esp, ebp
  0007c 5d                 pop     ebp
  0007d c3                 ret     0
?_Is_esc@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@ABE_NXZ ENDP ; std::_Parser<char const *,char,std::regex_traits<char> >::_Is_esc
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Error@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXW4error_type@regex_constants@2@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Code$ = 8                                   ; size = 4
?_Error@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXW4error_type@regex_constants@2@@Z PROC ; std::_Parser<char const *,char,std::regex_traits<char> >::_Error, COMDAT
; _this$ = ecx

; 4977 :        {     // handle error

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 4978 :        _Xregex_error(_Code);

  00007 8b 45 08   mov         eax, DWORD PTR __Code$[ebp]
  0000a 50                 push    eax
  0000b e8 00 00 00 00     call    ?_Xregex_error@std@@YAXW4error_type@regex_constants@1@@Z ; std::_Xregex_error
$LN2@Error:

; 4979 :        }

  00010 8b e5        mov         esp, ebp
  00012 5d                 pop     ebp
  00013 c2 04 00   ret         4
?_Error@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ENDP ; std::_Parser<char const *,char,std::regex_traits<char> >::_Error
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Mark_count@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@QBEIXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Mark_count@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@QBEIXZ PROC ; std::_Parser<char const *,char,std::regex_traits<char> >::_Mark_count, COMDAT
; _this$ = ecx

; 2231 :              {   // return number of capture groups

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2232 :              return (_Grp_idx + 1);

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a 8b 40 0c   mov         eax, DWORD PTR [eax+12]
  0000d 83 c0 01   add         eax, 1

; 2233 :              }

  00010 8b e5        mov         esp, ebp
  00012 5d                 pop     ebp
  00013 c3                 ret     0
?_Mark_count@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@QBEIXZ ENDP ; std::_Parser<char const *,char,std::regex_traits<char> >::_Mark_count
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Compile@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Root_node@2@XZ
_TEXT   SEGMENT
__Pos1$2 = -28                                      ; size = 4
__Res$ = -24                                            ; size = 4
_this$ = -20                                            ; size = 4
__$EHRec$ = -16                               ; size = 16
?_Compile@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Root_node@2@XZ PROC ; std::_Parser<char const *,char,std::regex_traits<char> >::_Compile, COMDAT
; _this$ = ecx

; 5795 :        {     // compile regular expression

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 6a ff        push        -1
  00005 68 00 00 00 00     push    __ehhandler$?_Compile@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Root_node@2@XZ
  0000a 64 a1 00 00 00
        00           mov     eax, DWORD PTR fs:0
  00010 50                 push    eax
  00011 51                 push    ecx
  00012 83 ec 0c   sub         esp, 12                        ; 0000000cH
  00015 53                 push    ebx
  00016 56                 push    esi
  00017 57                 push    edi
  00018 a1 00 00 00 00     mov     eax, DWORD PTR ___security_cookie
  0001d 33 c5        xor         eax, ebp
  0001f 50                 push    eax
  00020 8d 45 f4   lea         eax, DWORD PTR __$EHRec$[ebp+4]
  00023 64 a3 00 00 00
        00           mov     DWORD PTR fs:0, eax
  00029 89 65 f0   mov         DWORD PTR __$EHRec$[ebp], esp
  0002c 89 4d ec   mov         DWORD PTR _this$[ebp], ecx

; 5796 :        _Root_node *_Res = 0;

  0002f c7 45 e8 00 00
        00 00          mov         DWORD PTR __Res$[ebp], 0

; 5797 :        _TRY_BEGIN

  00036 c7 45 fc 00 00
        00 00          mov         DWORD PTR __$EHRec$[ebp+12], 0

; 5798 :        _Node_base *_Pos1 = _Nfa._Begin_capture_group(0);

  0003d 6a 00        push        0
  0003f 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  00042 83 c1 24   add         ecx, 36                        ; 00000024H
  00045 e8 00 00 00 00     call    ?_Begin_capture_group@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Node_base@2@I@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Begin_capture_group
  0004a 89 45 e4   mov         DWORD PTR __Pos1$2[ebp], eax

; 5799 :        _Disjunction();

  0004d 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  00050 e8 00 00 00 00     call    ?_Disjunction@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Disjunction

; 5800 :        if (_Pat != _End)

  00055 8b 45 ec   mov         eax, DWORD PTR _this$[ebp]
  00058 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  0005b 8b 10        mov         edx, DWORD PTR [eax]
  0005d 3b 51 08   cmp         edx, DWORD PTR [ecx+8]
  00060 74 0a        je  SHORT $LN3@Compile

; 5801 :              _Error(regex_constants::error_syntax);

  00062 6a 0e        push        14             ; 0000000eH
  00064 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  00067 e8 00 00 00 00     call    ?_Error@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_Error
$LN3@Compile:

; 5802 :        _Nfa._End_group(_Pos1);

  0006c 8b 45 e4   mov         eax, DWORD PTR __Pos1$2[ebp]
  0006f 50                 push    eax
  00070 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  00073 83 c1 24   add         ecx, 36                        ; 00000024H
  00076 e8 00 00 00 00     call    ?_End_group@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXPAV_Node_base@2@@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_End_group

; 5803 :        _Res = _Nfa._End_pattern();

  0007b 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  0007e 83 c1 24   add         ecx, 36                        ; 00000024H
  00081 e8 00 00 00 00     call    ?_End_pattern@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Root_node@2@XZ ; std::_Builder<char const *,char,std::regex_traits<char> >::_End_pattern
  00086 89 45 e8   mov         DWORD PTR __Res$[ebp], eax

; 5804 :        _Res->_Fl = _Flags;

  00089 8b 4d e8   mov         ecx, DWORD PTR __Res$[ebp]
  0008c 8b 55 ec   mov         edx, DWORD PTR _this$[ebp]
  0008f 8b 42 40   mov         eax, DWORD PTR [edx+64]
  00092 89 41 14   mov         DWORD PTR [ecx+20], eax

; 5805 :        _Res->_Marks = _Mark_count();

  00095 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  00098 e8 00 00 00 00     call    ?_Mark_count@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@QBEIXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Mark_count
  0009d 8b 4d e8   mov         ecx, DWORD PTR __Res$[ebp]
  000a0 89 41 1c   mov         DWORD PTR [ecx+28], eax

; 5806 :        _Calculate_loop_simplicity(_Res, 0, 0);

  000a3 6a 00        push        0
  000a5 6a 00        push        0
  000a7 8b 55 e8   mov         edx, DWORD PTR __Res$[ebp]
  000aa 52                 push    edx
  000ab e8 00 00 00 00     call    ?_Calculate_loop_simplicity@std@@YAXPAV_Node_base@1@0PAV_Node_rep@1@@Z ; std::_Calculate_loop_simplicity
  000b0 83 c4 0c   add         esp, 12                        ; 0000000cH
  000b3 eb 1a        jmp         SHORT $LN5@Compile
__catch$?_Compile@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Root_node@2@XZ$0:

; 5807 :        _CATCH_ALL
; 5808 :        _Nfa._Discard_pattern();

  000b5 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  000b8 83 c1 24   add         ecx, 36                        ; 00000024H
  000bb e8 00 00 00 00     call    ?_Discard_pattern@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXXZ ; std::_Builder<char const *,char,std::regex_traits<char> >::_Discard_pattern

; 5809 :        _RERAISE;

  000c0 6a 00        push        0
  000c2 6a 00        push        0
  000c4 e8 00 00 00 00     call    __CxxThrowException@8

; 5810 :        _CATCH_END

  000c9 b8 00 00 00 00     mov     eax, $LN8@Compile
  000ce c3                 ret     0
$LN5@Compile:
  000cf c7 45 fc ff ff
        ff ff          mov         DWORD PTR __$EHRec$[ebp+12], -1
  000d6 eb 07        jmp         SHORT __tryend$?_Compile@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Root_node@2@XZ$1
$LN8@Compile:
  000d8 c7 45 fc ff ff
        ff ff          mov         DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Compile@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Root_node@2@XZ$1:

; 5811 :        return (_Res);

  000df 8b 45 e8   mov         eax, DWORD PTR __Res$[ebp]
$LN4@Compile:

; 5812 :        }

  000e2 8b 4d f4   mov         ecx, DWORD PTR __$EHRec$[ebp+4]
  000e5 64 89 0d 00 00
        00 00          mov         DWORD PTR fs:0, ecx
  000ec 59                 pop     ecx
  000ed 5f                 pop     edi
  000ee 5e                 pop     esi
  000ef 5b                 pop     ebx
  000f0 8b e5        mov         esp, ebp
  000f2 5d                 pop     ebp
  000f3 c3                 ret     0
_TEXT   ENDS
;       COMDAT text$x
text$x  SEGMENT
__ehhandler$?_Compile@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Root_node@2@XZ:
  00000 8b 54 24 08        mov   edx, DWORD PTR [esp+8]
  00004 8d 42 0c   lea         eax, DWORD PTR [edx+12]
  00007 8b 4a e0   mov         ecx, DWORD PTR [edx-32]
  0000a 33 c8        xor         ecx, eax
  0000c e8 00 00 00 00     call    @__security_check_cookie@4
  00011 b8 00 00 00 00     mov     eax, OFFSET __ehfuncinfo$?_Compile@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Root_node@2@XZ
  00016 e9 00 00 00 00     jmp     ___CxxFrameHandler3
text$x  ENDS
?_Compile@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Root_node@2@XZ ENDP ; std::_Parser<char const *,char,std::regex_traits<char> >::_Compile
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ??0?$_Parser@PBDDV?$regex_traits@D@std@@@std@@QAE@ABV?$regex_traits@D@1@PBD1W4syntax_option_type@regex_constants@1@@Z
_TEXT   SEGMENT
tv157 = -32                                   ; size = 4
tv156 = -28                                   ; size = 4
tv155 = -24                                   ; size = 4
tv154 = -20                                   ; size = 4
tv153 = -16                                   ; size = 4
tv152 = -12                                   ; size = 4
_this$ = -8                                   ; size = 4
$T1 = -1                                                ; size = 1
__Tr$ = 8                                         ; size = 4
__Pfirst$ = 12                                      ; size = 4
__Plast$ = 16                                     ; size = 4
__Fx$ = 20                                          ; size = 4
??0?$_Parser@PBDDV?$regex_traits@D@std@@@std@@QAE@ABV?$regex_traits@D@1@PBD1W4syntax_option_type@regex_constants@1@@Z PROC ; std::_Parser<char const *,char,std::regex_traits<char> >::_Parser<char const *,char,std::regex_traits<char> >, COMDAT
; _this$ = ecx

; 5824 :        {     // construct

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 20   sub         esp, 32                        ; 00000020H
  00006 89 4d f8   mov         DWORD PTR _this$[ebp], ecx

; 5821 :        : _Pat(_Pfirst), _Begin(_Pfirst), _End(_Plast),

  00009 8b 45 f8   mov         eax, DWORD PTR _this$[ebp]
  0000c 8b 4d 0c   mov         ecx, DWORD PTR __Pfirst$[ebp]
  0000f 89 08        mov         DWORD PTR [eax], ecx
  00011 8b 55 f8   mov         edx, DWORD PTR _this$[ebp]
  00014 8b 45 0c   mov         eax, DWORD PTR __Pfirst$[ebp]
  00017 89 42 04   mov         DWORD PTR [edx+4], eax
  0001a 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  0001d 8b 55 10   mov         edx, DWORD PTR __Plast$[ebp]
  00020 89 51 08   mov         DWORD PTR [ecx+8], edx

; 5822 :              _Grp_idx(0), _Disj_count(0), _Finished_grps(0),

  00023 8b 45 f8   mov         eax, DWORD PTR _this$[ebp]
  00026 c7 40 0c 00 00
        00 00          mov         DWORD PTR [eax+12], 0
  0002d 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00030 c7 41 10 00 00
        00 00          mov         DWORD PTR [ecx+16], 0
  00037 8d 4d ff   lea         ecx, DWORD PTR $T1[ebp]
  0003a e8 00 00 00 00     call    ??0?$allocator@_N@std@@QAE@XZ ; std::allocator<bool>::allocator<bool>
  0003f 50                 push    eax
  00040 6a 00        push        0
  00042 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00045 83 c1 14   add         ecx, 20                        ; 00000014H
  00048 e8 00 00 00 00     call    ??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@IABV?$allocator@_N@1@@Z ; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >

; 5823 :              _Nfa(_Tr, _Fx), _Traits(_Tr), _Flags(_Fx)

  0004d 8b 55 14   mov         edx, DWORD PTR __Fx$[ebp]
  00050 52                 push    edx
  00051 8b 45 08   mov         eax, DWORD PTR __Tr$[ebp]
  00054 50                 push    eax
  00055 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00058 83 c1 24   add         ecx, 36                        ; 00000024H
  0005b e8 00 00 00 00     call    ??0?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAE@ABV?$regex_traits@D@1@W4syntax_option_type@regex_constants@1@@Z ; std::_Builder<char const *,char,std::regex_traits<char> >::_Builder<char const *,char,std::regex_traits<char> >
  00060 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00063 8b 55 08   mov         edx, DWORD PTR __Tr$[ebp]
  00066 89 51 3c   mov         DWORD PTR [ecx+60], edx
  00069 8b 45 f8   mov         eax, DWORD PTR _this$[ebp]
  0006c 8b 4d 14   mov         ecx, DWORD PTR __Fx$[ebp]
  0006f 89 48 40   mov         DWORD PTR [eax+64], ecx

; 5825 :        using namespace regex_constants;
; 5826 :        _L_flags = (_Flags & _Gmask) == ECMAScript

  00072 6a 3f        push        63             ; 0000003fH
  00074 8b 55 f8   mov         edx, DWORD PTR _this$[ebp]
  00077 8b 42 40   mov         eax, DWORD PTR [edx+64]
  0007a 50                 push    eax
  0007b e8 00 00 00 00     call    ??Iregex_constants@std@@YA?AW4syntax_option_type@01@W4201@0@Z ; std::regex_constants::operator&
  00080 83 c4 08   add         esp, 8
  00083 83 f8 01   cmp         eax, 1
  00086 0f 84 de 00 00
        00           je      $LN4@Parser
  0008c 6a 3f        push        63             ; 0000003fH
  0008e 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00091 8b 51 40   mov         edx, DWORD PTR [ecx+64]
  00094 52                 push    edx
  00095 e8 00 00 00 00     call    ??Iregex_constants@std@@YA?AW4syntax_option_type@01@W4201@0@Z ; std::regex_constants::operator&
  0009a 83 c4 08   add         esp, 8
  0009d 85 c0        test        eax, eax
  0009f 0f 84 c5 00 00
        00           je      $LN4@Parser
  000a5 6a 3f        push        63             ; 0000003fH
  000a7 8b 45 f8   mov         eax, DWORD PTR _this$[ebp]
  000aa 8b 48 40   mov         ecx, DWORD PTR [eax+64]
  000ad 51                 push    ecx
  000ae e8 00 00 00 00     call    ??Iregex_constants@std@@YA?AW4syntax_option_type@01@W4201@0@Z ; std::regex_constants::operator&
  000b3 83 c4 08   add         esp, 8
  000b6 83 f8 02   cmp         eax, 2
  000b9 75 0c        jne         SHORT $LN13@Parser
  000bb c7 45 e4 00 03
        00 6e          mov         DWORD PTR tv156[ebp], 1845494528 ; 6e000300H
  000c2 e9 9b 00 00 00     jmp     $LN14@Parser
$LN13@Parser:
  000c7 6a 3f        push        63             ; 0000003fH
  000c9 8b 55 f8   mov         edx, DWORD PTR _this$[ebp]
  000cc 8b 42 40   mov         eax, DWORD PTR [edx+64]
  000cf 50                 push    eax
  000d0 e8 00 00 00 00     call    ??Iregex_constants@std@@YA?AW4syntax_option_type@01@W4201@0@Z ; std::regex_constants::operator&
  000d5 83 c4 08   add         esp, 8
  000d8 83 f8 04   cmp         eax, 4
  000db 75 09        jne         SHORT $LN11@Parser
  000dd c7 45 e8 1b 00
        80 70          mov         DWORD PTR tv155[ebp], 1887436827 ; 7080001bH
  000e4 eb 76        jmp         SHORT $LN12@Parser
$LN11@Parser:
  000e6 6a 3f        push        63             ; 0000003fH
  000e8 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  000eb 8b 51 40   mov         edx, DWORD PTR [ecx+64]
  000ee 52                 push    edx
  000ef e8 00 00 00 00     call    ??Iregex_constants@std@@YA?AW4syntax_option_type@01@W4201@0@Z ; std::regex_constants::operator&
  000f4 83 c4 08   add         esp, 8
  000f7 83 f8 08   cmp         eax, 8
  000fa 75 09        jne         SHORT $LN9@Parser
  000fc c7 45 ec 1b a0
        81 71          mov         DWORD PTR tv154[ebp], 1904320539 ; 7181a01bH
  00103 eb 51        jmp         SHORT $LN10@Parser
$LN9@Parser:
  00105 6a 3f        push        63             ; 0000003fH
  00107 8b 45 f8   mov         eax, DWORD PTR _this$[ebp]
  0010a 8b 48 40   mov         ecx, DWORD PTR [eax+64]
  0010d 51                 push    ecx
  0010e e8 00 00 00 00     call    ??Iregex_constants@std@@YA?AW4syntax_option_type@01@W4201@0@Z ; std::regex_constants::operator&
  00113 83 c4 08   add         esp, 8
  00116 83 f8 10   cmp         eax, 16                        ; 00000010H
  00119 75 09        jne         SHORT $LN7@Parser
  0011b c7 45 f0 04 03
        08 6e          mov         DWORD PTR tv153[ebp], 1846018820 ; 6e080304H
  00122 eb 2c        jmp         SHORT $LN8@Parser
$LN7@Parser:
  00124 6a 3f        push        63             ; 0000003fH
  00126 8b 55 f8   mov         edx, DWORD PTR _this$[ebp]
  00129 8b 42 40   mov         eax, DWORD PTR [edx+64]
  0012c 50                 push    eax
  0012d e8 00 00 00 00     call    ??Iregex_constants@std@@YA?AW4syntax_option_type@01@W4201@0@Z ; std::regex_constants::operator&
  00132 83 c4 08   add         esp, 8
  00135 83 f8 20   cmp         eax, 32                        ; 00000020H
  00138 75 09        jne         SHORT $LN5@Parser
  0013a c7 45 f4 1f 00
        88 70          mov         DWORD PTR tv152[ebp], 1887961119 ; 7088001fH
  00141 eb 07        jmp         SHORT $LN6@Parser
$LN5@Parser:
  00143 c7 45 f4 00 00
        00 00          mov         DWORD PTR tv152[ebp], 0
$LN6@Parser:
  0014a 8b 4d f4   mov         ecx, DWORD PTR tv152[ebp]
  0014d 89 4d f0   mov         DWORD PTR tv153[ebp], ecx
$LN8@Parser:
  00150 8b 55 f0   mov         edx, DWORD PTR tv153[ebp]
  00153 89 55 ec   mov         DWORD PTR tv154[ebp], edx
$LN10@Parser:
  00156 8b 45 ec   mov         eax, DWORD PTR tv154[ebp]
  00159 89 45 e8   mov         DWORD PTR tv155[ebp], eax
$LN12@Parser:
  0015c 8b 4d e8   mov         ecx, DWORD PTR tv155[ebp]
  0015f 89 4d e4   mov         DWORD PTR tv156[ebp], ecx
$LN14@Parser:
  00162 8b 55 e4   mov         edx, DWORD PTR tv156[ebp]
  00165 89 55 e0   mov         DWORD PTR tv157[ebp], edx
  00168 eb 07        jmp         SHORT $LN15@Parser
$LN4@Parser:
  0016a c7 45 e0 fb 5d
        77 08          mov         DWORD PTR tv157[ebp], 142040571 ; 08775dfbH
$LN15@Parser:
  00171 8b 45 f8   mov         eax, DWORD PTR _this$[ebp]
  00174 8b 4d e0   mov         ecx, DWORD PTR tv157[ebp]
  00177 89 48 50   mov         DWORD PTR [eax+80], ecx

; 5827 :              || (_Flags & _Gmask) == 0 ? _ECMA_flags
; 5828 :              : (_Flags & _Gmask) == basic ? _Basic_flags
; 5829 :              : (_Flags & _Gmask) == extended ? _Extended_flags
; 5830 :              : (_Flags & _Gmask) == awk ? _Awk_flags
; 5831 :              : (_Flags & _Gmask) == grep ? _Grep_flags
; 5832 :              : (_Flags & _Gmask) == egrep ? _Egrep_flags
; 5833 :              : 0;
; 5834 :        if (_L_flags & _L_mtch_long)

  0017a 8b 55 f8   mov         edx, DWORD PTR _this$[ebp]
  0017d 8b 42 50   mov         eax, DWORD PTR [edx+80]
  00180 25 00 00 00 40     and     eax, 1073741824                ; 40000000H
  00185 74 0b        je  SHORT $LN2@Parser

; 5835 :              _Nfa._Setlong();

  00187 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  0018a 83 c1 24   add         ecx, 36                        ; 00000024H
  0018d e8 00 00 00 00     call    ?_Setlong@?$_Builder@PBDDV?$regex_traits@D@std@@@std@@QAEXXZ ; std::_Builder<char const *,char,std::regex_traits<char> >::_Setlong
$LN2@Parser:

; 5836 :        _Trans();

  00192 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00195 e8 00 00 00 00     call    ?_Trans@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@AAEXXZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Trans

; 5837 :        }

  0019a 8b 45 f8   mov         eax, DWORD PTR _this$[ebp]
  0019d 8b e5        mov         esp, ebp
  0019f 5d                 pop     ebp
  001a0 c2 10 00   ret         16           ; 00000010H
??0?$_Parser@PBDDV?$regex_traits@D@std@@@std@@QAE@ABV?$regex_traits@D@1@PBD1W4syntax_option_type@regex_constants@1@@Z ENDP ; std::_Parser<char const *,char,std::regex_traits<char> >::_Parser<char const *,char,std::regex_traits<char> >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ??G?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Right$ = 8                                            ; size = 4
??G?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@@Z PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator-, COMDAT
; _this$ = ecx

; 390  :              {   // return difference of iterators

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 391  :              return (*(_Mybase *)this - _Right);

  00007 8b 45 08   mov         eax, DWORD PTR __Right$[ebp]
  0000a 50                 push    eax
  0000b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000e e8 00 00 00 00     call    ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator-

; 392  :              }

  00013 8b e5        mov         esp, ebp
  00015 5d                 pop     ebp
  00016 c2 04 00   ret         4
??G?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@@Z ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator-
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*, COMDAT
; _this$ = ecx

; 331  :              {   // return designated object

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 332  :              return ((reference)**(_Mybase *)this);

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*

; 333  :              }

  0000f 8b e5        mov         esp, ebp
  00011 5d                 pop     ebp
  00012 c3                 ret     0
??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Parg$ = 8                                   ; size = 4
__Pstring$ = 12                               ; size = 4
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT
; _this$ = ecx

; 314  :              {   // construct with pointer _Parg

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 313  :              : _Mybase(_Parg, _Pstring)

  00007 8b 45 0c   mov         eax, DWORD PTR __Pstring$[ebp]
  0000a 50                 push    eax
  0000b 8b 4d 08   mov         ecx, DWORD PTR __Parg$[ebp]
  0000e 51                 push    ecx
  0000f 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00012 e8 00 00 00 00     call    ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >

; 315  :              }

  00017 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0001a 8b e5        mov         esp, ebp
  0001c 5d                 pop     ebp
  0001d c2 08 00   ret         8
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;       COMDAT ??$?9V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z
_TEXT   SEGMENT
tv69 = -4                                         ; size = 4
__Left$ = 8                                   ; size = 4
__Right$ = 12                                     ; size = 4
??$?9V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z PROC ; std::operator!=<std::allocator<char>,std::allocator<char> >, COMDAT

; 923  :        {     // test for allocator inequality

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx

; 924  :        return (!(_Left == _Right));

  00004 8b 45 0c   mov         eax, DWORD PTR __Right$[ebp]
  00007 50                 push    eax
  00008 8b 4d 08   mov         ecx, DWORD PTR __Left$[ebp]
  0000b 51                 push    ecx
  0000c e8 00 00 00 00     call    ??$?8V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ; std::operator==<std::allocator<char>,std::allocator<char> >
  00011 83 c4 08   add         esp, 8
  00014 0f b6 d0   movzx       edx, al
  00017 85 d2        test        edx, edx
  00019 75 09        jne         SHORT $LN3@operator
  0001b c7 45 fc 01 00
        00 00          mov         DWORD PTR tv69[ebp], 1
  00022 eb 07        jmp         SHORT $LN4@operator
$LN3@operator:
  00024 c7 45 fc 00 00
        00 00          mov         DWORD PTR tv69[ebp], 0
$LN4@operator:
  0002b 8a 45 fc   mov         al, BYTE PTR tv69[ebp]

; 925  :        }

  0002e 8b e5        mov         esp, ebp
  00030 5d                 pop     ebp
  00031 c3                 ret     0
??$?9V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ENDP ; std::operator!=<std::allocator<char>,std::allocator<char> >
_TEXT   ENDS
; Function compile flags: /Odtp
;       COMDAT ??_G?$collate@D@std@@MAEPAXI@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
___flags$ = 8                                     ; size = 4
??_G?$collate@D@std@@MAEPAXI@Z PROC           ; std::collate<char>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ??1?$collate@D@std@@MAE@XZ ; std::collate<char>::~collate<char>
  0000f 8b 45 08   mov         eax, DWORD PTR ___flags$[ebp]
  00012 83 e0 01   and         eax, 1
  00015 74 0e        je  SHORT $LN2@scalar
  00017 6a 10        push        16             ; 00000010H
  00019 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001c 51                 push    ecx
  0001d e8 00 00 00 00     call    ??3@YAXPAXI@Z                ; operator delete
  00022 83 c4 08   add         esp, 8
$LN2@scalar:
  00025 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00028 8b e5        mov         esp, ebp
  0002a 5d                 pop     ebp
  0002b c2 04 00   ret         4
??_G?$collate@D@std@@MAEPAXI@Z ENDP           ; std::collate<char>::`scalar deleting destructor'
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\locale
;       COMDAT ?do_hash@?$collate@D@std@@MBEJPBD0@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__First$ = 8                                            ; size = 4
__Last$ = 12                                            ; size = 4
?do_hash@?$collate@D@std@@MBEJPBD0@Z PROC             ; std::collate<char>::do_hash, COMDAT
; _this$ = ecx

; 122  :              {   // compute hash code for [_First, _Last)

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 123  :              _DEBUG_RANGE(_First, _Last);
; 124  :              return ((long)_Hash_seq((const unsigned char *)_First,

  00007 8b 45 0c   mov         eax, DWORD PTR __Last$[ebp]
  0000a 2b 45 08   sub         eax, DWORD PTR __First$[ebp]
  0000d 50                 push    eax
  0000e 8b 4d 08   mov         ecx, DWORD PTR __First$[ebp]
  00011 51                 push    ecx
  00012 e8 00 00 00 00     call    ?_Hash_seq@std@@YAIPBEI@Z ; std::_Hash_seq
  00017 83 c4 08   add         esp, 8

; 125  :                  (_Last - _First) * sizeof (_Elem)));
; 126  :              }

  0001a 8b e5        mov         esp, ebp
  0001c 5d                 pop     ebp
  0001d c2 08 00   ret         8
?do_hash@?$collate@D@std@@MBEJPBD0@Z ENDP             ; std::collate<char>::do_hash
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\locale
;       COMDAT ?do_transform@?$collate@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PBD0@Z
_TEXT   SEGMENT
$T1 = -44                                         ; size = 4
$T2 = -40                                         ; size = 4
_this$ = -36                                            ; size = 4
__Count$ = -32                                      ; size = 4
__Str$ = -28                                            ; size = 24
__$ArrayPad$ = -4                                 ; size = 4
___$ReturnUdt$ = 8                                  ; size = 4
__First$ = 12                                     ; size = 4
__Last$ = 16                                            ; size = 4
?do_transform@?$collate@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PBD0@Z PROC ; std::collate<char>::do_transform, COMDAT
; _this$ = ecx

; 103  :              {   // transform [_First, _Last) to key string

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 2c   sub         esp, 44                        ; 0000002cH
  00006 a1 00 00 00 00     mov     eax, DWORD PTR ___security_cookie
  0000b 33 c5        xor         eax, ebp
  0000d 89 45 fc   mov         DWORD PTR __$ArrayPad$[ebp], eax
  00010 56                 push    esi
  00011 89 4d dc   mov         DWORD PTR _this$[ebp], ecx

; 104  :              _DEBUG_RANGE(_First, _Last);
; 105  :              size_t _Count;
; 106  :              string_type _Str;

  00014 8d 4d e4   lea         ecx, DWORD PTR __Str$[ebp]
  00017 e8 00 00 00 00     call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 107  :
; 108  :              for (_Count = _Last - _First; 0 < _Count; )

  0001c 8b 45 10   mov         eax, DWORD PTR __Last$[ebp]
  0001f 2b 45 0c   sub         eax, DWORD PTR __First$[ebp]
  00022 89 45 e0   mov         DWORD PTR __Count$[ebp], eax
$LN4@do_transfo:
  00025 83 7d e0 00        cmp   DWORD PTR __Count$[ebp], 0
  00029 76 6b        jbe         SHORT $LN3@do_transfo

; 109  :                  {       // grow string if locale-specific strxfrm fails
; 110  :                  _Str.resize(_Count);

  0002b 8b 4d e0   mov         ecx, DWORD PTR __Count$[ebp]
  0002e 51                 push    ecx
  0002f 8d 4d e4   lea         ecx, DWORD PTR __Str$[ebp]
  00032 e8 00 00 00 00     call    ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize

; 111  :                  if ((_Count = _LStrxfrm(&*_Str.begin(),
; 112  :                          &*_Str.begin() + _Str.size(),
; 113  :                                  _First, _Last, &_Coll)) <= _Str.size())

  00037 8b 55 dc   mov         edx, DWORD PTR _this$[ebp]
  0003a 83 c2 08   add         edx, 8
  0003d 52                 push    edx
  0003e 8b 45 10   mov         eax, DWORD PTR __Last$[ebp]
  00041 50                 push    eax
  00042 8b 4d 0c   mov         ecx, DWORD PTR __First$[ebp]
  00045 51                 push    ecx
  00046 8d 55 d8   lea         edx, DWORD PTR $T2[ebp]
  00049 52                 push    edx
  0004a 8d 4d e4   lea         ecx, DWORD PTR __Str$[ebp]
  0004d e8 00 00 00 00     call    ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
  00052 8b c8        mov         ecx, eax
  00054 e8 00 00 00 00     call    ??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
  00059 8b f0        mov         esi, eax
  0005b 8d 4d e4   lea         ecx, DWORD PTR __Str$[ebp]
  0005e e8 00 00 00 00     call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  00063 03 f0        add         esi, eax
  00065 56                 push    esi
  00066 8d 45 d4   lea         eax, DWORD PTR $T1[ebp]
  00069 50                 push    eax
  0006a 8d 4d e4   lea         ecx, DWORD PTR __Str$[ebp]
  0006d e8 00 00 00 00     call    ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
  00072 8b c8        mov         ecx, eax
  00074 e8 00 00 00 00     call    ??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
  00079 50                 push    eax
  0007a e8 00 00 00 00     call    ??$_LStrxfrm@D@std@@YAIPAD0PBD1PBU_Collvec@@@Z ; std::_LStrxfrm<char>
  0007f 83 c4 14   add         esp, 20                        ; 00000014H
  00082 89 45 e0   mov         DWORD PTR __Count$[ebp], eax
  00085 8d 4d e4   lea         ecx, DWORD PTR __Str$[ebp]
  00088 e8 00 00 00 00     call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  0008d 39 45 e0   cmp         DWORD PTR __Count$[ebp], eax
  00090 77 02        ja  SHORT $LN5@do_transfo

; 114  :                          break;

  00092 eb 02        jmp         SHORT $LN3@do_transfo
$LN5@do_transfo:

; 115  :                  }

  00094 eb 8f        jmp         SHORT $LN4@do_transfo
$LN3@do_transfo:

; 116  :              _Str.resize(_Count);

  00096 8b 4d e0   mov         ecx, DWORD PTR __Count$[ebp]
  00099 51                 push    ecx
  0009a 8d 4d e4   lea         ecx, DWORD PTR __Str$[ebp]
  0009d e8 00 00 00 00     call    ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize

; 117  :              return (_Str);

  000a2 8d 55 e4   lea         edx, DWORD PTR __Str$[ebp]
  000a5 52                 push    edx
  000a6 8b 4d 08   mov         ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000a9 e8 00 00 00 00     call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  000ae 8d 4d e4   lea         ecx, DWORD PTR __Str$[ebp]
  000b1 e8 00 00 00 00     call    ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  000b6 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]

; 118  :              }

  000b9 5e                 pop     esi
  000ba 8b 4d fc   mov         ecx, DWORD PTR __$ArrayPad$[ebp]
  000bd 33 cd        xor         ecx, ebp
  000bf e8 00 00 00 00     call    @__security_check_cookie@4
  000c4 8b e5        mov         esp, ebp
  000c6 5d                 pop     ebp
  000c7 c2 0c 00   ret         12           ; 0000000cH
?do_transform@?$collate@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PBD0@Z ENDP ; std::collate<char>::do_transform
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\locale
;       COMDAT ?do_compare@?$collate@D@std@@MBEHPBD000@Z
_TEXT   SEGMENT
_this$ = -16                                            ; size = 4
tv74 = -12                                          ; size = 4
tv73 = -8                                         ; size = 4
__Ans$ = -4                                   ; size = 4
__First1$ = 8                                     ; size = 4
__Last1$ = 12                                     ; size = 4
__First2$ = 16                                      ; size = 4
__Last2$ = 20                                     ; size = 4
?do_compare@?$collate@D@std@@MBEHPBD000@Z PROC      ; std::collate<char>::do_compare, COMDAT
; _this$ = ecx

; 94   :              {   // compare [_First1, _Last1) to [_First2, _Last2)

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 10   sub         esp, 16                        ; 00000010H
  00006 89 4d f0   mov         DWORD PTR _this$[ebp], ecx

; 95   :              _DEBUG_RANGE(_First1, _Last1);
; 96   :              _DEBUG_RANGE(_First2, _Last2);
; 97   :              int _Ans = _LStrcoll(_First1, _Last1, _First2, _Last2, &_Coll);

  00009 8b 45 f0   mov         eax, DWORD PTR _this$[ebp]
  0000c 83 c0 08   add         eax, 8
  0000f 50                 push    eax
  00010 8b 4d 14   mov         ecx, DWORD PTR __Last2$[ebp]
  00013 51                 push    ecx
  00014 8b 55 10   mov         edx, DWORD PTR __First2$[ebp]
  00017 52                 push    edx
  00018 8b 45 0c   mov         eax, DWORD PTR __Last1$[ebp]
  0001b 50                 push    eax
  0001c 8b 4d 08   mov         ecx, DWORD PTR __First1$[ebp]
  0001f 51                 push    ecx
  00020 e8 00 00 00 00     call    ??$_LStrcoll@D@std@@YAHPBD000PBU_Collvec@@@Z ; std::_LStrcoll<char>
  00025 83 c4 14   add         esp, 20                        ; 00000014H
  00028 89 45 fc   mov         DWORD PTR __Ans$[ebp], eax

; 98   :              return (_Ans < 0 ? -1 : _Ans == 0 ? 0 : +1);

  0002b 83 7d fc 00        cmp   DWORD PTR __Ans$[ebp], 0
  0002f 7d 09        jge         SHORT $LN5@do_compare
  00031 c7 45 f4 ff ff
        ff ff          mov         DWORD PTR tv74[ebp], -1
  00038 eb 1c        jmp         SHORT $LN6@do_compare
$LN5@do_compare:
  0003a 83 7d fc 00        cmp   DWORD PTR __Ans$[ebp], 0
  0003e 75 09        jne         SHORT $LN3@do_compare
  00040 c7 45 f8 00 00
        00 00          mov         DWORD PTR tv73[ebp], 0
  00047 eb 07        jmp         SHORT $LN4@do_compare
$LN3@do_compare:
  00049 c7 45 f8 01 00
        00 00          mov         DWORD PTR tv73[ebp], 1
$LN4@do_compare:
  00050 8b 55 f8   mov         edx, DWORD PTR tv73[ebp]
  00053 89 55 f4   mov         DWORD PTR tv74[ebp], edx
$LN6@do_compare:
  00056 8b 45 f4   mov         eax, DWORD PTR tv74[ebp]

; 99   :              }

  00059 8b e5        mov         esp, ebp
  0005b 5d                 pop     ebp
  0005c c2 10 00   ret         16           ; 00000010H
?do_compare@?$collate@D@std@@MBEHPBD000@Z ENDP      ; std::collate<char>::do_compare
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\locale
;       COMDAT ?_Init@?$collate@D@std@@IAEXABV_Locinfo@2@@Z
_TEXT   SEGMENT
$T1 = -12                                         ; size = 8
_this$ = -4                                   ; size = 4
__Lobj$ = 8                                   ; size = 4
?_Init@?$collate@D@std@@IAEXABV_Locinfo@2@@Z PROC       ; std::collate<char>::_Init, COMDAT
; _this$ = ecx

; 88   :              {   // initialize from _Lobj

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 0c   sub         esp, 12                        ; 0000000cH
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 89   :              _Coll = _Lobj._Getcoll();

  00009 8d 45 f4   lea         eax, DWORD PTR $T1[ebp]
  0000c 50                 push    eax
  0000d 8b 4d 08   mov         ecx, DWORD PTR __Lobj$[ebp]
  00010 e8 00 00 00 00     call    ?_Getcoll@_Locinfo@std@@QBE?AU_Collvec@@XZ ; std::_Locinfo::_Getcoll
  00015 8b 08        mov         ecx, DWORD PTR [eax]
  00017 8b 50 04   mov         edx, DWORD PTR [eax+4]
  0001a 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0001d 89 48 08   mov         DWORD PTR [eax+8], ecx
  00020 89 50 0c   mov         DWORD PTR [eax+12], edx

; 90   :              }

  00023 8b e5        mov         esp, ebp
  00025 5d                 pop     ebp
  00026 c2 04 00   ret         4
?_Init@?$collate@D@std@@IAEXABV_Locinfo@2@@Z ENDP       ; std::collate<char>::_Init
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\locale
;       COMDAT ??1?$collate@D@std@@MAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??1?$collate@D@std@@MAE@XZ PROC               ; std::collate<char>::~collate<char>, COMDAT
; _this$ = ecx

; 74   :              {   // destroy the object

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a c7 00 00 00 00
        00           mov     DWORD PTR [eax], OFFSET ??_7?$collate@D@std@@6B@

; 75   :              _CSTD free(_Coll._LocaleName);

  00010 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00013 8b 51 0c   mov         edx, DWORD PTR [ecx+12]
  00016 52                 push    edx
  00017 e8 00 00 00 00     call    _free
  0001c 83 c4 04   add         esp, 4

; 76   :              }

  0001f 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00022 e8 00 00 00 00     call    ??1facet@locale@std@@MAE@XZ ; std::locale::facet::~facet
  00027 8b e5        mov         esp, ebp
  00029 5d                 pop     ebp
  0002a c3                 ret     0
??1?$collate@D@std@@MAE@XZ ENDP               ; std::collate<char>::~collate<char>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\locale
;       COMDAT ?_Getcat@?$collate@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT   SEGMENT
$T1 = -92                                         ; size = 52
tv91 = -40                                          ; size = 4
$T2 = -36                                         ; size = 4
$T3 = -32                                         ; size = 4
$T4 = -28                                         ; size = 24
__$ArrayPad$ = -4                                 ; size = 4
__Ppf$ = 8                                          ; size = 4
__Ploc$ = 12                                            ; size = 4
?_Getcat@?$collate@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::collate<char>::_Getcat, COMDAT

; 65   :              {   // return locale category mask and construct standard facet

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 5c   sub         esp, 92                        ; 0000005cH
  00006 a1 00 00 00 00     mov     eax, DWORD PTR ___security_cookie
  0000b 33 c5        xor         eax, ebp
  0000d 89 45 fc   mov         DWORD PTR __$ArrayPad$[ebp], eax
  00010 c7 45 e0 00 00
        00 00          mov         DWORD PTR $T3[ebp], 0

; 66   :              if (_Ppf != 0 && *_Ppf == 0)

  00017 83 7d 08 00        cmp   DWORD PTR __Ppf$[ebp], 0
  0001b 0f 84 86 00 00
        00           je      $LN2@Getcat
  00021 8b 45 08   mov         eax, DWORD PTR __Ppf$[ebp]
  00024 83 38 00   cmp         DWORD PTR [eax], 0
  00027 75 7e        jne         SHORT $LN2@Getcat

; 67   :                  *_Ppf = new collate<_Elem>(

  00029 6a 10        push        16             ; 00000010H
  0002b e8 00 00 00 00     call    ??2@YAPAXI@Z   ; operator new
  00030 83 c4 04   add         esp, 4
  00033 89 45 dc   mov         DWORD PTR $T2[ebp], eax
  00036 83 7d dc 00        cmp   DWORD PTR $T2[ebp], 0
  0003a 74 34        je  SHORT $LN4@Getcat
  0003c 6a 00        push        0
  0003e 8d 4d e4   lea         ecx, DWORD PTR $T4[ebp]
  00041 51                 push    ecx
  00042 8b 4d 0c   mov         ecx, DWORD PTR __Ploc$[ebp]
  00045 e8 00 00 00 00     call    ?name@locale@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::locale::name
  0004a 83 4d e0 01        or    DWORD PTR $T3[ebp], 1
  0004e 8b c8        mov         ecx, eax
  00050 e8 00 00 00 00     call    ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00055 50                 push    eax
  00056 8d 4d a4   lea         ecx, DWORD PTR $T1[ebp]
  00059 e8 00 00 00 00     call    ??0_Locinfo@std@@QAE@PBD@Z ; std::_Locinfo::_Locinfo
  0005e 83 4d e0 02        or    DWORD PTR $T3[ebp], 2
  00062 50                 push    eax
  00063 8b 4d dc   mov         ecx, DWORD PTR $T2[ebp]
  00066 e8 00 00 00 00     call    ??0?$collate@D@std@@QAE@ABV_Locinfo@1@I@Z ; std::collate<char>::collate<char>
  0006b 89 45 d8   mov         DWORD PTR tv91[ebp], eax
  0006e eb 07        jmp         SHORT $LN5@Getcat
$LN4@Getcat:
  00070 c7 45 d8 00 00
        00 00          mov         DWORD PTR tv91[ebp], 0
$LN5@Getcat:
  00077 8b 55 08   mov         edx, DWORD PTR __Ppf$[ebp]
  0007a 8b 45 d8   mov         eax, DWORD PTR tv91[ebp]
  0007d 89 02        mov         DWORD PTR [edx], eax
  0007f 8b 4d e0   mov         ecx, DWORD PTR $T3[ebp]
  00082 83 e1 02   and         ecx, 2
  00085 74 0c        je  SHORT $LN6@Getcat
  00087 83 65 e0 fd        and   DWORD PTR $T3[ebp], -3     ; fffffffdH
  0008b 8d 4d a4   lea         ecx, DWORD PTR $T1[ebp]
  0008e e8 00 00 00 00     call    ??1_Locinfo@std@@QAE@XZ      ; std::_Locinfo::~_Locinfo
$LN6@Getcat:
  00093 8b 55 e0   mov         edx, DWORD PTR $T3[ebp]
  00096 83 e2 01   and         edx, 1
  00099 74 0c        je  SHORT $LN2@Getcat
  0009b 83 65 e0 fe        and   DWORD PTR $T3[ebp], -2     ; fffffffeH
  0009f 8d 4d e4   lea         ecx, DWORD PTR $T4[ebp]
  000a2 e8 00 00 00 00     call    ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN2@Getcat:

; 68   :                          _Locinfo(_Ploc->name().c_str()));
; 69   :              return (_X_COLLATE);

  000a7 b8 01 00 00 00     mov     eax, 1

; 70   :              }

  000ac 8b 4d fc   mov         ecx, DWORD PTR __$ArrayPad$[ebp]
  000af 33 cd        xor         ecx, ebp
  000b1 e8 00 00 00 00     call    @__security_check_cookie@4
  000b6 8b e5        mov         esp, ebp
  000b8 5d                 pop     ebp
  000b9 c3                 ret     0
?_Getcat@?$collate@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::collate<char>::_Getcat
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\locale
;       COMDAT ??0?$collate@D@std@@QAE@ABV_Locinfo@1@I@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Lobj$ = 8                                   ; size = 4
__Refs$ = 12                                            ; size = 4
??0?$collate@D@std@@QAE@ABV_Locinfo@1@I@Z PROC      ; std::collate<char>::collate<char>, COMDAT
; _this$ = ecx

; 59   :              {   // construct from specified locale

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 58   :              : locale::facet(_Refs)

  00007 8b 45 0c   mov         eax, DWORD PTR __Refs$[ebp]
  0000a 50                 push    eax
  0000b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000e e8 00 00 00 00     call    ??0facet@locale@std@@IAE@I@Z ; std::locale::facet::facet

; 59   :              {   // construct from specified locale

  00013 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00016 c7 01 00 00 00
        00           mov     DWORD PTR [ecx], OFFSET ??_7?$collate@D@std@@6B@

; 60   :              _Init(_Lobj);

  0001c 8b 55 08   mov         edx, DWORD PTR __Lobj$[ebp]
  0001f 52                 push    edx
  00020 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00023 e8 00 00 00 00     call    ?_Init@?$collate@D@std@@IAEXABV_Locinfo@2@@Z ; std::collate<char>::_Init

; 61   :              }

  00028 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0002b 8b e5        mov         esp, ebp
  0002d 5d                 pop     ebp
  0002e c2 08 00   ret         8
??0?$collate@D@std@@QAE@ABV_Locinfo@1@I@Z ENDP      ; std::collate<char>::collate<char>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\locale
;       COMDAT ?transform@?$collate@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PBD0@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
___$ReturnUdt$ = 8                                  ; size = 4
__First$ = 12                                     ; size = 4
__Last$ = 16                                            ; size = 4
?transform@?$collate@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PBD0@Z PROC ; std::collate<char>::transform, COMDAT
; _this$ = ecx

; 38   :              {   // transform [_First, _Last) to key string

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 39   :              return (do_transform(_First, _Last));

  00007 8b 45 10   mov         eax, DWORD PTR __Last$[ebp]
  0000a 50                 push    eax
  0000b 8b 4d 0c   mov         ecx, DWORD PTR __First$[ebp]
  0000e 51                 push    ecx
  0000f 8b 55 08   mov         edx, DWORD PTR ___$ReturnUdt$[ebp]
  00012 52                 push    edx
  00013 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00016 8b 10        mov         edx, DWORD PTR [eax]
  00018 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001b 8b 42 10   mov         eax, DWORD PTR [edx+16]
  0001e ff d0        call        eax
  00020 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]

; 40   :              }

  00023 8b e5        mov         esp, ebp
  00025 5d                 pop     ebp
  00026 c2 0c 00   ret         12           ; 0000000cH
?transform@?$collate@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PBD0@Z ENDP ; std::collate<char>::transform
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;       COMDAT ??$use_facet@V?$collate@D@std@@@std@@YAABV?$collate@D@0@ABVlocale@0@@Z
_TEXT   SEGMENT
$T1 = -36                                         ; size = 12
$T2 = -24                                         ; size = 4
__Lock$3 = -20                                      ; size = 4
__Id$4 = -16                                            ; size = 4
__Pfmod$5 = -12                               ; size = 4
__Pf$6 = -8                                   ; size = 4
__Psave$7 = -4                                      ; size = 4
__Loc$ = 8                                          ; size = 4
??$use_facet@V?$collate@D@std@@@std@@YAABV?$collate@D@0@ABVlocale@0@@Z PROC ; std::use_facet<std::collate<char> >, COMDAT

; 553  :        {     // get facet reference from locale

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 24   sub         esp, 36                        ; 00000024H

; 554  :  #if _NO_LOCALES
; 555  :        static _Wrap_facet<_Facet> _Wfac;
; 556  :        return (*(_Facet *)&_Wfac);
; 557  :
; 558  :  #else /* _NO_LOCALES */
; 559  :        _BEGIN_LOCK(_LOCK_LOCALE)     // the thread lock, make get atomic

  00006 6a 00        push        0
  00008 8d 4d ec   lea         ecx, DWORD PTR __Lock$3[ebp]
  0000b e8 00 00 00 00     call    ??0_Lockit@std@@QAE@H@Z      ; std::_Lockit::_Lockit

; 560  :              const locale::facet *_Psave =
; 561  :                  _Facetptr<_Facet>::_Psave;      // static pointer to lazy facet

  00010 a1 00 00 00 00     mov     eax, DWORD PTR ?_Psave@?$_Facetptr@V?$collate@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::collate<char> >::_Psave
  00015 89 45 fc   mov         DWORD PTR __Psave$7[ebp], eax

; 562  :
; 563  :              size_t _Id = _Facet::id;

  00018 b9 00 00 00 00     mov     ecx, OFFSET ?id@?$collate@D@std@@2V0locale@2@A ; std::collate<char>::id
  0001d e8 00 00 00 00     call    ??Bid@locale@std@@QAEIXZ ; std::locale::id::operator unsigned int
  00022 89 45 f0   mov         DWORD PTR __Id$4[ebp], eax

; 564  :              const locale::facet *_Pf = _Loc._Getfacet(_Id);

  00025 8b 4d f0   mov         ecx, DWORD PTR __Id$4[ebp]
  00028 51                 push    ecx
  00029 8b 4d 08   mov         ecx, DWORD PTR __Loc$[ebp]
  0002c e8 00 00 00 00     call    ?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ; std::locale::_Getfacet
  00031 89 45 f8   mov         DWORD PTR __Pf$6[ebp], eax

; 565  :
; 566  :              if (_Pf != 0)

  00034 83 7d f8 00        cmp   DWORD PTR __Pf$6[ebp], 0
  00038 74 02        je  SHORT $LN2@use_facet
  0003a eb 69        jmp         SHORT $LN3@use_facet
$LN2@use_facet:

; 567  :                  ;       // got facet from locale
; 568  :              else if (_Psave != 0)

  0003c 83 7d fc 00        cmp   DWORD PTR __Psave$7[ebp], 0
  00040 74 08        je  SHORT $LN4@use_facet

; 569  :                  _Pf = _Psave;   // lazy facet already allocated

  00042 8b 55 fc   mov         edx, DWORD PTR __Psave$7[ebp]
  00045 89 55 f8   mov         DWORD PTR __Pf$6[ebp], edx
  00048 eb 5b        jmp         SHORT $LN3@use_facet
$LN4@use_facet:

; 570  :              else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

  0004a 8b 45 08   mov         eax, DWORD PTR __Loc$[ebp]
  0004d 50                 push    eax
  0004e 8d 4d fc   lea         ecx, DWORD PTR __Psave$7[ebp]
  00051 51                 push    ecx
  00052 e8 00 00 00 00     call    ?_Getcat@?$collate@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::collate<char>::_Getcat
  00057 83 c4 08   add         esp, 8
  0005a 83 f8 ff   cmp         eax, -1
  0005d 75 18        jne         SHORT $LN6@use_facet

; 571  :
; 572  :  #if _HAS_EXCEPTIONS
; 573  :
; 574  :                  _THROW_NCEE(_XSTD bad_cast, _EMPTY_ARGUMENT);   // lazy disallowed

  0005f 8d 4d dc   lea         ecx, DWORD PTR $T1[ebp]
  00062 e8 00 00 00 00     call    ??0bad_cast@std@@QAE@XZ      ; std::bad_cast::bad_cast
  00067 68 00 00 00 00     push    OFFSET __TI2?AVbad_cast@std@@
  0006c 8d 55 dc   lea         edx, DWORD PTR $T1[ebp]
  0006f 52                 push    edx
  00070 e8 00 00 00 00     call    __CxxThrowException@8

; 575  :
; 576  :  #else /* _HAS_EXCEPTIONS */
; 577  :                  abort();        // lazy disallowed
; 578  :  #endif /* _HAS_EXCEPTIONS */
; 579  :
; 580  :              else

  00075 eb 2e        jmp         SHORT $LN3@use_facet
$LN6@use_facet:

; 581  :                  {       // queue up lazy facet for destruction
; 582  :                  _Pf = _Psave;

  00077 8b 45 fc   mov         eax, DWORD PTR __Psave$7[ebp]
  0007a 89 45 f8   mov         DWORD PTR __Pf$6[ebp], eax

; 583  :                  _Facetptr<_Facet>::_Psave = _Psave;

  0007d 8b 4d fc   mov         ecx, DWORD PTR __Psave$7[ebp]
  00080 89 0d 00 00 00
        00           mov     DWORD PTR ?_Psave@?$_Facetptr@V?$collate@D@std@@@std@@2PBVfacet@locale@2@B, ecx ; std::_Facetptr<std::collate<char> >::_Psave

; 584  :
; 585  :                  locale::facet *_Pfmod = (_Facet *)_Psave;

  00086 8b 55 fc   mov         edx, DWORD PTR __Psave$7[ebp]
  00089 89 55 f4   mov         DWORD PTR __Pfmod$5[ebp], edx

; 586  :                  _Pfmod->_Incref();

  0008c 8b 45 f4   mov         eax, DWORD PTR __Pfmod$5[ebp]
  0008f 8b 10        mov         edx, DWORD PTR [eax]
  00091 8b 4d f4   mov         ecx, DWORD PTR __Pfmod$5[ebp]
  00094 8b 42 04   mov         eax, DWORD PTR [edx+4]
  00097 ff d0        call        eax

; 587  :
; 588  :  #if defined(_M_CEE)
; 589  :                  _Facet_Register_m(_Pfmod);
; 590  :
; 591  :  #else /* defined(_M_CEE) */
; 592  :                  _Facet_Register(_Pfmod);

  00099 8b 4d f4   mov         ecx, DWORD PTR __Pfmod$5[ebp]
  0009c 51                 push    ecx
  0009d e8 00 00 00 00     call    ?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register
  000a2 83 c4 04   add         esp, 4
$LN3@use_facet:

; 593  :  #endif /* defined(_M_CEE) */
; 594  :                  }
; 595  :
; 596  :              return ((const _Facet&)(*_Pf));     // should be dynamic_cast

  000a5 8b 55 f8   mov         edx, DWORD PTR __Pf$6[ebp]
  000a8 89 55 e8   mov         DWORD PTR $T2[ebp], edx
  000ab 8d 4d ec   lea         ecx, DWORD PTR __Lock$3[ebp]
  000ae e8 00 00 00 00     call    ??1_Lockit@std@@QAE@XZ       ; std::_Lockit::~_Lockit
  000b3 8b 45 e8   mov         eax, DWORD PTR $T2[ebp]
$LN8@use_facet:

; 597  :        _END_LOCK()
; 598  :  #endif /* _NO_LOCALES */
; 599  :        }     // end of use_facet body

  000b6 8b e5        mov         esp, ebp
  000b8 5d                 pop     ebp
  000b9 c3                 ret     0
??$use_facet@V?$collate@D@std@@@std@@YAABV?$collate@D@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::collate<char> >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;       COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Ptr$ = 8                                          ; size = 4
_<_Args_0>$ = 12                                        ; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 892  :              {   // construct _Ty(_Types...) at _Ptr

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 893  :              _Mytraits::construct(*this, _Ptr,

  00007 8b 45 0c   mov         eax, DWORD PTR _<_Args_0>$[ebp]
  0000a 50                 push    eax
  0000b e8 00 00 00 00     call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>
  00010 83 c4 04   add         esp, 4
  00013 50                 push    eax
  00014 8b 4d 08   mov         ecx, DWORD PTR __Ptr$[ebp]
  00017 51                 push    ecx
  00018 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  0001b 52                 push    edx
  0001c e8 00 00 00 00     call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
  00021 83 c4 0c   add         esp, 12                        ; 0000000cH

; 894  :                  _STD forward<_Types>(_Args)...);
; 895  :              }

  00024 8b e5        mov         esp, ebp
  00026 5d                 pop     ebp
  00027 c2 08 00   ret         8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;       COMDAT ??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z
_TEXT   SEGMENT
___formal$ = 8                                      ; size = 4
___formal$ = 12                               ; size = 4
??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z PROC            ; std::operator==<char,char>, COMDAT

; 693  :        {     // test for allocator equality

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 694  :        return (true);

  00003 b0 01        mov         al, 1

; 695  :        }

  00005 5d                 pop     ebp
  00006 c3                 ret     0
??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z ENDP            ; std::operator==<char,char>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;       COMDAT ??$?8V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z
_TEXT   SEGMENT
__Left$ = 8                                   ; size = 4
__Right$ = 12                                     ; size = 4
??$?8V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z PROC ; std::operator==<std::allocator<char>,std::allocator<char> >, COMDAT

; 914  :        {     // test for allocator equality

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 915  :        return (static_cast<const _Ty&>(_Left)

  00003 8b 45 0c   mov         eax, DWORD PTR __Right$[ebp]
  00006 50                 push    eax
  00007 8b 4d 08   mov         ecx, DWORD PTR __Left$[ebp]
  0000a 51                 push    ecx
  0000b e8 00 00 00 00     call    ??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z ; std::operator==<char,char>
  00010 83 c4 08   add         esp, 8

; 916  :              == static_cast<const _Other&>(_Right));
; 917  :        }

  00013 5d                 pop     ebp
  00014 c3                 ret     0
??$?8V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ENDP ; std::operator==<std::allocator<char>,std::allocator<char> >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;       COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT   SEGMENT
$T1 = -1                                                ; size = 1
__Val$ = 8                                          ; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC           ; std::addressof<char>, COMDAT

; 715  :        {     // return address of _Val

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx

; 716  :        return (_Addressof(_Val, is_function<_Ty>()));

  00004 0f b6 45 ff        movzx         eax, BYTE PTR $T1[ebp]
  00008 50                 push    eax
  00009 8b 4d 08   mov         ecx, DWORD PTR __Val$[ebp]
  0000c 51                 push    ecx
  0000d e8 00 00 00 00     call    ??$_Addressof@D@std@@YAPADAADU?$integral_constant@_N$0A@@0@@Z ; std::_Addressof<char>
  00012 83 c4 08   add         esp, 8

; 717  :        }

  00015 8b e5        mov         esp, ebp
  00017 5d                 pop     ebp
  00018 c3                 ret     0
??$addressof@D@std@@YAPADAAD@Z ENDP           ; std::addressof<char>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;       COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Ptr$ = 8                                          ; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 900  :              {   // destroy object at _Ptr

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 901  :              _Mytraits::destroy(*this, _Ptr);

  00007 8b 45 08   mov         eax, DWORD PTR __Ptr$[ebp]
  0000a 50                 push    eax
  0000b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000e 51                 push    ecx
  0000f e8 00 00 00 00     call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
  00014 83 c4 08   add         esp, 8

; 902  :              }

  00017 8b e5        mov         esp, ebp
  00019 5d                 pop     ebp
  0001a c2 04 00   ret         4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
___formal$ = 8                                      ; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; _this$ = ecx

; 279  :              {   // construct from forwarded values

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 278  :              : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
  0000f 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00012 e8 00 00 00 00     call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >

; 280  :              }

  00017 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0001a 8b e5        mov         esp, ebp
  0001c 5d                 pop     ebp
  0001d c2 04 00   ret         4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;       COMDAT ??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT   SEGMENT
__Arg$ = 8                                          ; size = 4
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 1298 :        {     // forward an lvalue as either an lvalue or an rvalue

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 1299 :        return (static_cast<_Ty&&>(_Arg));

  00003 8b 45 08   mov         eax, DWORD PTR __Arg$[ebp]

; 1300 :        }

  00006 5d                 pop     ebp
  00007 c3                 ret     0
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z
_TEXT   SEGMENT
_this$ = -8                                   ; size = 4
$T1 = -1                                                ; size = 1
__Al$ = 8                                         ; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::_Wrap_alloc<std::allocator<char> >,void>, COMDAT
; _this$ = ecx

; 580  :              {   // construct allocator from _Al

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d f8   mov         DWORD PTR _this$[ebp], ecx

; 578  :              : _Mypair(_One_then_variadic_args_t(),

  00009 8b 45 08   mov         eax, DWORD PTR __Al$[ebp]
  0000c 50                 push    eax
  0000d e8 00 00 00 00     call    ??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ; std::forward<std::_Wrap_alloc<std::allocator<char> > >
  00012 83 c4 04   add         esp, 4
  00015 50                 push    eax
  00016 0f b6 4d ff        movzx         ecx, BYTE PTR $T1[ebp]
  0001a 51                 push    ecx
  0001b 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  0001e e8 00 00 00 00     call    ??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::_Wrap_alloc<std::allocator<char> > >

; 581  :              }

  00023 8b 45 f8   mov         eax, DWORD PTR _this$[ebp]
  00026 8b e5        mov         esp, ebp
  00028 5d                 pop     ebp
  00029 c2 04 00   ret         4
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::_Wrap_alloc<std::allocator<char> >,void>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;       COMDAT ??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z
_TEXT   SEGMENT
__Arg$ = 8                                          ; size = 4
??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z PROC ; std::move<std::_Wrap_alloc<std::allocator<char> > &>, COMDAT

; 1314 :        {     // forward _Arg as movable

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 1315 :        return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003 8b 45 08   mov         eax, DWORD PTR __Arg$[ebp]

; 1316 :        }

  00006 5d                 pop     ebp
  00007 c3                 ret     0
??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ENDP ; std::move<std::_Wrap_alloc<std::allocator<char> > &>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ??$_Reset@PBD@?$basic_regex@DV?$regex_traits@D@std@@@std@@AAEXPBD0W4syntax_option_type@regex_constants@1@Uforward_iterator_tag@1@@Z
_TEXT   SEGMENT
__Prs$ = -92                                            ; size = 84
__Rx$ = -8                                          ; size = 4
_this$ = -4                                   ; size = 4
__First$ = 8                                            ; size = 4
__Last$ = 12                                            ; size = 4
__Flags$ = 16                                     ; size = 4
___formal$ = 20                               ; size = 1
??$_Reset@PBD@?$basic_regex@DV?$regex_traits@D@std@@@std@@AAEXPBD0W4syntax_option_type@regex_constants@1@Uforward_iterator_tag@1@@Z PROC ; std::basic_regex<char,std::regex_traits<char> >::_Reset<char const *>, COMDAT
; _this$ = ecx

; 2634 :              {   // build regular expression from forward iterators

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 5c   sub         esp, 92                        ; 0000005cH
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2635 :  #if _ENHANCED_REGEX_VISUALIZER
; 2636 :              _Visualization.assign(_First, _Last);
; 2637 :  #endif /* _ENHANCED_REGEX_VISUALIZER */
; 2638 :
; 2639 :              _Parser<_FwdIt, _Elem, _RxTraits>
; 2640 :                  _Prs(_Traits, _First, _Last, _Flags);

  00009 8b 45 10   mov         eax, DWORD PTR __Flags$[ebp]
  0000c 50                 push    eax
  0000d 8b 4d 0c   mov         ecx, DWORD PTR __Last$[ebp]
  00010 51                 push    ecx
  00011 8b 55 08   mov         edx, DWORD PTR __First$[ebp]
  00014 52                 push    edx
  00015 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00018 83 c0 04   add         eax, 4
  0001b 50                 push    eax
  0001c 8d 4d a4   lea         ecx, DWORD PTR __Prs$[ebp]
  0001f e8 00 00 00 00     call    ??0?$_Parser@PBDDV?$regex_traits@D@std@@@std@@QAE@ABV?$regex_traits@D@1@PBD1W4syntax_option_type@regex_constants@1@@Z ; std::_Parser<char const *,char,std::regex_traits<char> >::_Parser<char const *,char,std::regex_traits<char> >

; 2641 :              _Root_node *_Rx = _Prs._Compile();

  00024 8d 4d a4   lea         ecx, DWORD PTR __Prs$[ebp]
  00027 e8 00 00 00 00     call    ?_Compile@?$_Parser@PBDDV?$regex_traits@D@std@@@std@@QAEPAV_Root_node@2@XZ ; std::_Parser<char const *,char,std::regex_traits<char> >::_Compile
  0002c 89 45 f8   mov         DWORD PTR __Rx$[ebp], eax

; 2642 :              _Reset(_Rx);

  0002f 8b 4d f8   mov         ecx, DWORD PTR __Rx$[ebp]
  00032 51                 push    ecx
  00033 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00036 e8 00 00 00 00     call    ?_Reset@?$basic_regex@DV?$regex_traits@D@std@@@std@@AAEXPAV_Root_node@2@@Z ; std::basic_regex<char,std::regex_traits<char> >::_Reset

; 2643 :              }

  0003b 8d 4d a4   lea         ecx, DWORD PTR __Prs$[ebp]
  0003e e8 00 00 00 00     call    ??1?$_Parser@PBDDV?$regex_traits@D@std@@@std@@QAE@XZ
  00043 8b e5        mov         esp, ebp
  00045 5d                 pop     ebp
  00046 c2 10 00   ret         16           ; 00000010H
??$_Reset@PBD@?$basic_regex@DV?$regex_traits@D@std@@@std@@AAEXPBD0W4syntax_option_type@regex_constants@1@Uforward_iterator_tag@1@@Z ENDP ; std::basic_regex<char,std::regex_traits<char> >::_Reset<char const *>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Reset@?$basic_regex@DV?$regex_traits@D@std@@@std@@AAEXPAV_Root_node@2@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Rx$ = 8                                         ; size = 4
?_Reset@?$basic_regex@DV?$regex_traits@D@std@@@std@@AAEXPAV_Root_node@2@@Z PROC ; std::basic_regex<char,std::regex_traits<char> >::_Reset, COMDAT
; _this$ = ecx

; 2646 :              {   // build regular expression holding root node _Rx

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2647 :              if (_Rx != 0)

  00007 83 7d 08 00        cmp   DWORD PTR __Rx$[ebp], 0
  0000b 74 09        je  SHORT $LN2@Reset

; 2648 :                  _MT_INCR(reinterpret_cast<_Atomic_counter_t&>(_Rx->_Refs));

  0000d 8b 45 08   mov         eax, DWORD PTR __Rx$[ebp]
  00010 83 c0 20   add         eax, 32                        ; 00000020H
  00013 f0 ff 00   lock         inc  DWORD PTR [eax]
$LN2@Reset:

; 2649 :              _Tidy();

  00016 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00019 e8 00 00 00 00     call    ?_Tidy@?$basic_regex@DV?$regex_traits@D@std@@@std@@AAEXXZ ; std::basic_regex<char,std::regex_traits<char> >::_Tidy

; 2650 :              _Rep = _Rx;

  0001e 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00021 8b 55 08   mov         edx, DWORD PTR __Rx$[ebp]
  00024 89 11        mov         DWORD PTR [ecx], edx

; 2651 :              }

  00026 8b e5        mov         esp, ebp
  00028 5d                 pop     ebp
  00029 c2 04 00   ret         4
?_Reset@?$basic_regex@DV?$regex_traits@D@std@@@std@@AAEXPAV_Root_node@2@@Z ENDP ; std::basic_regex<char,std::regex_traits<char> >::_Reset
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Tidy@?$basic_regex@DV?$regex_traits@D@std@@@std@@AAEXXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Tidy@?$basic_regex@DV?$regex_traits@D@std@@@std@@AAEXXZ PROC ; std::basic_regex<char,std::regex_traits<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2614 :              {   // free all storage

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2615 :              if (_Rep != 0 && _MT_DECR(

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a 83 38 00   cmp         DWORD PTR [eax], 0
  0000d 74 22        je  SHORT $LN2@Tidy
  0000f 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00012 8b 11        mov         edx, DWORD PTR [ecx]
  00014 83 c2 20   add         edx, 32                        ; 00000020H
  00017 83 c8 ff   or  eax, -1
  0001a f0 0f c1 02        lock   xadd     DWORD PTR [edx], eax
  0001e 48                 dec     eax
  0001f 75 10        jne         SHORT $LN2@Tidy

; 2616 :                  reinterpret_cast<_Atomic_counter_t&>(_Rep->_Refs)) == 0)
; 2617 :                  _Destroy_node(_Rep);

  00021 6a 00        push        0
  00023 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00026 8b 11        mov         edx, DWORD PTR [ecx]
  00028 52                 push    edx
  00029 e8 00 00 00 00     call    ?_Destroy_node@std@@YAXPAV_Node_base@1@0@Z ; std::_Destroy_node
  0002e 83 c4 08   add         esp, 8
$LN2@Tidy:

; 2618 :              _Rep = 0;

  00031 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00034 c7 00 00 00 00
        00           mov     DWORD PTR [eax], 0

; 2619 :              }

  0003a 8b e5        mov         esp, ebp
  0003c 5d                 pop     ebp
  0003d c3                 ret     0
?_Tidy@?$basic_regex@DV?$regex_traits@D@std@@@std@@AAEXXZ ENDP ; std::basic_regex<char,std::regex_traits<char> >::_Tidy
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ??1?$basic_regex@DV?$regex_traits@D@std@@@std@@QAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??1?$basic_regex@DV?$regex_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_regex<char,std::regex_traits<char> >::~basic_regex<char,std::regex_traits<char> >, COMDAT
; _this$ = ecx

; 2485 :              {   // destroy the object

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2486 :              _Tidy();

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Tidy@?$basic_regex@DV?$regex_traits@D@std@@@std@@AAEXXZ ; std::basic_regex<char,std::regex_traits<char> >::_Tidy

; 2487 :              }

  0000f 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00012 83 c1 04   add         ecx, 4
  00015 e8 00 00 00 00     call    ??1?$regex_traits@D@std@@QAE@XZ
  0001a 8b e5        mov         esp, ebp
  0001c 5d                 pop     ebp
  0001d c3                 ret     0
??1?$basic_regex@DV?$regex_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_regex<char,std::regex_traits<char> >::~basic_regex<char,std::regex_traits<char> >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ??0?$basic_regex@DV?$regex_traits@D@std@@@std@@QAE@PBDW4syntax_option_type@regex_constants@1@@Z
_TEXT   SEGMENT
_this$ = -8                                   ; size = 4
$T1 = -2                                                ; size = 1
$T2 = -1                                                ; size = 1
__Ptr$ = 8                                          ; size = 4
__Flags$ = 12                                     ; size = 4
??0?$basic_regex@DV?$regex_traits@D@std@@@std@@QAE@PBDW4syntax_option_type@regex_constants@1@@Z PROC ; std::basic_regex<char,std::regex_traits<char> >::basic_regex<char,std::regex_traits<char> >, COMDAT
; _this$ = ecx

; 2374 :              {   // construct from null terminated character sequence

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d f8   mov         DWORD PTR _this$[ebp], ecx

; 2373 :              : _Rep(0)

  00009 8b 45 f8   mov         eax, DWORD PTR _this$[ebp]
  0000c c7 00 00 00 00
        00           mov     DWORD PTR [eax], 0

; 2374 :              {   // construct from null terminated character sequence

  00012 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00015 83 c1 04   add         ecx, 4
  00018 e8 00 00 00 00     call    ??0?$regex_traits@D@std@@QAE@XZ

; 2375 :              _Reset(_Ptr, _Ptr + _RxTraits::length(_Ptr),

  0001d 33 c9        xor         ecx, ecx
  0001f 88 4d ff   mov         BYTE PTR $T2[ebp], cl
  00022 8a 55 ff   mov         dl, BYTE PTR $T2[ebp]
  00025 88 55 fe   mov         BYTE PTR $T1[ebp], dl
  00028 0f b6 45 fe        movzx         eax, BYTE PTR $T1[ebp]
  0002c 50                 push    eax
  0002d 8b 4d 0c   mov         ecx, DWORD PTR __Flags$[ebp]
  00030 51                 push    ecx
  00031 8b 55 08   mov         edx, DWORD PTR __Ptr$[ebp]
  00034 52                 push    edx
  00035 e8 00 00 00 00     call    ?length@?$_Regex_traits@D@std@@SAIPBD@Z ; std::_Regex_traits<char>::length
  0003a 83 c4 04   add         esp, 4
  0003d 03 45 08   add         eax, DWORD PTR __Ptr$[ebp]
  00040 50                 push    eax
  00041 8b 45 08   mov         eax, DWORD PTR __Ptr$[ebp]
  00044 50                 push    eax
  00045 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00048 e8 00 00 00 00     call    ??$_Reset@PBD@?$basic_regex@DV?$regex_traits@D@std@@@std@@AAEXPBD0W4syntax_option_type@regex_constants@1@Uforward_iterator_tag@1@@Z ; std::basic_regex<char,std::regex_traits<char> >::_Reset<char const *>

; 2376 :                  _Flags, random_access_iterator_tag());
; 2377 :              }

  0004d 8b 45 f8   mov         eax, DWORD PTR _this$[ebp]
  00050 8b e5        mov         esp, ebp
  00052 5d                 pop     ebp
  00053 c2 08 00   ret         8
??0?$basic_regex@DV?$regex_traits@D@std@@@std@@QAE@PBDW4syntax_option_type@regex_constants@1@@Z ENDP ; std::basic_regex<char,std::regex_traits<char> >::basic_regex<char,std::regex_traits<char> >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\users\administrator\appdata\local\temp\2\gcc-explorer-compiler11653-3488-1xp4orl.hsemi\example.cpp
_TEXT   SEGMENT
_self_regex$ = -48                                  ; size = 20
_s$ = -28                                         ; size = 24
__$ArrayPad$ = -4                                 ; size = 4
?regexTest@@YAXXZ PROC                              ; regexTest

; 5    : {

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 30   sub         esp, 48                        ; 00000030H
  00006 a1 00 00 00 00     mov     eax, DWORD PTR ___security_cookie
  0000b 33 c5        xor         eax, ebp
  0000d 89 45 fc   mov         DWORD PTR __$ArrayPad$[ebp], eax

; 6    :     std::string s = "Some people, when confronted with a problem, think "

  00010 68 00 00 00 00     push    OFFSET $SG45541
  00015 8d 4d e4   lea         ecx, DWORD PTR _s$[ebp]
  00018 e8 00 00 00 00     call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 7    :           "\"I know, I'll use regular expressions.\" "
; 8    :           "Now they have two problems.";
; 9    :     std::regex self_regex("REGULAR EXPRESSIONS",

  0001d 68 00 01 00 00     push    256              ; 00000100H
  00022 6a 01        push        1
  00024 e8 00 00 00 00     call    ??Uregex_constants@std@@YA?AW4syntax_option_type@01@W4201@0@Z ; std::regex_constants::operator|
  00029 83 c4 08   add         esp, 8
  0002c 50                 push    eax
  0002d 68 00 00 00 00     push    OFFSET $SG45542
  00032 8d 4d d0   lea         ecx, DWORD PTR _self_regex$[ebp]
  00035 e8 00 00 00 00     call    ??0?$basic_regex@DV?$regex_traits@D@std@@@std@@QAE@PBDW4syntax_option_type@regex_constants@1@@Z ; std::basic_regex<char,std::regex_traits<char> >::basic_regex<char,std::regex_traits<char> >

; 10   :             std::regex_constants::ECMAScript | std::regex_constants::icase);
; 11   : }

  0003a 8d 4d d0   lea         ecx, DWORD PTR _self_regex$[ebp]
  0003d e8 00 00 00 00     call    ??1?$basic_regex@DV?$regex_traits@D@std@@@std@@QAE@XZ ; std::basic_regex<char,std::regex_traits<char> >::~basic_regex<char,std::regex_traits<char> >
  00042 8d 4d e4   lea         ecx, DWORD PTR _s$[ebp]
  00045 e8 00 00 00 00     call    ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0004a 8b 4d fc   mov         ecx, DWORD PTR __$ArrayPad$[ebp]
  0004d 33 cd        xor         ecx, ebp
  0004f e8 00 00 00 00     call    @__security_check_cookie@4
  00054 8b e5        mov         esp, ebp
  00056 5d                 pop     ebp
  00057 c3                 ret     0
?regexTest@@YAXXZ ENDP                              ; regexTest
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Calculate_loop_simplicity@std@@YAXPAV_Node_base@1@0PAV_Node_rep@1@@Z
_TEXT   SEGMENT
tv68 = -8                                         ; size = 4
__Branch$1 = -4                               ; size = 4
__Nx$ = 8                                         ; size = 4
__Ne$ = 12                                          ; size = 4
__Outer_rep$ = 16                                 ; size = 4
?_Calculate_loop_simplicity@std@@YAXPAV_Node_base@1@0PAV_Node_rep@1@@Z PROC ; std::_Calculate_loop_simplicity, COMDAT

; 5745 :        {     // walks regex NFA, calculates values of _Node_rep::_Simple_loop

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8

; 5746 :        for (; _Nx != _Ne && _Nx != 0; _Nx = _Nx->_Next)

  00006 eb 09        jmp         SHORT $LN4@Calculate_
$LN2@Calculate_:
  00008 8b 45 08   mov         eax, DWORD PTR __Nx$[ebp]
  0000b 8b 48 0c   mov         ecx, DWORD PTR [eax+12]
  0000e 89 4d 08   mov         DWORD PTR __Nx$[ebp], ecx
$LN4@Calculate_:
  00011 8b 55 08   mov         edx, DWORD PTR __Nx$[ebp]
  00014 3b 55 0c   cmp         edx, DWORD PTR __Ne$[ebp]
  00017 0f 84 e2 00 00
        00           je      $LN1@Calculate_
  0001d 83 7d 08 00        cmp   DWORD PTR __Nx$[ebp], 0
  00021 0f 84 d8 00 00
        00           je      $LN1@Calculate_

; 5747 :              {
; 5748 :              switch (_Nx->_Kind)

  00027 8b 45 08   mov         eax, DWORD PTR __Nx$[ebp]
  0002a 8b 48 04   mov         ecx, DWORD PTR [eax+4]
  0002d 89 4d f8   mov         DWORD PTR tv68[ebp], ecx
  00030 8b 55 f8   mov         edx, DWORD PTR tv68[ebp]
  00033 83 ea 0a   sub         edx, 10                        ; 0000000aH
  00036 89 55 f8   mov         DWORD PTR tv68[ebp], edx
  00039 83 7d f8 09        cmp   DWORD PTR tv68[ebp], 9
  0003d 0f 87 b7 00 00
        00           ja      $LN5@Calculate_
  00043 8b 45 f8   mov         eax, DWORD PTR tv68[ebp]
  00046 0f b6 88 00 00
        00 00          movzx       ecx, BYTE PTR $LN21@Calculate_[eax]
  0004d ff 24 8d 00 00
        00 00          jmp         DWORD PTR $LN22@Calculate_[ecx*4]
$LN10@Calculate_:

; 5749 :                  {
; 5750 :                  case _N_if:
; 5751 :                          // _Node_if inside a _Node_rep makes the rep not simple
; 5752 :                          if (_Outer_rep != 0)

  00054 83 7d 10 00        cmp   DWORD PTR __Outer_rep$[ebp], 0
  00058 74 0a        je  SHORT $LN11@Calculate_

; 5753 :                                  _Outer_rep->_Simple_loop = 0;

  0005a 8b 55 10   mov         edx, DWORD PTR __Outer_rep$[ebp]
  0005d c7 42 24 00 00
        00 00          mov         DWORD PTR [edx+36], 0
$LN11@Calculate_:

; 5754 :                          // visit each branch of the if
; 5755 :                          for (_Node_if *_Branch = static_cast<_Node_if *>(_Nx)->_Child;

  00064 8b 45 08   mov         eax, DWORD PTR __Nx$[ebp]
  00067 8b 48 18   mov         ecx, DWORD PTR [eax+24]
  0006a 89 4d fc   mov         DWORD PTR __Branch$1[ebp], ecx
  0006d eb 09        jmp         SHORT $LN9@Calculate_
$LN7@Calculate_:

; 5757 :                                  _Branch = _Branch->_Child)

  0006f 8b 55 fc   mov         edx, DWORD PTR __Branch$1[ebp]
  00072 8b 42 18   mov         eax, DWORD PTR [edx+24]
  00075 89 45 fc   mov         DWORD PTR __Branch$1[ebp], eax
$LN9@Calculate_:

; 5756 :                                  _Branch != 0;

  00078 83 7d fc 00        cmp   DWORD PTR __Branch$1[ebp], 0
  0007c 74 1c        je  SHORT $LN8@Calculate_

; 5758 :                                  _Calculate_loop_simplicity(_Branch->_Next, _Branch->_Endif, _Outer_rep);

  0007e 8b 4d 10   mov         ecx, DWORD PTR __Outer_rep$[ebp]
  00081 51                 push    ecx
  00082 8b 55 fc   mov         edx, DWORD PTR __Branch$1[ebp]
  00085 8b 42 14   mov         eax, DWORD PTR [edx+20]
  00088 50                 push    eax
  00089 8b 4d fc   mov         ecx, DWORD PTR __Branch$1[ebp]
  0008c 8b 51 0c   mov         edx, DWORD PTR [ecx+12]
  0008f 52                 push    edx
  00090 e8 00 00 00 00     call    ?_Calculate_loop_simplicity@std@@YAXPAV_Node_base@1@0PAV_Node_rep@1@@Z ; std::_Calculate_loop_simplicity
  00095 83 c4 0c   add         esp, 12                        ; 0000000cH
  00098 eb d5        jmp         SHORT $LN7@Calculate_
$LN8@Calculate_:

; 5759 :                          break;

  0009a eb 5e        jmp         SHORT $LN5@Calculate_
$LN12@Calculate_:

; 5760 :                  case _N_assert:
; 5761 :                  case _N_neg_assert:
; 5762 :                          // visit the assertion body
; 5763 :                          // note _Outer_rep being reset: the assertion regex is completely independent
; 5764 :                          _Calculate_loop_simplicity(static_cast<_Node_assert *>(_Nx)->_Child, 0, 0);

  0009c 6a 00        push        0
  0009e 6a 00        push        0
  000a0 8b 45 08   mov         eax, DWORD PTR __Nx$[ebp]
  000a3 8b 48 14   mov         ecx, DWORD PTR [eax+20]
  000a6 51                 push    ecx
  000a7 e8 00 00 00 00     call    ?_Calculate_loop_simplicity@std@@YAXPAV_Node_base@1@0PAV_Node_rep@1@@Z ; std::_Calculate_loop_simplicity
  000ac 83 c4 0c   add         esp, 12                        ; 0000000cH

; 5765 :                          break;

  000af eb 49        jmp         SHORT $LN5@Calculate_
$LN13@Calculate_:

; 5766 :                  case _N_rep:
; 5767 :                          // _Node_rep inside another _Node_rep makes both not simple
; 5768 :                          if (_Outer_rep == 0)

  000b1 83 7d 10 00        cmp   DWORD PTR __Outer_rep$[ebp], 0
  000b5 75 08        jne         SHORT $LN14@Calculate_

; 5769 :                                  _Outer_rep = static_cast<_Node_rep *>(_Nx);

  000b7 8b 55 08   mov         edx, DWORD PTR __Nx$[ebp]
  000ba 89 55 10   mov         DWORD PTR __Outer_rep$[ebp], edx

; 5770 :                          else

  000bd eb 14        jmp         SHORT $LN15@Calculate_
$LN14@Calculate_:

; 5771 :                                  {
; 5772 :                                  _Outer_rep->_Simple_loop = 0;

  000bf 8b 45 10   mov         eax, DWORD PTR __Outer_rep$[ebp]
  000c2 c7 40 24 00 00
        00 00          mov         DWORD PTR [eax+36], 0

; 5773 :                                  static_cast<_Node_rep *>(_Nx)->_Simple_loop = 0;

  000c9 8b 4d 08   mov         ecx, DWORD PTR __Nx$[ebp]
  000cc c7 41 24 00 00
        00 00          mov         DWORD PTR [ecx+36], 0
$LN15@Calculate_:

; 5774 :                                  }
; 5775 :                          break;

  000d3 eb 25        jmp         SHORT $LN5@Calculate_
$LN16@Calculate_:

; 5776 :                  case _N_end_rep:
; 5777 :                          if (_Outer_rep == static_cast<_Node_end_rep *>(_Nx)->_Begin_rep)

  000d5 8b 55 08   mov         edx, DWORD PTR __Nx$[ebp]
  000d8 8b 45 10   mov         eax, DWORD PTR __Outer_rep$[ebp]
  000db 3b 42 14   cmp         eax, DWORD PTR [edx+20]
  000de 75 1a        jne         SHORT $LN5@Calculate_

; 5778 :                                  {
; 5779 :                                  // if the _Node_rep is still undetermined when we reach its end, it is simple
; 5780 :                                  if (_Outer_rep->_Simple_loop == -1)

  000e0 8b 4d 10   mov         ecx, DWORD PTR __Outer_rep$[ebp]
  000e3 83 79 24 ff        cmp   DWORD PTR [ecx+36], -1
  000e7 75 0a        jne         SHORT $LN18@Calculate_

; 5781 :                                          _Outer_rep->_Simple_loop = 1;

  000e9 8b 55 10   mov         edx, DWORD PTR __Outer_rep$[ebp]
  000ec c7 42 24 01 00
        00 00          mov         DWORD PTR [edx+36], 1
$LN18@Calculate_:

; 5782 :                                  _Outer_rep = 0;

  000f3 c7 45 10 00 00
        00 00          mov         DWORD PTR __Outer_rep$[ebp], 0
$LN5@Calculate_:

; 5783 :                                  }
; 5784 :                          break;
; 5785 :                  default:
; 5786 :                          break;
; 5787 :                  }
; 5788 :              }

  000fa e9 09 ff ff ff     jmp     $LN2@Calculate_
$LN1@Calculate_:

; 5789 :        }

  000ff 8b e5        mov         esp, ebp
  00101 5d                 pop     ebp
  00102 c3                 ret     0
  00103 90                 npad    1
$LN22@Calculate_:
  00104 00 00 00 00        DD    $LN12@Calculate_
  00108 00 00 00 00        DD    $LN10@Calculate_
  0010c 00 00 00 00        DD    $LN13@Calculate_
  00110 00 00 00 00        DD    $LN16@Calculate_
  00114 00 00 00 00        DD    $LN5@Calculate_
$LN21@Calculate_:
  00118 00                 DB      0
  00119 00                 DB      0
  0011a 04                 DB      4
  0011b 04                 DB      4
  0011c 04                 DB      4
  0011d 04                 DB      4
  0011e 01                 DB      1
  0011f 04                 DB      4
  00120 02                 DB      2
  00121 03                 DB      3
?_Calculate_loop_simplicity@std@@YAXPAV_Node_base@1@0PAV_Node_rep@1@@Z ENDP ; std::_Calculate_loop_simplicity
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEXABV12@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
___formal$ = 8                                      ; size = 4
?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Compat, COMDAT
; _this$ = ecx

; 261  :              {   // test for compatible iterator pair

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 262  :              }

  00007 8b e5        mov         esp, ebp
  00009 5d                 pop     ebp
  0000a c2 04 00   ret         4
?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Compat
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT   SEGMENT
tv69 = -8                                         ; size = 4
_this$ = -4                                   ; size = 4
__Right$ = 8                                            ; size = 4
??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator==, COMDAT
; _this$ = ecx

; 212  :              {   // test for iterator equality

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 213  :              _Compat(_Right);

  00009 8b 45 08   mov         eax, DWORD PTR __Right$[ebp]
  0000c 50                 push    eax
  0000d 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00010 e8 00 00 00 00     call    ?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEXABV12@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Compat

; 214  :              return (_Ptr == _Right._Ptr);

  00015 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00018 8b 55 08   mov         edx, DWORD PTR __Right$[ebp]
  0001b 8b 01        mov         eax, DWORD PTR [ecx]
  0001d 3b 02        cmp         eax, DWORD PTR [edx]
  0001f 75 09        jne         SHORT $LN3@operator
  00021 c7 45 f8 01 00
        00 00          mov         DWORD PTR tv69[ebp], 1
  00028 eb 07        jmp         SHORT $LN4@operator
$LN3@operator:
  0002a c7 45 f8 00 00
        00 00          mov         DWORD PTR tv69[ebp], 0
$LN4@operator:
  00031 8a 45 f8   mov         al, BYTE PTR tv69[ebp]

; 215  :              }

  00034 8b e5        mov         esp, ebp
  00036 5d                 pop     ebp
  00037 c2 04 00   ret         4
??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator==
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV01@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Right$ = 8                                            ; size = 4
??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV01@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator-, COMDAT
; _this$ = ecx

; 201  :              {   // return difference of iterators

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 202  :              _Compat(_Right);

  00007 8b 45 08   mov         eax, DWORD PTR __Right$[ebp]
  0000a 50                 push    eax
  0000b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000e e8 00 00 00 00     call    ?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEXABV12@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Compat

; 203  :              return (_Ptr - _Right._Ptr);

  00013 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00016 8b 55 08   mov         edx, DWORD PTR __Right$[ebp]
  00019 8b 01        mov         eax, DWORD PTR [ecx]
  0001b 2b 02        sub         eax, DWORD PTR [edx]

; 204  :              }

  0001d 8b e5        mov         esp, ebp
  0001f 5d                 pop     ebp
  00020 c2 04 00   ret         4
??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator-
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*, COMDAT
; _this$ = ecx

; 67   :              {   // return designated object

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 68   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 69   :              if (this->_Getcont() == 0
; 70   :                  || _Ptr == 0
; 71   :                  || _Ptr < ((_Mystr *)this->_Getcont())->_Myptr()
; 72   :                  || ((_Mystr *)this->_Getcont())->_Myptr()
; 73   :                          + ((_Mystr *)this->_Getcont())->_Mysize <= _Ptr)
; 74   :                  {       // report error
; 75   :                  _DEBUG_ERROR("string iterator not dereferencable");
; 76   :                  _SCL_SECURE_OUT_OF_RANGE;
; 77   :                  }
; 78   :
; 79   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 80   :              _SCL_SECURE_VALIDATE(this->_Getcont() != 0 && _Ptr != 0);
; 81   :              _SCL_SECURE_VALIDATE_RANGE(
; 82   :                  ((_Mystr *)this->_Getcont())->_Myptr() <= _Ptr
; 83   :                  && _Ptr < ((_Mystr *)this->_Getcont())->_Myptr()
; 84   :                          + ((_Mystr *)this->_Getcont())->_Mysize);
; 85   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 86   :
; 87   :              _Analysis_assume_(_Ptr != 0);
; 88   :
; 89   :              return (*_Ptr);

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a 8b 00        mov         eax, DWORD PTR [eax]

; 90   :              }

  0000c 8b e5        mov         esp, ebp
  0000e 5d                 pop     ebp
  0000f c3                 ret     0
??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Parg$ = 8                                   ; size = 4
__Pstring$ = 12                               ; size = 4
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT
; _this$ = ecx

; 47   :        _String_const_iterator(pointer _Parg, const _Container_base *_Pstring)

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 48   :              {   // construct with pointer _Parg
; 49   :              this->_Adopt(_Pstring);

  00007 8b 45 0c   mov         eax, DWORD PTR __Pstring$[ebp]
  0000a 50                 push    eax
  0000b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000e e8 00 00 00 00     call    ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 50   :              _Ptr = _Parg;

  00013 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00016 8b 55 08   mov         edx, DWORD PTR __Parg$[ebp]
  00019 89 11        mov         DWORD PTR [ecx], edx

; 51   :              }

  0001b 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0001e 8b e5        mov         esp, ebp
  00020 5d                 pop     ebp
  00021 c2 08 00   ret         8
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@QBEXXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@QBEXXZ PROC ; std::vector<bool,std::allocator<bool> >::_Xlen, COMDAT
; _this$ = ecx

; 3042 :              {   // report a length_error

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 3043 :              _Xlength_error("vector<bool> too long");

  00007 68 00 00 00 00     push    OFFSET ??_C@_0BG@EOMJEIFA@vector?$DMbool?$DO?5too?5long?$AA@
  0000c e8 00 00 00 00     call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen:

; 3044 :              }

  00011 8b e5        mov         esp, ebp
  00013 5d                 pop     ebp
  00014 c3                 ret     0
?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@QBEXXZ ENDP ; std::vector<bool,std::allocator<bool> >::_Xlen
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI@Z
_TEXT   SEGMENT
$T1 = -36                                         ; size = 4
$T2 = -32                                         ; size = 4
$T3 = -28                                         ; size = 4
$T4 = -24                                         ; size = 4
$T5 = -20                                         ; size = 4
$T6 = -16                                         ; size = 4
tv167 = -12                                   ; size = 4
__Words$ = -8                                     ; size = 4
_this$ = -4                                   ; size = 4
__Size$ = 8                                   ; size = 4
?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI@Z PROC ; std::vector<bool,std::allocator<bool> >::_Trim, COMDAT
; _this$ = ecx

; 3027 :              {   // trim base vector to exact length in bits

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 24   sub         esp, 36                        ; 00000024H
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 3028 :              if (max_size() < _Size)

  00009 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000c e8 00 00 00 00     call    ?max_size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<bool,std::allocator<bool> >::max_size
  00011 3b 45 08   cmp         eax, DWORD PTR __Size$[ebp]
  00014 73 08        jae         SHORT $LN2@Trim

; 3029 :                  _Xlen();        // result too long

  00016 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00019 e8 00 00 00 00     call    ?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@QBEXXZ ; std::vector<bool,std::allocator<bool> >::_Xlen
$LN2@Trim:

; 3030 :              size_type _Words = this->_Nw(_Size);

  0001e 8b 45 08   mov         eax, DWORD PTR __Size$[ebp]
  00021 50                 push    eax
  00022 e8 00 00 00 00     call    ?_Nw@?$_Vb_val@V?$allocator@_N@std@@@std@@SAII@Z ; std::_Vb_val<std::allocator<bool> >::_Nw
  00027 83 c4 04   add         esp, 4
  0002a 89 45 f8   mov         DWORD PTR __Words$[ebp], eax

; 3031 :
; 3032 :              if (_Words < this->_Myvec.size())

  0002d 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00030 e8 00 00 00 00     call    ?size@?$vector@IV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<bool> >::size
  00035 39 45 f8   cmp         DWORD PTR __Words$[ebp], eax
  00038 73 45        jae         SHORT $LN3@Trim

; 3033 :                  this->_Myvec.erase(this->_Myvec.begin() + _Words,

  0003a 8d 4d e8   lea         ecx, DWORD PTR $T4[ebp]
  0003d 51                 push    ecx
  0003e 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00041 e8 00 00 00 00     call    ?end@?$vector@IV?$allocator@_N@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ ; std::vector<unsigned int,std::allocator<bool> >::end
  00046 8b 10        mov         edx, DWORD PTR [eax]
  00048 89 55 f0   mov         DWORD PTR $T6[ebp], edx
  0004b 8b 45 f8   mov         eax, DWORD PTR __Words$[ebp]
  0004e 50                 push    eax
  0004f 8d 4d e4   lea         ecx, DWORD PTR $T3[ebp]
  00052 51                 push    ecx
  00053 8d 55 e0   lea         edx, DWORD PTR $T2[ebp]
  00056 52                 push    edx
  00057 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0005a e8 00 00 00 00     call    ?begin@?$vector@IV?$allocator@_N@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ ; std::vector<unsigned int,std::allocator<bool> >::begin
  0005f 8b c8        mov         ecx, eax
  00061 e8 00 00 00 00     call    ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+
  00066 8b 00        mov         eax, DWORD PTR [eax]
  00068 89 45 ec   mov         DWORD PTR $T5[ebp], eax
  0006b 8b 4d f0   mov         ecx, DWORD PTR $T6[ebp]
  0006e 51                 push    ecx
  0006f 8b 55 ec   mov         edx, DWORD PTR $T5[ebp]
  00072 52                 push    edx
  00073 8d 45 dc   lea         eax, DWORD PTR $T1[ebp]
  00076 50                 push    eax
  00077 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0007a e8 00 00 00 00     call    ?erase@?$vector@IV?$allocator@_N@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@0@Z ; std::vector<unsigned int,std::allocator<bool> >::erase
$LN3@Trim:

; 3034 :                          this->_Myvec.end());
; 3035 :              this->_Mysize = _Size;

  0007f 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00082 8b 55 08   mov         edx, DWORD PTR __Size$[ebp]
  00085 89 51 0c   mov         DWORD PTR [ecx+12], edx

; 3036 :              _Size %= _VBITS;

  00088 8b 45 08   mov         eax, DWORD PTR __Size$[ebp]
  0008b 33 d2        xor         edx, edx
  0008d b9 20 00 00 00     mov     ecx, 32                        ; 00000020H
  00092 f7 f1        div         ecx
  00094 89 55 08   mov         DWORD PTR __Size$[ebp], edx

; 3037 :              if (0 < _Size)

  00097 83 7d 08 00        cmp   DWORD PTR __Size$[ebp], 0
  0009b 76 29        jbe         SHORT $LN5@Trim

; 3038 :                  this->_Myvec[_Words - 1] &= ((_Vbase)(1) << _Size) - 1;

  0009d 8b 55 f8   mov         edx, DWORD PTR __Words$[ebp]
  000a0 83 ea 01   sub         edx, 1
  000a3 52                 push    edx
  000a4 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000a7 e8 00 00 00 00     call    ??A?$vector@IV?$allocator@_N@std@@@std@@QAEAAII@Z ; std::vector<unsigned int,std::allocator<bool> >::operator[]
  000ac 89 45 f4   mov         DWORD PTR tv167[ebp], eax
  000af b8 01 00 00 00     mov     eax, 1
  000b4 8b 4d 08   mov         ecx, DWORD PTR __Size$[ebp]
  000b7 d3 e0        shl         eax, cl
  000b9 83 e8 01   sub         eax, 1
  000bc 8b 4d f4   mov         ecx, DWORD PTR tv167[ebp]
  000bf 23 01        and         eax, DWORD PTR [ecx]
  000c1 8b 55 f4   mov         edx, DWORD PTR tv167[ebp]
  000c4 89 02        mov         DWORD PTR [edx], eax
$LN5@Trim:

; 3039 :              }

  000c6 8b e5        mov         esp, ebp
  000c8 5d                 pop     ebp
  000c9 c2 04 00   ret         4
?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI@Z ENDP ; std::vector<bool,std::allocator<bool> >::_Trim
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Insert_x@?$vector@_NV?$allocator@_N@std@@@std@@QAEIV?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@I@Z
_TEXT   SEGMENT
$T1 = -60                                         ; size = 8
$T2 = -52                                         ; size = 8
$T3 = -44                                         ; size = 8
$T4 = -36                                         ; size = 8
$T5 = -28                                         ; size = 8
__Oldend$6 = -20                                        ; size = 8
$T7 = -12                                         ; size = 4
__Off$ = -8                                   ; size = 4
_this$ = -4                                   ; size = 4
__Where$ = 8                                            ; size = 8
__Count$ = 16                                     ; size = 4
?_Insert_x@?$vector@_NV?$allocator@_N@std@@@std@@QAEIV?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@I@Z PROC ; std::vector<bool,std::allocator<bool> >::_Insert_x, COMDAT
; _this$ = ecx

; 2964 :              {   // make room to insert _Count elements at _Where

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 3c   sub         esp, 60                        ; 0000003cH
  00006 56                 push    esi
  00007 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2965 :              size_type _Off = _Where - begin();

  0000a 8d 45 e4   lea         eax, DWORD PTR $T5[ebp]
  0000d 50                 push    eax
  0000e 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00011 e8 00 00 00 00     call    ?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::begin
  00016 50                 push    eax
  00017 8d 4d 08   lea         ecx, DWORD PTR __Where$[ebp]
  0001a e8 00 00 00 00     call    ??G?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEHABV01@@Z ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator-
  0001f 89 45 f8   mov         DWORD PTR __Off$[ebp], eax

; 2966 :
; 2967 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2968 :              if (end() < _Where)
; 2969 :                  _DEBUG_ERROR("vector<bool> insert iterator outside range");
; 2970 :              bool _Realloc = capacity() - size() < _Count;
; 2971 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2972 :
; 2973 :              if (_Count == 0)

  00022 83 7d 10 00        cmp   DWORD PTR __Count$[ebp], 0
  00026 75 05        jne         SHORT $LN2@Insert_x
  00028 e9 d2 00 00 00     jmp     $LN3@Insert_x
$LN2@Insert_x:

; 2974 :                  ;
; 2975 :              else if (max_size() - size() < _Count)

  0002d 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00030 e8 00 00 00 00     call    ?max_size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<bool,std::allocator<bool> >::max_size
  00035 8b f0        mov         esi, eax
  00037 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0003a e8 00 00 00 00     call    ?size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<bool,std::allocator<bool> >::size
  0003f 2b f0        sub         esi, eax
  00041 3b 75 10   cmp         esi, DWORD PTR __Count$[ebp]
  00044 73 0d        jae         SHORT $LN4@Insert_x

; 2976 :                  _Xlen();        // result too long

  00046 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00049 e8 00 00 00 00     call    ?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@QBEXXZ ; std::vector<bool,std::allocator<bool> >::_Xlen

; 2977 :              else

  0004e e9 ac 00 00 00     jmp     $LN3@Insert_x
$LN4@Insert_x:

; 2978 :                  {       // worth doing
; 2979 :                  this->_Myvec.resize(this->_Nw(size() + _Count), 0);

  00053 c7 45 f4 00 00
        00 00          mov         DWORD PTR $T7[ebp], 0
  0005a 8d 4d f4   lea         ecx, DWORD PTR $T7[ebp]
  0005d 51                 push    ecx
  0005e 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00061 e8 00 00 00 00     call    ?size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<bool,std::allocator<bool> >::size
  00066 03 45 10   add         eax, DWORD PTR __Count$[ebp]
  00069 50                 push    eax
  0006a e8 00 00 00 00     call    ?_Nw@?$_Vb_val@V?$allocator@_N@std@@@std@@SAII@Z ; std::_Vb_val<std::allocator<bool> >::_Nw
  0006f 83 c4 04   add         esp, 4
  00072 50                 push    eax
  00073 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00076 e8 00 00 00 00     call    ?resize@?$vector@IV?$allocator@_N@std@@@std@@QAEXIABI@Z ; std::vector<unsigned int,std::allocator<bool> >::resize

; 2980 :                  if (empty())

  0007b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0007e e8 00 00 00 00     call    ?empty@?$vector@_NV?$allocator@_N@std@@@std@@QBE_NXZ ; std::vector<bool,std::allocator<bool> >::empty
  00083 0f b6 d0   movzx       edx, al
  00086 85 d2        test        edx, edx
  00088 74 11        je  SHORT $LN6@Insert_x

; 2981 :                          this->_Mysize += _Count;

  0008a 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0008d 8b 48 0c   mov         ecx, DWORD PTR [eax+12]
  00090 03 4d 10   add         ecx, DWORD PTR __Count$[ebp]
  00093 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  00096 89 4a 0c   mov         DWORD PTR [edx+12], ecx

; 2982 :                  else

  00099 eb 64        jmp         SHORT $LN3@Insert_x
$LN6@Insert_x:

; 2983 :                          {       // make room and copy down suffix
; 2984 :                          iterator _Oldend = end();

  0009b 8d 45 ec   lea         eax, DWORD PTR __Oldend$6[ebp]
  0009e 50                 push    eax
  0009f 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000a2 e8 00 00 00 00     call    ?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::end

; 2985 :                          this->_Mysize += _Count;

  000a7 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000aa 8b 51 0c   mov         edx, DWORD PTR [ecx+12]
  000ad 03 55 10   add         edx, DWORD PTR __Count$[ebp]
  000b0 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  000b3 89 50 0c   mov         DWORD PTR [eax+12], edx

; 2986 :                          _STD copy_backward(begin() + _Off, _Oldend, end());

  000b6 8d 4d dc   lea         ecx, DWORD PTR $T4[ebp]
  000b9 51                 push    ecx
  000ba 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000bd e8 00 00 00 00     call    ?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::end
  000c2 8b 50 04   mov         edx, DWORD PTR [eax+4]
  000c5 52                 push    edx
  000c6 8b 00        mov         eax, DWORD PTR [eax]
  000c8 50                 push    eax
  000c9 8b 4d f0   mov         ecx, DWORD PTR __Oldend$6[ebp+4]
  000cc 51                 push    ecx
  000cd 8b 55 ec   mov         edx, DWORD PTR __Oldend$6[ebp]
  000d0 52                 push    edx
  000d1 8b 45 f8   mov         eax, DWORD PTR __Off$[ebp]
  000d4 50                 push    eax
  000d5 8d 4d d4   lea         ecx, DWORD PTR $T3[ebp]
  000d8 51                 push    ecx
  000d9 8d 55 cc   lea         edx, DWORD PTR $T2[ebp]
  000dc 52                 push    edx
  000dd 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000e0 e8 00 00 00 00     call    ?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::begin
  000e5 8b c8        mov         ecx, eax
  000e7 e8 00 00 00 00     call    ??H?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator+
  000ec 8b 48 04   mov         ecx, DWORD PTR [eax+4]
  000ef 51                 push    ecx
  000f0 8b 10        mov         edx, DWORD PTR [eax]
  000f2 52                 push    edx
  000f3 8d 45 c4   lea         eax, DWORD PTR $T1[ebp]
  000f6 50                 push    eax
  000f7 e8 00 00 00 00     call    ??$copy_backward@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00@Z ; std::copy_backward<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
  000fc 83 c4 1c   add         esp, 28                        ; 0000001cH
$LN3@Insert_x:

; 2987 :                          }
; 2988 :
; 2989 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2990 :                  _Orphan_range(_Realloc ? 0 : _Off, this->_Mysize);
; 2991 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2992 :                  }
; 2993 :              return (_Off);

  000ff 8b 45 f8   mov         eax, DWORD PTR __Off$[ebp]
$LN8@Insert_x:

; 2994 :              }

  00102 5e                 pop     esi
  00103 8b e5        mov         esp, ebp
  00105 5d                 pop     ebp
  00106 c2 0c 00   ret         12           ; 0000000cH
?_Insert_x@?$vector@_NV?$allocator@_N@std@@@std@@QAEIV?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@I@Z ENDP ; std::vector<bool,std::allocator<bool> >::_Insert_x
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Insert_n@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@V?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@IAB_N@Z
_TEXT   SEGMENT
$T1 = -48                                         ; size = 8
$T2 = -40                                         ; size = 8
$T3 = -32                                         ; size = 8
$T4 = -24                                         ; size = 8
$T5 = -16                                         ; size = 8
__Off$ = -8                                   ; size = 4
_this$ = -4                                   ; size = 4
___$ReturnUdt$ = 8                                  ; size = 4
__Where$ = 12                                     ; size = 8
__Count$ = 20                                     ; size = 4
__Val$ = 24                                   ; size = 4
?_Insert_n@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@V?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@IAB_N@Z PROC ; std::vector<bool,std::allocator<bool> >::_Insert_n, COMDAT
; _this$ = ecx

; 2957 :              {   // insert _Count * _Val at _Where

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 30   sub         esp, 48                        ; 00000030H
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2958 :              size_type _Off = _Insert_x(_Where, _Count);

  00009 8b 45 14   mov         eax, DWORD PTR __Count$[ebp]
  0000c 50                 push    eax
  0000d 8b 4d 10   mov         ecx, DWORD PTR __Where$[ebp+4]
  00010 51                 push    ecx
  00011 8b 55 0c   mov         edx, DWORD PTR __Where$[ebp]
  00014 52                 push    edx
  00015 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00018 e8 00 00 00 00     call    ?_Insert_x@?$vector@_NV?$allocator@_N@std@@@std@@QAEIV?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@I@Z ; std::vector<bool,std::allocator<bool> >::_Insert_x
  0001d 89 45 f8   mov         DWORD PTR __Off$[ebp], eax

; 2959 :              _STD fill(begin() + _Off, begin() + (_Off + _Count), _Val);

  00020 8b 45 18   mov         eax, DWORD PTR __Val$[ebp]
  00023 50                 push    eax
  00024 8b 4d f8   mov         ecx, DWORD PTR __Off$[ebp]
  00027 03 4d 14   add         ecx, DWORD PTR __Count$[ebp]
  0002a 51                 push    ecx
  0002b 8d 55 f0   lea         edx, DWORD PTR $T5[ebp]
  0002e 52                 push    edx
  0002f 8d 45 e8   lea         eax, DWORD PTR $T4[ebp]
  00032 50                 push    eax
  00033 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00036 e8 00 00 00 00     call    ?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::begin
  0003b 8b c8        mov         ecx, eax
  0003d e8 00 00 00 00     call    ??H?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator+
  00042 8b 48 04   mov         ecx, DWORD PTR [eax+4]
  00045 51                 push    ecx
  00046 8b 10        mov         edx, DWORD PTR [eax]
  00048 52                 push    edx
  00049 8b 45 f8   mov         eax, DWORD PTR __Off$[ebp]
  0004c 50                 push    eax
  0004d 8d 4d e0   lea         ecx, DWORD PTR $T3[ebp]
  00050 51                 push    ecx
  00051 8d 55 d8   lea         edx, DWORD PTR $T2[ebp]
  00054 52                 push    edx
  00055 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00058 e8 00 00 00 00     call    ?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::begin
  0005d 8b c8        mov         ecx, eax
  0005f e8 00 00 00 00     call    ??H?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator+
  00064 8b 48 04   mov         ecx, DWORD PTR [eax+4]
  00067 51                 push    ecx
  00068 8b 10        mov         edx, DWORD PTR [eax]
  0006a 52                 push    edx
  0006b e8 00 00 00 00     call    ??$fill@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@0AB_N@Z ; std::fill<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,bool>
  00070 83 c4 14   add         esp, 20                        ; 00000014H

; 2960 :              return (begin() + _Off);

  00073 8b 45 f8   mov         eax, DWORD PTR __Off$[ebp]
  00076 50                 push    eax
  00077 8b 4d 08   mov         ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0007a 51                 push    ecx
  0007b 8d 55 d0   lea         edx, DWORD PTR $T1[ebp]
  0007e 52                 push    edx
  0007f 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00082 e8 00 00 00 00     call    ?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::begin
  00087 8b c8        mov         ecx, eax
  00089 e8 00 00 00 00     call    ??H?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator+
  0008e 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2961 :              }

  00091 8b e5        mov         esp, ebp
  00093 5d                 pop     ebp
  00094 c2 14 00   ret         20           ; 00000014H
?_Insert_n@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@V?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@IAB_N@Z ENDP ; std::vector<bool,std::allocator<bool> >::_Insert_n
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@V?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@0@Z
_TEXT   SEGMENT
$T1 = -64                                         ; size = 8
$T2 = -56                                         ; size = 8
$T3 = -48                                         ; size = 8
$T4 = -40                                         ; size = 8
__Next$5 = -32                                      ; size = 8
__Last$ = -24                                     ; size = 8
__First$ = -16                                      ; size = 8
__Off$ = -8                                   ; size = 4
_this$ = -4                                   ; size = 4
___$ReturnUdt$ = 8                                  ; size = 4
__First_arg$ = 12                                 ; size = 8
__Last_arg$ = 20                                        ; size = 8
?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@V?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@0@Z PROC ; std::vector<bool,std::allocator<bool> >::erase, COMDAT
; _this$ = ecx

; 2876 :              {   // erase [_First, _Last)

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 40   sub         esp, 64                        ; 00000040H
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2877 :              iterator _First = _Make_iter(_First_arg);

  00009 8b 45 10   mov         eax, DWORD PTR __First_arg$[ebp+4]
  0000c 50                 push    eax
  0000d 8b 4d 0c   mov         ecx, DWORD PTR __First_arg$[ebp]
  00010 51                 push    ecx
  00011 8d 55 f0   lea         edx, DWORD PTR __First$[ebp]
  00014 52                 push    edx
  00015 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00018 e8 00 00 00 00     call    ?_Make_iter@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@V?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@@Z ; std::vector<bool,std::allocator<bool> >::_Make_iter

; 2878 :              iterator _Last = _Make_iter(_Last_arg);

  0001d 8b 45 18   mov         eax, DWORD PTR __Last_arg$[ebp+4]
  00020 50                 push    eax
  00021 8b 4d 14   mov         ecx, DWORD PTR __Last_arg$[ebp]
  00024 51                 push    ecx
  00025 8d 55 e8   lea         edx, DWORD PTR __Last$[ebp]
  00028 52                 push    edx
  00029 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0002c e8 00 00 00 00     call    ?_Make_iter@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@V?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@@Z ; std::vector<bool,std::allocator<bool> >::_Make_iter

; 2879 :              size_type _Off = _First - begin();

  00031 8d 45 d8   lea         eax, DWORD PTR $T4[ebp]
  00034 50                 push    eax
  00035 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00038 e8 00 00 00 00     call    ?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::begin
  0003d 50                 push    eax
  0003e 8d 4d f0   lea         ecx, DWORD PTR __First$[ebp]
  00041 e8 00 00 00 00     call    ??G?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEHABV?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@@Z ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator-
  00046 89 45 f8   mov         DWORD PTR __Off$[ebp], eax

; 2880 :
; 2881 :              if (_First != _Last)

  00049 8d 4d e8   lea         ecx, DWORD PTR __Last$[ebp]
  0004c 51                 push    ecx
  0004d 8d 4d f0   lea         ecx, DWORD PTR __First$[ebp]
  00050 e8 00 00 00 00     call    ??9?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator!=
  00055 0f b6 d0   movzx       edx, al
  00058 85 d2        test        edx, edx
  0005a 74 4d        je  SHORT $LN2@erase

; 2882 :                  {       // worth doing, copy down over hole
; 2883 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2884 :                  if (_Last < _First || end() < _Last)
; 2885 :                          _DEBUG_ERROR("vector<bool> erase iterator outside range");
; 2886 :                  iterator _Next = _STD copy(_Last, end(), _First);
; 2887 :                  size_type _Newsize = _Next - begin();
; 2888 :                  _Orphan_range(_Newsize, this->_Mysize);
; 2889 :                  _Trim(_Newsize);
; 2890 :
; 2891 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2892 :                  iterator _Next = _STD copy(_Last, end(), _First);

  0005c 8b 45 f4   mov         eax, DWORD PTR __First$[ebp+4]
  0005f 50                 push    eax
  00060 8b 4d f0   mov         ecx, DWORD PTR __First$[ebp]
  00063 51                 push    ecx
  00064 8d 55 d0   lea         edx, DWORD PTR $T3[ebp]
  00067 52                 push    edx
  00068 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0006b e8 00 00 00 00     call    ?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::end
  00070 8b 48 04   mov         ecx, DWORD PTR [eax+4]
  00073 51                 push    ecx
  00074 8b 10        mov         edx, DWORD PTR [eax]
  00076 52                 push    edx
  00077 8b 45 ec   mov         eax, DWORD PTR __Last$[ebp+4]
  0007a 50                 push    eax
  0007b 8b 4d e8   mov         ecx, DWORD PTR __Last$[ebp]
  0007e 51                 push    ecx
  0007f 8d 55 e0   lea         edx, DWORD PTR __Next$5[ebp]
  00082 52                 push    edx
  00083 e8 00 00 00 00     call    ??$copy@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00@Z ; std::copy<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
  00088 83 c4 1c   add         esp, 28                        ; 0000001cH

; 2893 :                  _Trim(_Next - begin());

  0008b 8d 45 c8   lea         eax, DWORD PTR $T2[ebp]
  0008e 50                 push    eax
  0008f 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00092 e8 00 00 00 00     call    ?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::begin
  00097 50                 push    eax
  00098 8d 4d e0   lea         ecx, DWORD PTR __Next$5[ebp]
  0009b e8 00 00 00 00     call    ??G?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEHABV?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@@Z ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator-
  000a0 50                 push    eax
  000a1 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000a4 e8 00 00 00 00     call    ?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI@Z ; std::vector<bool,std::allocator<bool> >::_Trim
$LN2@erase:

; 2894 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2895 :                  }
; 2896 :              return (begin() + _Off);

  000a9 8b 4d f8   mov         ecx, DWORD PTR __Off$[ebp]
  000ac 51                 push    ecx
  000ad 8b 55 08   mov         edx, DWORD PTR ___$ReturnUdt$[ebp]
  000b0 52                 push    edx
  000b1 8d 45 c0   lea         eax, DWORD PTR $T1[ebp]
  000b4 50                 push    eax
  000b5 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000b8 e8 00 00 00 00     call    ?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::begin
  000bd 8b c8        mov         ecx, eax
  000bf e8 00 00 00 00     call    ??H?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator+
  000c4 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2897 :              }

  000c7 8b e5        mov         esp, ebp
  000c9 5d                 pop     ebp
  000ca c2 14 00   ret         20           ; 00000014H
?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@V?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@0@Z ENDP ; std::vector<bool,std::allocator<bool> >::erase
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@I@Z
_TEXT   SEGMENT
__It$ = -12                                   ; size = 8
_this$ = -4                                   ; size = 4
___$ReturnUdt$ = 8                                  ; size = 4
__Off$ = 12                                   ; size = 4
??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@I@Z PROC ; std::vector<bool,std::allocator<bool> >::operator[], COMDAT
; _this$ = ecx

; 2759 :              {   // subscript mutable sequence

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 0c   sub         esp, 12                        ; 0000000cH
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2760 :              iterator _It = begin();

  00009 8d 45 f4   lea         eax, DWORD PTR __It$[ebp]
  0000c 50                 push    eax
  0000d 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00010 e8 00 00 00 00     call    ?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::begin

; 2761 :              _It._Advance(_Off);

  00015 8b 4d 0c   mov         ecx, DWORD PTR __Off$[ebp]
  00018 51                 push    ecx
  00019 8d 4d f4   lea         ecx, DWORD PTR __It$[ebp]
  0001c e8 00 00 00 00     call    ?_Advance@?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXI@Z ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Advance

; 2762 :              return (*_It);

  00021 8b 55 08   mov         edx, DWORD PTR ___$ReturnUdt$[ebp]
  00024 52                 push    edx
  00025 8d 4d f4   lea         ecx, DWORD PTR __It$[ebp]
  00028 e8 00 00 00 00     call    ??D?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@XZ ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator*
  0002d 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2763 :              }

  00030 8b e5        mov         esp, ebp
  00032 5d                 pop     ebp
  00033 c2 08 00   ret         8
??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@I@Z ENDP ; std::vector<bool,std::allocator<bool> >::operator[]
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?empty@?$vector@_NV?$allocator@_N@std@@@std@@QBE_NXZ
_TEXT   SEGMENT
_this$ = -8                                   ; size = 4
tv67 = -4                                         ; size = 4
?empty@?$vector@_NV?$allocator@_N@std@@@std@@QBE_NXZ PROC ; std::vector<bool,std::allocator<bool> >::empty, COMDAT
; _this$ = ecx

; 2728 :              {   // test if sequence is empty

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d f8   mov         DWORD PTR _this$[ebp], ecx

; 2729 :              return (size() == 0);

  00009 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  0000c e8 00 00 00 00     call    ?size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<bool,std::allocator<bool> >::size
  00011 85 c0        test        eax, eax
  00013 75 09        jne         SHORT $LN3@empty
  00015 c7 45 fc 01 00
        00 00          mov         DWORD PTR tv67[ebp], 1
  0001c eb 07        jmp         SHORT $LN4@empty
$LN3@empty:
  0001e c7 45 fc 00 00
        00 00          mov         DWORD PTR tv67[ebp], 0
$LN4@empty:
  00025 8a 45 fc   mov         al, BYTE PTR tv67[ebp]

; 2730 :              }

  00028 8b e5        mov         esp, ebp
  0002a 5d                 pop     ebp
  0002b c3                 ret     0
?empty@?$vector@_NV?$allocator@_N@std@@@std@@QBE_NXZ ENDP ; std::vector<bool,std::allocator<bool> >::empty
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?max_size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ
_TEXT   SEGMENT
_this$ = -12                                            ; size = 4
tv73 = -8                                         ; size = 4
__Maxsize$ = -4                               ; size = 4
?max_size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ PROC ; std::vector<bool,std::allocator<bool> >::max_size, COMDAT
; _this$ = ecx

; 2721 :              {   // return maximum possible length of sequence

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 0c   sub         esp, 12                        ; 0000000cH
  00006 89 4d f4   mov         DWORD PTR _this$[ebp], ecx

; 2722 :              const size_type _Maxsize = this->_Myvec.max_size();

  00009 8b 4d f4   mov         ecx, DWORD PTR _this$[ebp]
  0000c e8 00 00 00 00     call    ?max_size@?$vector@IV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<bool> >::max_size
  00011 89 45 fc   mov         DWORD PTR __Maxsize$[ebp], eax

; 2723 :              return (_Maxsize < (size_type)(-1) / _VBITS

  00014 81 7d fc ff ff
        ff 07          cmp         DWORD PTR __Maxsize$[ebp], 134217727 ; 07ffffffH
  0001b 73 0b        jae         SHORT $LN3@max_size
  0001d 8b 45 fc   mov         eax, DWORD PTR __Maxsize$[ebp]
  00020 c1 e0 05   shl         eax, 5
  00023 89 45 f8   mov         DWORD PTR tv73[ebp], eax
  00026 eb 07        jmp         SHORT $LN4@max_size
$LN3@max_size:
  00028 c7 45 f8 ff ff
        ff ff          mov         DWORD PTR tv73[ebp], -1
$LN4@max_size:
  0002f 8b 45 f8   mov         eax, DWORD PTR tv73[ebp]

; 2724 :                  ? _Maxsize * _VBITS : (size_type)(-1));
; 2725 :              }

  00032 8b e5        mov         esp, ebp
  00034 5d                 pop     ebp
  00035 c3                 ret     0
?max_size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ENDP ; std::vector<bool,std::allocator<bool> >::max_size
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ PROC ; std::vector<bool,std::allocator<bool> >::size, COMDAT
; _this$ = ecx

; 2716 :              {   // return length of sequence

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2717 :              return (this->_Mysize);

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a 8b 40 0c   mov         eax, DWORD PTR [eax+12]

; 2718 :              }

  0000d 8b e5        mov         esp, ebp
  0000f 5d                 pop     ebp
  00010 c3                 ret     0
?size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ENDP ; std::vector<bool,std::allocator<bool> >::size
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?resize@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI_N@Z
_TEXT   SEGMENT
$T1 = -76                                         ; size = 8
$T2 = -68                                         ; size = 8
$T3 = -60                                         ; size = 8
$T4 = -52                                         ; size = 8
$T5 = -44                                         ; size = 8
$T6 = -36                                         ; size = 8
$T7 = -28                                         ; size = 8
$T8 = -20                                         ; size = 8
$T9 = -12                                         ; size = 8
_this$ = -4                                   ; size = 4
__Newsize$ = 8                                      ; size = 4
__Val$ = 12                                   ; size = 1
?resize@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI_N@Z PROC ; std::vector<bool,std::allocator<bool> >::resize, COMDAT
; _this$ = ecx

; 2708 :              {   // determine new length, padding with _Val elements as needed

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 4c   sub         esp, 76                        ; 0000004cH
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2709 :              if (size() < _Newsize)

  00009 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000c e8 00 00 00 00     call    ?size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<bool,std::allocator<bool> >::size
  00011 3b 45 08   cmp         eax, DWORD PTR __Newsize$[ebp]
  00014 73 3f        jae         SHORT $LN2@resize

; 2710 :                  _Insert_n(end(), _Newsize - size(), _Val);

  00016 8d 45 dc   lea         eax, DWORD PTR $T6[ebp]
  00019 50                 push    eax
  0001a 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001d e8 00 00 00 00     call    ?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::end
  00022 8b 08        mov         ecx, DWORD PTR [eax]
  00024 8b 50 04   mov         edx, DWORD PTR [eax+4]
  00027 89 4d f4   mov         DWORD PTR $T9[ebp], ecx
  0002a 89 55 f8   mov         DWORD PTR $T9[ebp+4], edx
  0002d 8d 45 0c   lea         eax, DWORD PTR __Val$[ebp]
  00030 50                 push    eax
  00031 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00034 e8 00 00 00 00     call    ?size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<bool,std::allocator<bool> >::size
  00039 8b 4d 08   mov         ecx, DWORD PTR __Newsize$[ebp]
  0003c 2b c8        sub         ecx, eax
  0003e 51                 push    ecx
  0003f 8b 55 f8   mov         edx, DWORD PTR $T9[ebp+4]
  00042 52                 push    edx
  00043 8b 45 f4   mov         eax, DWORD PTR $T9[ebp]
  00046 50                 push    eax
  00047 8d 4d d4   lea         ecx, DWORD PTR $T5[ebp]
  0004a 51                 push    ecx
  0004b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0004e e8 00 00 00 00     call    ?_Insert_n@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@V?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@IAB_N@Z ; std::vector<bool,std::allocator<bool> >::_Insert_n
  00053 eb 66        jmp         SHORT $LN1@resize
$LN2@resize:

; 2711 :              else if (_Newsize < size())

  00055 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00058 e8 00 00 00 00     call    ?size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<bool,std::allocator<bool> >::size
  0005d 39 45 08   cmp         DWORD PTR __Newsize$[ebp], eax
  00060 73 59        jae         SHORT $LN1@resize

; 2712 :                  erase(begin() + _Newsize, end());

  00062 8d 55 cc   lea         edx, DWORD PTR $T4[ebp]
  00065 52                 push    edx
  00066 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00069 e8 00 00 00 00     call    ?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::end
  0006e 8b 08        mov         ecx, DWORD PTR [eax]
  00070 8b 50 04   mov         edx, DWORD PTR [eax+4]
  00073 89 4d ec   mov         DWORD PTR $T8[ebp], ecx
  00076 89 55 f0   mov         DWORD PTR $T8[ebp+4], edx
  00079 8b 45 08   mov         eax, DWORD PTR __Newsize$[ebp]
  0007c 50                 push    eax
  0007d 8d 4d c4   lea         ecx, DWORD PTR $T3[ebp]
  00080 51                 push    ecx
  00081 8d 55 bc   lea         edx, DWORD PTR $T2[ebp]
  00084 52                 push    edx
  00085 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00088 e8 00 00 00 00     call    ?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::begin
  0008d 8b c8        mov         ecx, eax
  0008f e8 00 00 00 00     call    ??H?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator+
  00094 8b 08        mov         ecx, DWORD PTR [eax]
  00096 8b 50 04   mov         edx, DWORD PTR [eax+4]
  00099 89 4d e4   mov         DWORD PTR $T7[ebp], ecx
  0009c 89 55 e8   mov         DWORD PTR $T7[ebp+4], edx
  0009f 8b 45 f0   mov         eax, DWORD PTR $T8[ebp+4]
  000a2 50                 push    eax
  000a3 8b 4d ec   mov         ecx, DWORD PTR $T8[ebp]
  000a6 51                 push    ecx
  000a7 8b 55 e8   mov         edx, DWORD PTR $T7[ebp+4]
  000aa 52                 push    edx
  000ab 8b 45 e4   mov         eax, DWORD PTR $T7[ebp]
  000ae 50                 push    eax
  000af 8d 4d b4   lea         ecx, DWORD PTR $T1[ebp]
  000b2 51                 push    ecx
  000b3 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000b6 e8 00 00 00 00     call    ?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@V?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@0@Z ; std::vector<bool,std::allocator<bool> >::erase
$LN1@resize:

; 2713 :              }

  000bb 8b e5        mov         esp, ebp
  000bd 5d                 pop     ebp
  000be c2 08 00   ret         8
?resize@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI_N@Z ENDP ; std::vector<bool,std::allocator<bool> >::resize
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Make_iter@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@V?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@@Z
_TEXT   SEGMENT
$T1 = -20                                         ; size = 8
__Tmp$ = -12                                            ; size = 8
_this$ = -4                                   ; size = 4
___$ReturnUdt$ = 8                                  ; size = 4
__Where$ = 12                                     ; size = 8
?_Make_iter@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@V?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@@Z PROC ; std::vector<bool,std::allocator<bool> >::_Make_iter, COMDAT
; _this$ = ecx

; 2680 :              {   // make iterator from const_iterator

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 14   sub         esp, 20                        ; 00000014H
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2681 :              iterator _Tmp = begin();

  00009 8d 45 f4   lea         eax, DWORD PTR __Tmp$[ebp]
  0000c 50                 push    eax
  0000d 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00010 e8 00 00 00 00     call    ?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::begin

; 2682 :              if (0 < this->_Mysize)

  00015 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00018 83 79 0c 00        cmp   DWORD PTR [ecx+12], 0
  0001c 76 1e        jbe         SHORT $LN2@Make_iter

; 2683 :                  _Tmp += _Where - begin();

  0001e 8d 55 ec   lea         edx, DWORD PTR $T1[ebp]
  00021 52                 push    edx
  00022 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00025 e8 00 00 00 00     call    ?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::begin
  0002a 50                 push    eax
  0002b 8d 4d 0c   lea         ecx, DWORD PTR __Where$[ebp]
  0002e e8 00 00 00 00     call    ??G?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEHABV01@@Z ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator-
  00033 50                 push    eax
  00034 8d 4d f4   lea         ecx, DWORD PTR __Tmp$[ebp]
  00037 e8 00 00 00 00     call    ??Y?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator+=
$LN2@Make_iter:

; 2684 :              return (_Tmp);

  0003c 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]
  0003f 8b 4d f4   mov         ecx, DWORD PTR __Tmp$[ebp]
  00042 89 08        mov         DWORD PTR [eax], ecx
  00044 8b 55 f8   mov         edx, DWORD PTR __Tmp$[ebp+4]
  00047 89 50 04   mov         DWORD PTR [eax+4], edx
  0004a 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2685 :              }

  0004d 8b e5        mov         esp, ebp
  0004f 5d                 pop     ebp
  00050 c2 0c 00   ret         12           ; 0000000cH
?_Make_iter@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@V?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@@Z ENDP ; std::vector<bool,std::allocator<bool> >::_Make_iter
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ
_TEXT   SEGMENT
__Tmp$ = -12                                            ; size = 8
_this$ = -4                                   ; size = 4
___$ReturnUdt$ = 8                                  ; size = 4
?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ PROC ; std::vector<bool,std::allocator<bool> >::end, COMDAT
; _this$ = ecx

; 2635 :              {   // return iterator for end of mutable sequence

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 0c   sub         esp, 12                        ; 0000000cH
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2636 :              iterator _Tmp = begin();

  00009 8d 45 f4   lea         eax, DWORD PTR __Tmp$[ebp]
  0000c 50                 push    eax
  0000d 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00010 e8 00 00 00 00     call    ?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::begin

; 2637 :              if (0 < this->_Mysize)

  00015 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00018 83 79 0c 00        cmp   DWORD PTR [ecx+12], 0
  0001c 76 0f        jbe         SHORT $LN2@end

; 2638 :                  _Tmp += this->_Mysize;

  0001e 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  00021 8b 42 0c   mov         eax, DWORD PTR [edx+12]
  00024 50                 push    eax
  00025 8d 4d f4   lea         ecx, DWORD PTR __Tmp$[ebp]
  00028 e8 00 00 00 00     call    ??Y?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator+=
$LN2@end:

; 2639 :              return (_Tmp);

  0002d 8b 4d 08   mov         ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00030 8b 55 f4   mov         edx, DWORD PTR __Tmp$[ebp]
  00033 89 11        mov         DWORD PTR [ecx], edx
  00035 8b 45 f8   mov         eax, DWORD PTR __Tmp$[ebp+4]
  00038 89 41 04   mov         DWORD PTR [ecx+4], eax
  0003b 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2640 :              }

  0003e 8b e5        mov         esp, ebp
  00040 5d                 pop     ebp
  00041 c2 04 00   ret         4
?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ ENDP ; std::vector<bool,std::allocator<bool> >::end
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
___$ReturnUdt$ = 8                                  ; size = 4
?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ PROC ; std::vector<bool,std::allocator<bool> >::begin, COMDAT
; _this$ = ecx

; 2625 :              {   // return iterator for beginning of mutable sequence

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2626 :              return (iterator((_Vbase *)this->_Myvec._Myfirst(), this));

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a 50                 push    eax
  0000b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000e e8 00 00 00 00     call    ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myfirst
  00013 8b 08        mov         ecx, DWORD PTR [eax]
  00015 51                 push    ecx
  00016 8b 4d 08   mov         ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00019 e8 00 00 00 00     call    ??0?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PAIPAU_Container_base0@1@@Z ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >
  0001e 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2627 :              }

  00021 8b e5        mov         esp, ebp
  00023 5d                 pop     ebp
  00024 c2 04 00   ret         4
?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ ENDP ; std::vector<bool,std::allocator<bool> >::begin
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ PROC    ; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >, COMDAT
; _this$ = ecx

; 2604 :              {   // destroy the object

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2605 :              }

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ??1?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@XZ ; std::_Vb_val<std::allocator<bool> >::~_Vb_val<std::allocator<bool> >
  0000f 8b e5        mov         esp, ebp
  00011 5d                 pop     ebp
  00012 c3                 ret     0
??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ ENDP    ; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@IABV?$allocator@_N@1@@Z
_TEXT   SEGMENT
_this$ = -8                                   ; size = 4
$T1 = -1                                                ; size = 1
__Count$ = 8                                            ; size = 4
__Al$ = 12                                          ; size = 4
??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@IABV?$allocator@_N@1@@Z PROC ; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >, COMDAT
; _this$ = ecx

; 2496 :              {   // construct from _Count * false, optional allocator

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d f8   mov         DWORD PTR _this$[ebp], ecx

; 2495 :              : _Mybase(_Count, false, _Al)

  00009 c6 45 ff 00        mov   BYTE PTR $T1[ebp], 0
  0000d 8b 45 0c   mov         eax, DWORD PTR __Al$[ebp]
  00010 50                 push    eax
  00011 8d 4d ff   lea         ecx, DWORD PTR $T1[ebp]
  00014 51                 push    ecx
  00015 8b 55 08   mov         edx, DWORD PTR __Count$[ebp]
  00018 52                 push    edx
  00019 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  0001c e8 00 00 00 00     call    ??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@IAB_NABV?$allocator@_N@1@@Z ; std::_Vb_val<std::allocator<bool> >::_Vb_val<std::allocator<bool> >

; 2497 :              _Trim(_Count);

  00021 8b 45 08   mov         eax, DWORD PTR __Count$[ebp]
  00024 50                 push    eax
  00025 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00028 e8 00 00 00 00     call    ?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI@Z ; std::vector<bool,std::allocator<bool> >::_Trim

; 2498 :              }

  0002d 8b 45 f8   mov         eax, DWORD PTR _this$[ebp]
  00030 8b e5        mov         esp, ebp
  00032 5d                 pop     ebp
  00033 c2 08 00   ret         8
??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@IABV?$allocator@_N@1@@Z ENDP ; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Nw@?$_Vb_val@V?$allocator@_N@std@@@std@@SAII@Z
_TEXT   SEGMENT
__Count$ = 8                                            ; size = 4
?_Nw@?$_Vb_val@V?$allocator@_N@std@@@std@@SAII@Z PROC   ; std::_Vb_val<std::allocator<bool> >::_Nw, COMDAT

; 2444 :              {   // return number of base words from number of bits

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 2445 :              return ((_Count + _VBITS - 1) / _VBITS);

  00003 8b 45 08   mov         eax, DWORD PTR __Count$[ebp]
  00006 83 c0 1f   add         eax, 31                        ; 0000001fH
  00009 c1 e8 05   shr         eax, 5

; 2446 :              }

  0000c 5d                 pop     ebp
  0000d c3                 ret     0
?_Nw@?$_Vb_val@V?$allocator@_N@std@@@std@@SAII@Z ENDP   ; std::_Vb_val<std::allocator<bool> >::_Nw
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Free_proxy@?$_Vb_val@V?$allocator@_N@std@@@std@@QAEXXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Free_proxy@?$_Vb_val@V?$allocator@_N@std@@@std@@QAEXXZ PROC ; std::_Vb_val<std::allocator<bool> >::_Free_proxy, COMDAT
; _this$ = ecx

; 2414 :              {   // do nothing

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2415 :              }

  00007 8b e5        mov         esp, ebp
  00009 5d                 pop     ebp
  0000a c3                 ret     0
?_Free_proxy@?$_Vb_val@V?$allocator@_N@std@@@std@@QAEXXZ ENDP ; std::_Vb_val<std::allocator<bool> >::_Free_proxy
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Alloc_proxy@?$_Vb_val@V?$allocator@_N@std@@@std@@QAEXXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Alloc_proxy@?$_Vb_val@V?$allocator@_N@std@@@std@@QAEXXZ PROC ; std::_Vb_val<std::allocator<bool> >::_Alloc_proxy, COMDAT
; _this$ = ecx

; 2410 :              {   // do nothing

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2411 :              }

  00007 8b e5        mov         esp, ebp
  00009 5d                 pop     ebp
  0000a c3                 ret     0
?_Alloc_proxy@?$_Vb_val@V?$allocator@_N@std@@@std@@QAEXXZ ENDP ; std::_Vb_val<std::allocator<bool> >::_Alloc_proxy
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??1?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??1?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@XZ PROC     ; std::_Vb_val<std::allocator<bool> >::~_Vb_val<std::allocator<bool> >, COMDAT
; _this$ = ecx

; 2400 :              {   // destroy proxy

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2401 :              _Free_proxy();

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Free_proxy@?$_Vb_val@V?$allocator@_N@std@@@std@@QAEXXZ ; std::_Vb_val<std::allocator<bool> >::_Free_proxy

; 2402 :              }

  0000f 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00012 e8 00 00 00 00     call    ??1?$vector@IV?$allocator@_N@std@@@std@@QAE@XZ ; std::vector<unsigned int,std::allocator<bool> >::~vector<unsigned int,std::allocator<bool> >
  00017 8b e5        mov         esp, ebp
  00019 5d                 pop     ebp
  0001a c3                 ret     0
??1?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@XZ ENDP     ; std::_Vb_val<std::allocator<bool> >::~_Vb_val<std::allocator<bool> >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@IAB_NABV?$allocator@_N@1@@Z
_TEXT   SEGMENT
$T1 = -12                                         ; size = 4
tv70 = -8                                         ; size = 4
_this$ = -4                                   ; size = 4
__Count$ = 8                                            ; size = 4
__Val$ = 12                                   ; size = 4
__Al$ = 16                                          ; size = 4
??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@IAB_NABV?$allocator@_N@1@@Z PROC ; std::_Vb_val<std::allocator<bool> >::_Vb_val<std::allocator<bool> >, COMDAT
; _this$ = ecx

; 2364 :              {   // construct _Count * _Val elements with allocator _Al

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 0c   sub         esp, 12                        ; 0000000cH
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2363 :              : _Myvec(_Nw(_Count), (_Vbase)(_Val ? -1 : 0), _Al)

  00009 8b 45 0c   mov         eax, DWORD PTR __Val$[ebp]
  0000c 0f b6 08   movzx       ecx, BYTE PTR [eax]
  0000f 85 c9        test        ecx, ecx
  00011 74 09        je  SHORT $LN3@Vb_val
  00013 c7 45 f8 ff ff
        ff ff          mov         DWORD PTR tv70[ebp], -1
  0001a eb 07        jmp         SHORT $LN4@Vb_val
$LN3@Vb_val:
  0001c c7 45 f8 00 00
        00 00          mov         DWORD PTR tv70[ebp], 0
$LN4@Vb_val:
  00023 8b 55 f8   mov         edx, DWORD PTR tv70[ebp]
  00026 89 55 f4   mov         DWORD PTR $T1[ebp], edx
  00029 8b 45 10   mov         eax, DWORD PTR __Al$[ebp]
  0002c 50                 push    eax
  0002d 8d 4d f4   lea         ecx, DWORD PTR $T1[ebp]
  00030 51                 push    ecx
  00031 8b 55 08   mov         edx, DWORD PTR __Count$[ebp]
  00034 52                 push    edx
  00035 e8 00 00 00 00     call    ?_Nw@?$_Vb_val@V?$allocator@_N@std@@@std@@SAII@Z ; std::_Vb_val<std::allocator<bool> >::_Nw
  0003a 83 c4 04   add         esp, 4
  0003d 50                 push    eax
  0003e 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00041 e8 00 00 00 00     call    ??0?$vector@IV?$allocator@_N@std@@@std@@QAE@IABIABV?$allocator@_N@1@@Z ; std::vector<unsigned int,std::allocator<bool> >::vector<unsigned int,std::allocator<bool> >

; 2365 :              _Alloc_proxy();

  00046 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00049 e8 00 00 00 00     call    ?_Alloc_proxy@?$_Vb_val@V?$allocator@_N@std@@@std@@QAEXXZ ; std::_Vb_val<std::allocator<bool> >::_Alloc_proxy

; 2366 :              _Mysize = 0;

  0004e 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00051 c7 40 0c 00 00
        00 00          mov         DWORD PTR [eax+12], 0

; 2367 :              }

  00058 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0005b 8b e5        mov         esp, ebp
  0005d 5d                 pop     ebp
  0005e c2 0c 00   ret         12           ; 0000000cH
??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@IAB_NABV?$allocator@_N@1@@Z ENDP ; std::_Vb_val<std::allocator<bool> >::_Vb_val<std::allocator<bool> >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Xlen@?$vector@IV?$allocator@_N@std@@@std@@IBEXXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Xlen@?$vector@IV?$allocator@_N@std@@@std@@IBEXXZ PROC ; std::vector<unsigned int,std::allocator<bool> >::_Xlen, COMDAT
; _this$ = ecx

; 1787 :              {   // report a length_error

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1788 :              _Xlength_error("vector<T> too long");

  00007 68 00 00 00 00     push    OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0000c e8 00 00 00 00     call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen:

; 1789 :              }

  00011 8b e5        mov         esp, ebp
  00013 5d                 pop     ebp
  00014 c3                 ret     0
?_Xlen@?$vector@IV?$allocator@_N@std@@@std@@IBEXXZ ENDP ; std::vector<unsigned int,std::allocator<bool> >::_Xlen
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Ufill@?$vector@IV?$allocator@_N@std@@@std@@IAEPAIPAIIPBI@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Ptr$ = 8                                          ; size = 4
__Count$ = 12                                     ; size = 4
__Pval$ = 16                                            ; size = 4
?_Ufill@?$vector@IV?$allocator@_N@std@@@std@@IAEPAIPAIIPBI@Z PROC ; std::vector<unsigned int,std::allocator<bool> >::_Ufill, COMDAT
; _this$ = ecx

; 1781 :              {   // copy initializing _Count * _Val, using allocator

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1782 :              _Uninitialized_fill_n(_Ptr, _Count, _Pval, this->_Getal());

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Getal
  0000f 50                 push    eax
  00010 8b 45 10   mov         eax, DWORD PTR __Pval$[ebp]
  00013 50                 push    eax
  00014 8b 4d 0c   mov         ecx, DWORD PTR __Count$[ebp]
  00017 51                 push    ecx
  00018 8b 55 08   mov         edx, DWORD PTR __Ptr$[ebp]
  0001b 52                 push    edx
  0001c e8 00 00 00 00     call    ??$_Uninitialized_fill_n@PAIIU?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAXPAIIPBIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z ; std::_Uninitialized_fill_n<unsigned int *,unsigned int,std::_Wrap_alloc<std::allocator<unsigned int> > >
  00021 83 c4 10   add         esp, 16                        ; 00000010H

; 1783 :              return (_Ptr + _Count);

  00024 8b 45 0c   mov         eax, DWORD PTR __Count$[ebp]
  00027 8b 4d 08   mov         ecx, DWORD PTR __Ptr$[ebp]
  0002a 8d 04 81   lea         eax, DWORD PTR [ecx+eax*4]

; 1784 :              }

  0002d 8b e5        mov         esp, ebp
  0002f 5d                 pop     ebp
  00030 c2 0c 00   ret         12           ; 0000000cH
?_Ufill@?$vector@IV?$allocator@_N@std@@@std@@IAEPAIPAIIPBI@Z ENDP ; std::vector<unsigned int,std::allocator<bool> >::_Ufill
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Tidy@?$vector@IV?$allocator@_N@std@@@std@@IAEXXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Tidy@?$vector@IV?$allocator@_N@std@@@std@@IAEXXZ PROC ; std::vector<unsigned int,std::allocator<bool> >::_Tidy, COMDAT
; _this$ = ecx

; 1659 :              {   // free all storage

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 56                 push    esi
  00005 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1660 :              if (this->_Myfirst() != pointer())

  00008 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000b e8 00 00 00 00     call    ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myfirst
  00010 83 38 00   cmp         DWORD PTR [eax], 0
  00013 0f 84 84 00 00
        00           je      $LN1@Tidy

; 1661 :                  {       // something to free, destroy and deallocate it
; 1662 :                  this->_Orphan_all();

  00019 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001c e8 00 00 00 00     call    ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Orphan_all

; 1663 :                  _Destroy(this->_Myfirst(), this->_Mylast());

  00021 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00024 e8 00 00 00 00     call    ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Mylast
  00029 8b 00        mov         eax, DWORD PTR [eax]
  0002b 50                 push    eax
  0002c 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0002f e8 00 00 00 00     call    ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myfirst
  00034 8b 08        mov         ecx, DWORD PTR [eax]
  00036 51                 push    ecx
  00037 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0003a e8 00 00 00 00     call    ?_Destroy@?$vector@IV?$allocator@_N@std@@@std@@IAEXPAI0@Z ; std::vector<unsigned int,std::allocator<bool> >::_Destroy

; 1664 :                  this->_Getal().deallocate(this->_Myfirst(),

  0003f 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00042 e8 00 00 00 00     call    ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myend
  00047 8b f0        mov         esi, eax
  00049 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0004c e8 00 00 00 00     call    ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myfirst
  00051 8b 16        mov         edx, DWORD PTR [esi]
  00053 2b 10        sub         edx, DWORD PTR [eax]
  00055 c1 fa 02   sar         edx, 2
  00058 52                 push    edx
  00059 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0005c e8 00 00 00 00     call    ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myfirst
  00061 8b 00        mov         eax, DWORD PTR [eax]
  00063 50                 push    eax
  00064 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00067 e8 00 00 00 00     call    ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Getal
  0006c 8b c8        mov         ecx, eax
  0006e e8 00 00 00 00     call    ?deallocate@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAII@Z ; std::_Wrap_alloc<std::allocator<unsigned int> >::deallocate

; 1665 :                          this->_Myend() - this->_Myfirst());
; 1666 :                  this->_Myfirst() = pointer();

  00073 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00076 e8 00 00 00 00     call    ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myfirst
  0007b c7 00 00 00 00
        00           mov     DWORD PTR [eax], 0

; 1667 :                  this->_Mylast() = pointer();

  00081 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00084 e8 00 00 00 00     call    ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Mylast
  00089 c7 00 00 00 00
        00           mov     DWORD PTR [eax], 0

; 1668 :                  this->_Myend() = pointer();

  0008f 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00092 e8 00 00 00 00     call    ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myend
  00097 c7 00 00 00 00
        00           mov     DWORD PTR [eax], 0
$LN1@Tidy:

; 1669 :                  }
; 1670 :              }

  0009d 5e                 pop     esi
  0009e 8b e5        mov         esp, ebp
  000a0 5d                 pop     ebp
  000a1 c3                 ret     0
?_Tidy@?$vector@IV?$allocator@_N@std@@@std@@IAEXXZ ENDP ; std::vector<unsigned int,std::allocator<bool> >::_Tidy
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Reserve@?$vector@IV?$allocator@_N@std@@@std@@IAEXI@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Count$ = 8                                            ; size = 4
?_Reserve@?$vector@IV?$allocator@_N@std@@@std@@IAEXI@Z PROC ; std::vector<unsigned int,std::allocator<bool> >::_Reserve, COMDAT
; _this$ = ecx

; 1649 :              {   // ensure room for _Count new elements, grow exponentially

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 56                 push    esi
  00005 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1650 :              if (_Unused_capacity() < _Count)

  00008 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000b e8 00 00 00 00     call    ?_Unused_capacity@?$vector@IV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<bool> >::_Unused_capacity
  00010 3b 45 08   cmp         eax, DWORD PTR __Count$[ebp]
  00013 73 3e        jae         SHORT $LN4@Reserve

; 1651 :                  {       // need more room, try to get it
; 1652 :                  if (max_size() - size() < _Count)

  00015 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00018 e8 00 00 00 00     call    ?max_size@?$vector@IV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<bool> >::max_size
  0001d 8b f0        mov         esi, eax
  0001f 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00022 e8 00 00 00 00     call    ?size@?$vector@IV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<bool> >::size
  00027 2b f0        sub         esi, eax
  00029 3b 75 08   cmp         esi, DWORD PTR __Count$[ebp]
  0002c 73 08        jae         SHORT $LN3@Reserve

; 1653 :                          _Xlen();

  0002e 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00031 e8 00 00 00 00     call    ?_Xlen@?$vector@IV?$allocator@_N@std@@@std@@IBEXXZ ; std::vector<unsigned int,std::allocator<bool> >::_Xlen
$LN3@Reserve:

; 1654 :                  _Reallocate(_Grow_to(size() + _Count));

  00036 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00039 e8 00 00 00 00     call    ?size@?$vector@IV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<bool> >::size
  0003e 03 45 08   add         eax, DWORD PTR __Count$[ebp]
  00041 50                 push    eax
  00042 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00045 e8 00 00 00 00     call    ?_Grow_to@?$vector@IV?$allocator@_N@std@@@std@@IBEII@Z ; std::vector<unsigned int,std::allocator<bool> >::_Grow_to
  0004a 50                 push    eax
  0004b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0004e e8 00 00 00 00     call    ?_Reallocate@?$vector@IV?$allocator@_N@std@@@std@@IAEXI@Z ; std::vector<unsigned int,std::allocator<bool> >::_Reallocate
$LN4@Reserve:

; 1655 :                  }
; 1656 :              }

  00053 5e                 pop     esi
  00054 8b e5        mov         esp, ebp
  00056 5d                 pop     ebp
  00057 c2 04 00   ret         4
?_Reserve@?$vector@IV?$allocator@_N@std@@@std@@IAEXI@Z ENDP ; std::vector<unsigned int,std::allocator<bool> >::_Reserve
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Reallocate@?$vector@IV?$allocator@_N@std@@@std@@IAEXI@Z
_TEXT   SEGMENT
__Size$ = -28                                     ; size = 4
__Ptr$ = -24                                            ; size = 4
_this$ = -20                                            ; size = 4
__$EHRec$ = -16                               ; size = 16
__Count$ = 8                                            ; size = 4
?_Reallocate@?$vector@IV?$allocator@_N@std@@@std@@IAEXI@Z PROC ; std::vector<unsigned int,std::allocator<bool> >::_Reallocate, COMDAT
; _this$ = ecx

; 1624 :              {   // move to array of exactly _Count elements

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 6a ff        push        -1
  00005 68 00 00 00 00     push    __ehhandler$?_Reallocate@?$vector@IV?$allocator@_N@std@@@std@@IAEXI@Z
  0000a 64 a1 00 00 00
        00           mov     eax, DWORD PTR fs:0
  00010 50                 push    eax
  00011 51                 push    ecx
  00012 83 ec 0c   sub         esp, 12                        ; 0000000cH
  00015 53                 push    ebx
  00016 56                 push    esi
  00017 57                 push    edi
  00018 a1 00 00 00 00     mov     eax, DWORD PTR ___security_cookie
  0001d 33 c5        xor         eax, ebp
  0001f 50                 push    eax
  00020 8d 45 f4   lea         eax, DWORD PTR __$EHRec$[ebp+4]
  00023 64 a3 00 00 00
        00           mov     DWORD PTR fs:0, eax
  00029 89 65 f0   mov         DWORD PTR __$EHRec$[ebp], esp
  0002c 89 4d ec   mov         DWORD PTR _this$[ebp], ecx

; 1625 :              pointer _Ptr = this->_Getal().allocate(_Count);

  0002f 8b 45 08   mov         eax, DWORD PTR __Count$[ebp]
  00032 50                 push    eax
  00033 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  00036 e8 00 00 00 00     call    ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Getal
  0003b 8b c8        mov         ecx, eax
  0003d e8 00 00 00 00     call    ?allocate@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEPAII@Z ; std::_Wrap_alloc<std::allocator<unsigned int> >::allocate
  00042 89 45 e8   mov         DWORD PTR __Ptr$[ebp], eax

; 1626 :
; 1627 :              _TRY_BEGIN

  00045 c7 45 fc 00 00
        00 00          mov         DWORD PTR __$EHRec$[ebp+12], 0

; 1628 :              _Umove(this->_Myfirst(), this->_Mylast(), _Ptr);

  0004c 8b 4d e8   mov         ecx, DWORD PTR __Ptr$[ebp]
  0004f 51                 push    ecx
  00050 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  00053 e8 00 00 00 00     call    ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Mylast
  00058 8b 10        mov         edx, DWORD PTR [eax]
  0005a 52                 push    edx
  0005b 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  0005e e8 00 00 00 00     call    ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myfirst
  00063 8b 00        mov         eax, DWORD PTR [eax]
  00065 50                 push    eax
  00066 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  00069 e8 00 00 00 00     call    ??$_Umove@PAI@?$vector@IV?$allocator@_N@std@@@std@@IAEPAIPAI00@Z ; std::vector<unsigned int,std::allocator<bool> >::_Umove<unsigned int *>
  0006e eb 26        jmp         SHORT $LN5@Reallocate
__catch$?_Reallocate@?$vector@IV?$allocator@_N@std@@@std@@IAEXI@Z$0:

; 1629 :              _CATCH_ALL
; 1630 :              this->_Getal().deallocate(_Ptr, _Count);

  00070 8b 4d 08   mov         ecx, DWORD PTR __Count$[ebp]
  00073 51                 push    ecx
  00074 8b 55 e8   mov         edx, DWORD PTR __Ptr$[ebp]
  00077 52                 push    edx
  00078 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  0007b e8 00 00 00 00     call    ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Getal
  00080 8b c8        mov         ecx, eax
  00082 e8 00 00 00 00     call    ?deallocate@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAII@Z ; std::_Wrap_alloc<std::allocator<unsigned int> >::deallocate

; 1631 :              _RERAISE;

  00087 6a 00        push        0
  00089 6a 00        push        0
  0008b e8 00 00 00 00     call    __CxxThrowException@8

; 1632 :              _CATCH_END

  00090 b8 00 00 00 00     mov     eax, $LN8@Reallocate
  00095 c3                 ret     0
$LN5@Reallocate:
  00096 c7 45 fc ff ff
        ff ff          mov         DWORD PTR __$EHRec$[ebp+12], -1
  0009d eb 07        jmp         SHORT __tryend$?_Reallocate@?$vector@IV?$allocator@_N@std@@@std@@IAEXI@Z$1
$LN8@Reallocate:
  0009f c7 45 fc ff ff
        ff ff          mov         DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Reallocate@?$vector@IV?$allocator@_N@std@@@std@@IAEXI@Z$1:

; 1633 :
; 1634 :              size_type _Size = size();

  000a6 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  000a9 e8 00 00 00 00     call    ?size@?$vector@IV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<bool> >::size
  000ae 89 45 e4   mov         DWORD PTR __Size$[ebp], eax

; 1635 :              if (this->_Myfirst() != pointer())

  000b1 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  000b4 e8 00 00 00 00     call    ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myfirst
  000b9 83 38 00   cmp         DWORD PTR [eax], 0
  000bc 74 52        je  SHORT $LN3@Reallocate

; 1636 :                  {       // destroy and deallocate old array
; 1637 :                  _Destroy(this->_Myfirst(), this->_Mylast());

  000be 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  000c1 e8 00 00 00 00     call    ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Mylast
  000c6 8b 00        mov         eax, DWORD PTR [eax]
  000c8 50                 push    eax
  000c9 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  000cc e8 00 00 00 00     call    ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myfirst
  000d1 8b 08        mov         ecx, DWORD PTR [eax]
  000d3 51                 push    ecx
  000d4 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  000d7 e8 00 00 00 00     call    ?_Destroy@?$vector@IV?$allocator@_N@std@@@std@@IAEXPAI0@Z ; std::vector<unsigned int,std::allocator<bool> >::_Destroy

; 1638 :                  this->_Getal().deallocate(this->_Myfirst(),

  000dc 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  000df e8 00 00 00 00     call    ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myend
  000e4 8b f0        mov         esi, eax
  000e6 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  000e9 e8 00 00 00 00     call    ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myfirst
  000ee 8b 16        mov         edx, DWORD PTR [esi]
  000f0 2b 10        sub         edx, DWORD PTR [eax]
  000f2 c1 fa 02   sar         edx, 2
  000f5 52                 push    edx
  000f6 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  000f9 e8 00 00 00 00     call    ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myfirst
  000fe 8b 00        mov         eax, DWORD PTR [eax]
  00100 50                 push    eax
  00101 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  00104 e8 00 00 00 00     call    ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Getal
  00109 8b c8        mov         ecx, eax
  0010b e8 00 00 00 00     call    ?deallocate@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAII@Z ; std::_Wrap_alloc<std::allocator<unsigned int> >::deallocate
$LN3@Reallocate:

; 1639 :                          this->_Myend() - this->_Myfirst());
; 1640 :                  }
; 1641 :
; 1642 :              this->_Orphan_all();

  00110 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  00113 e8 00 00 00 00     call    ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Orphan_all

; 1643 :              this->_Myend() = _Ptr + _Count;

  00118 8b 4d 08   mov         ecx, DWORD PTR __Count$[ebp]
  0011b 8b 55 e8   mov         edx, DWORD PTR __Ptr$[ebp]
  0011e 8d 34 8a   lea         esi, DWORD PTR [edx+ecx*4]
  00121 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  00124 e8 00 00 00 00     call    ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myend
  00129 89 30        mov         DWORD PTR [eax], esi

; 1644 :              this->_Mylast() = _Ptr + _Size;

  0012b 8b 45 e4   mov         eax, DWORD PTR __Size$[ebp]
  0012e 8b 4d e8   mov         ecx, DWORD PTR __Ptr$[ebp]
  00131 8d 34 81   lea         esi, DWORD PTR [ecx+eax*4]
  00134 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  00137 e8 00 00 00 00     call    ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Mylast
  0013c 89 30        mov         DWORD PTR [eax], esi

; 1645 :              this->_Myfirst() = _Ptr;

  0013e 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  00141 e8 00 00 00 00     call    ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myfirst
  00146 8b 55 e8   mov         edx, DWORD PTR __Ptr$[ebp]
  00149 89 10        mov         DWORD PTR [eax], edx
$LN4@Reallocate:

; 1646 :              }

  0014b 8b 4d f4   mov         ecx, DWORD PTR __$EHRec$[ebp+4]
  0014e 64 89 0d 00 00
        00 00          mov         DWORD PTR fs:0, ecx
  00155 59                 pop     ecx
  00156 5f                 pop     edi
  00157 5e                 pop     esi
  00158 5b                 pop     ebx
  00159 8b e5        mov         esp, ebp
  0015b 5d                 pop     ebp
  0015c c2 04 00   ret         4
_TEXT   ENDS
;       COMDAT text$x
text$x  SEGMENT
__ehhandler$?_Reallocate@?$vector@IV?$allocator@_N@std@@@std@@IAEXI@Z:
  00000 8b 54 24 08        mov   edx, DWORD PTR [esp+8]
  00004 8d 42 0c   lea         eax, DWORD PTR [edx+12]
  00007 8b 4a e0   mov         ecx, DWORD PTR [edx-32]
  0000a 33 c8        xor         ecx, eax
  0000c e8 00 00 00 00     call    @__security_check_cookie@4
  00011 b8 00 00 00 00     mov     eax, OFFSET __ehfuncinfo$?_Reallocate@?$vector@IV?$allocator@_N@std@@@std@@IAEXI@Z
  00016 e9 00 00 00 00     jmp     ___CxxFrameHandler3
text$x  ENDS
?_Reallocate@?$vector@IV?$allocator@_N@std@@@std@@IAEXI@Z ENDP ; std::vector<unsigned int,std::allocator<bool> >::_Reallocate
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Inside@?$vector@IV?$allocator@_N@std@@@std@@IBE_NPBI@Z
_TEXT   SEGMENT
tv78 = -8                                         ; size = 4
_this$ = -4                                   ; size = 4
__Ptr$ = 8                                          ; size = 4
?_Inside@?$vector@IV?$allocator@_N@std@@@std@@IBE_NPBI@Z PROC ; std::vector<unsigned int,std::allocator<bool> >::_Inside, COMDAT
; _this$ = ecx

; 1619 :              {   // test if _Ptr points inside vector

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1620 :              return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);

  00009 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000c e8 00 00 00 00     call    ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABQAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Mylast
  00011 8b 4d 08   mov         ecx, DWORD PTR __Ptr$[ebp]
  00014 3b 08        cmp         ecx, DWORD PTR [eax]
  00016 73 18        jae         SHORT $LN3@Inside
  00018 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001b e8 00 00 00 00     call    ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABQAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myfirst
  00020 8b 10        mov         edx, DWORD PTR [eax]
  00022 3b 55 08   cmp         edx, DWORD PTR __Ptr$[ebp]
  00025 77 09        ja  SHORT $LN3@Inside
  00027 c7 45 f8 01 00
        00 00          mov         DWORD PTR tv78[ebp], 1
  0002e eb 07        jmp         SHORT $LN4@Inside
$LN3@Inside:
  00030 c7 45 f8 00 00
        00 00          mov         DWORD PTR tv78[ebp], 0
$LN4@Inside:
  00037 8a 45 f8   mov         al, BYTE PTR tv78[ebp]

; 1621 :              }

  0003a 8b e5        mov         esp, ebp
  0003c 5d                 pop     ebp
  0003d c2 04 00   ret         4
?_Inside@?$vector@IV?$allocator@_N@std@@@std@@IBE_NPBI@Z ENDP ; std::vector<unsigned int,std::allocator<bool> >::_Inside
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Grow_to@?$vector@IV?$allocator@_N@std@@@std@@IBEII@Z
_TEXT   SEGMENT
tv73 = -12                                          ; size = 4
_this$ = -8                                   ; size = 4
__Capacity$ = -4                                        ; size = 4
__Count$ = 8                                            ; size = 4
?_Grow_to@?$vector@IV?$allocator@_N@std@@@std@@IBEII@Z PROC ; std::vector<unsigned int,std::allocator<bool> >::_Grow_to, COMDAT
; _this$ = ecx

; 1608 :              {   // grow by 50% or at least to _Count

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 0c   sub         esp, 12                        ; 0000000cH
  00006 89 4d f8   mov         DWORD PTR _this$[ebp], ecx

; 1609 :              size_type _Capacity = capacity();

  00009 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  0000c e8 00 00 00 00     call    ?capacity@?$vector@IV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<bool> >::capacity
  00011 89 45 fc   mov         DWORD PTR __Capacity$[ebp], eax

; 1610 :
; 1611 :              _Capacity = max_size() - _Capacity / 2 < _Capacity

  00014 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00017 e8 00 00 00 00     call    ?max_size@?$vector@IV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<bool> >::max_size
  0001c 8b 4d fc   mov         ecx, DWORD PTR __Capacity$[ebp]
  0001f d1 e9        shr         ecx, 1
  00021 2b c1        sub         eax, ecx
  00023 3b 45 fc   cmp         eax, DWORD PTR __Capacity$[ebp]
  00026 73 09        jae         SHORT $LN4@Grow_to
  00028 c7 45 f4 00 00
        00 00          mov         DWORD PTR tv73[ebp], 0
  0002f eb 0b        jmp         SHORT $LN5@Grow_to
$LN4@Grow_to:
  00031 8b 55 fc   mov         edx, DWORD PTR __Capacity$[ebp]
  00034 d1 ea        shr         edx, 1
  00036 03 55 fc   add         edx, DWORD PTR __Capacity$[ebp]
  00039 89 55 f4   mov         DWORD PTR tv73[ebp], edx
$LN5@Grow_to:
  0003c 8b 45 f4   mov         eax, DWORD PTR tv73[ebp]
  0003f 89 45 fc   mov         DWORD PTR __Capacity$[ebp], eax

; 1612 :                  ? 0 : _Capacity + _Capacity / 2;        // try to grow by 50%
; 1613 :              if (_Capacity < _Count)

  00042 8b 4d fc   mov         ecx, DWORD PTR __Capacity$[ebp]
  00045 3b 4d 08   cmp         ecx, DWORD PTR __Count$[ebp]
  00048 73 06        jae         SHORT $LN2@Grow_to

; 1614 :                  _Capacity = _Count;

  0004a 8b 55 08   mov         edx, DWORD PTR __Count$[ebp]
  0004d 89 55 fc   mov         DWORD PTR __Capacity$[ebp], edx
$LN2@Grow_to:

; 1615 :              return (_Capacity);

  00050 8b 45 fc   mov         eax, DWORD PTR __Capacity$[ebp]

; 1616 :              }

  00053 8b e5        mov         esp, ebp
  00055 5d                 pop     ebp
  00056 c2 04 00   ret         4
?_Grow_to@?$vector@IV?$allocator@_N@std@@@std@@IBEII@Z ENDP ; std::vector<unsigned int,std::allocator<bool> >::_Grow_to
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Destroy@?$vector@IV?$allocator@_N@std@@@std@@IAEXPAI0@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__First$ = 8                                            ; size = 4
__Last$ = 12                                            ; size = 4
?_Destroy@?$vector@IV?$allocator@_N@std@@@std@@IAEXPAI0@Z PROC ; std::vector<unsigned int,std::allocator<bool> >::_Destroy, COMDAT
; _this$ = ecx

; 1603 :              {   // destroy [_First, _Last) using allocator

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1604 :              _Destroy_range(_First, _Last, this->_Getal());

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Getal
  0000f 50                 push    eax
  00010 8b 45 0c   mov         eax, DWORD PTR __Last$[ebp]
  00013 50                 push    eax
  00014 8b 4d 08   mov         ecx, DWORD PTR __First$[ebp]
  00017 51                 push    ecx
  00018 e8 00 00 00 00     call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAXPAI0AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<unsigned int> > >
  0001d 83 c4 0c   add         esp, 12                        ; 0000000cH

; 1605 :              }

  00020 8b e5        mov         esp, ebp
  00022 5d                 pop     ebp
  00023 c2 08 00   ret         8
?_Destroy@?$vector@IV?$allocator@_N@std@@@std@@IAEXPAI0@Z ENDP ; std::vector<unsigned int,std::allocator<bool> >::_Destroy
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Buy@?$vector@IV?$allocator@_N@std@@@std@@IAE_NI@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Capacity$ = 8                               ; size = 4
?_Buy@?$vector@IV?$allocator@_N@std@@@std@@IAE_NI@Z PROC ; std::vector<unsigned int,std::allocator<bool> >::_Buy, COMDAT
; _this$ = ecx

; 1584 :              {   // allocate array with _Capacity elements

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 56                 push    esi
  00005 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1585 :              this->_Myfirst() = pointer();

  00008 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000b e8 00 00 00 00     call    ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myfirst
  00010 c7 00 00 00 00
        00           mov     DWORD PTR [eax], 0

; 1586 :              this->_Mylast() = pointer();

  00016 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00019 e8 00 00 00 00     call    ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Mylast
  0001e c7 00 00 00 00
        00           mov     DWORD PTR [eax], 0

; 1587 :              this->_Myend() = pointer();

  00024 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00027 e8 00 00 00 00     call    ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myend
  0002c c7 00 00 00 00
        00           mov     DWORD PTR [eax], 0

; 1588 :
; 1589 :              if (_Capacity == 0)

  00032 83 7d 08 00        cmp   DWORD PTR __Capacity$[ebp], 0
  00036 75 06        jne         SHORT $LN2@Buy

; 1590 :                  return (false);

  00038 32 c0        xor         al, al
  0003a eb 6a        jmp         SHORT $LN6@Buy
  0003c eb 66        jmp         SHORT $LN3@Buy
$LN2@Buy:

; 1591 :              else if (max_size() < _Capacity)

  0003e 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00041 e8 00 00 00 00     call    ?max_size@?$vector@IV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<bool> >::max_size
  00046 3b 45 08   cmp         eax, DWORD PTR __Capacity$[ebp]
  00049 73 0a        jae         SHORT $LN4@Buy

; 1592 :                  _Xlen();        // result too long

  0004b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0004e e8 00 00 00 00     call    ?_Xlen@?$vector@IV?$allocator@_N@std@@@std@@IBEXXZ ; std::vector<unsigned int,std::allocator<bool> >::_Xlen

; 1593 :              else

  00053 eb 4f        jmp         SHORT $LN3@Buy
$LN4@Buy:

; 1594 :                  {       // nonempty array, allocate storage
; 1595 :                  this->_Myfirst() = this->_Getal().allocate(_Capacity);

  00055 8b 45 08   mov         eax, DWORD PTR __Capacity$[ebp]
  00058 50                 push    eax
  00059 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0005c e8 00 00 00 00     call    ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Getal
  00061 8b c8        mov         ecx, eax
  00063 e8 00 00 00 00     call    ?allocate@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEPAII@Z ; std::_Wrap_alloc<std::allocator<unsigned int> >::allocate
  00068 8b f0        mov         esi, eax
  0006a 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0006d e8 00 00 00 00     call    ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myfirst
  00072 89 30        mov         DWORD PTR [eax], esi

; 1596 :                  this->_Mylast() = this->_Myfirst();

  00074 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00077 e8 00 00 00 00     call    ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myfirst
  0007c 8b f0        mov         esi, eax
  0007e 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00081 e8 00 00 00 00     call    ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Mylast
  00086 8b 0e        mov         ecx, DWORD PTR [esi]
  00088 89 08        mov         DWORD PTR [eax], ecx

; 1597 :                  this->_Myend() = this->_Myfirst() + _Capacity;

  0008a 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0008d e8 00 00 00 00     call    ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myfirst
  00092 8b 10        mov         edx, DWORD PTR [eax]
  00094 8b 45 08   mov         eax, DWORD PTR __Capacity$[ebp]
  00097 8d 34 82   lea         esi, DWORD PTR [edx+eax*4]
  0009a 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0009d e8 00 00 00 00     call    ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myend
  000a2 89 30        mov         DWORD PTR [eax], esi
$LN3@Buy:

; 1598 :                  }
; 1599 :              return (true);

  000a4 b0 01        mov         al, 1
$LN6@Buy:

; 1600 :              }

  000a6 5e                 pop     esi
  000a7 8b e5        mov         esp, ebp
  000a9 5d                 pop     ebp
  000aa c2 04 00   ret         4
?_Buy@?$vector@IV?$allocator@_N@std@@@std@@IAE_NI@Z ENDP ; std::vector<unsigned int,std::allocator<bool> >::_Buy
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?clear@?$vector@IV?$allocator@_N@std@@@std@@QAEXXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?clear@?$vector@IV?$allocator@_N@std@@@std@@QAEXXZ PROC ; std::vector<unsigned int,std::allocator<bool> >::clear, COMDAT
; _this$ = ecx

; 1543 :              {   // erase all

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 56                 push    esi
  00005 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1544 :              this->_Orphan_all();

  00008 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000b e8 00 00 00 00     call    ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Orphan_all

; 1545 :              _Destroy(this->_Myfirst(), this->_Mylast());

  00010 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00013 e8 00 00 00 00     call    ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Mylast
  00018 8b 00        mov         eax, DWORD PTR [eax]
  0001a 50                 push    eax
  0001b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001e e8 00 00 00 00     call    ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myfirst
  00023 8b 08        mov         ecx, DWORD PTR [eax]
  00025 51                 push    ecx
  00026 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00029 e8 00 00 00 00     call    ?_Destroy@?$vector@IV?$allocator@_N@std@@@std@@IAEXPAI0@Z ; std::vector<unsigned int,std::allocator<bool> >::_Destroy

; 1546 :              this->_Mylast() = this->_Myfirst();

  0002e 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00031 e8 00 00 00 00     call    ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myfirst
  00036 8b f0        mov         esi, eax
  00038 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0003b e8 00 00 00 00     call    ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Mylast
  00040 8b 16        mov         edx, DWORD PTR [esi]
  00042 89 10        mov         DWORD PTR [eax], edx

; 1547 :              }

  00044 5e                 pop     esi
  00045 8b e5        mov         esp, ebp
  00047 5d                 pop     ebp
  00048 c3                 ret     0
?clear@?$vector@IV?$allocator@_N@std@@@std@@QAEXXZ ENDP ; std::vector<unsigned int,std::allocator<bool> >::clear
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Pop_back_n@?$vector@IV?$allocator@_N@std@@@std@@QAEXI@Z
_TEXT   SEGMENT
__Ptr$ = -8                                   ; size = 4
_this$ = -4                                   ; size = 4
__Count$ = 8                                            ; size = 4
?_Pop_back_n@?$vector@IV?$allocator@_N@std@@@std@@QAEXI@Z PROC ; std::vector<unsigned int,std::allocator<bool> >::_Pop_back_n, COMDAT
; _this$ = ecx

; 1531 :              {   // erase _Count elements at end

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1532 :              pointer _Ptr = this->_Mylast() - _Count;

  00009 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000c e8 00 00 00 00     call    ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Mylast
  00011 8b 4d 08   mov         ecx, DWORD PTR __Count$[ebp]
  00014 c1 e1 02   shl         ecx, 2
  00017 8b 10        mov         edx, DWORD PTR [eax]
  00019 2b d1        sub         edx, ecx
  0001b 89 55 f8   mov         DWORD PTR __Ptr$[ebp], edx

; 1533 :
; 1534 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1535 :              _Orphan_range(_Ptr, this->_Mylast());
; 1536 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1537 :
; 1538 :              _Destroy(_Ptr, this->_Mylast());

  0001e 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00021 e8 00 00 00 00     call    ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Mylast
  00026 8b 00        mov         eax, DWORD PTR [eax]
  00028 50                 push    eax
  00029 8b 4d f8   mov         ecx, DWORD PTR __Ptr$[ebp]
  0002c 51                 push    ecx
  0002d 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00030 e8 00 00 00 00     call    ?_Destroy@?$vector@IV?$allocator@_N@std@@@std@@IAEXPAI0@Z ; std::vector<unsigned int,std::allocator<bool> >::_Destroy

; 1539 :              this->_Mylast() = _Ptr;

  00035 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00038 e8 00 00 00 00     call    ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Mylast
  0003d 8b 55 f8   mov         edx, DWORD PTR __Ptr$[ebp]
  00040 89 10        mov         DWORD PTR [eax], edx

; 1540 :              }

  00042 8b e5        mov         esp, ebp
  00044 5d                 pop     ebp
  00045 c2 04 00   ret         4
?_Pop_back_n@?$vector@IV?$allocator@_N@std@@@std@@QAEXI@Z ENDP ; std::vector<unsigned int,std::allocator<bool> >::_Pop_back_n
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?erase@?$vector@IV?$allocator@_N@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@0@Z
_TEXT   SEGMENT
$T1 = -24                                         ; size = 4
$T2 = -20                                         ; size = 4
__Ptr$3 = -16                                     ; size = 4
__Last$4 = -12                                      ; size = 4
__First$5 = -8                                      ; size = 4
_this$ = -4                                   ; size = 4
___$ReturnUdt$ = 8                                  ; size = 4
__First_arg$ = 12                                 ; size = 4
__Last_arg$ = 16                                        ; size = 4
?erase@?$vector@IV?$allocator@_N@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@0@Z PROC ; std::vector<unsigned int,std::allocator<bool> >::erase, COMDAT
; _this$ = ecx

; 1499 :              {   // erase [_First, _Last)

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 18   sub         esp, 24                        ; 00000018H
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1500 :              if (_First_arg == begin() && _Last_arg == end())

  00009 8d 45 ec   lea         eax, DWORD PTR $T2[ebp]
  0000c 50                 push    eax
  0000d 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00010 e8 00 00 00 00     call    ?begin@?$vector@IV?$allocator@_N@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ ; std::vector<unsigned int,std::allocator<bool> >::begin
  00015 50                 push    eax
  00016 8d 4d 0c   lea         ecx, DWORD PTR __First_arg$[ebp]
  00019 e8 00 00 00 00     call    ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator==
  0001e 0f b6 c8   movzx       ecx, al
  00021 85 c9        test        ecx, ecx
  00023 74 29        je  SHORT $LN2@erase
  00025 8d 55 e8   lea         edx, DWORD PTR $T1[ebp]
  00028 52                 push    edx
  00029 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0002c e8 00 00 00 00     call    ?end@?$vector@IV?$allocator@_N@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ ; std::vector<unsigned int,std::allocator<bool> >::end
  00031 50                 push    eax
  00032 8d 4d 10   lea         ecx, DWORD PTR __Last_arg$[ebp]
  00035 e8 00 00 00 00     call    ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator==
  0003a 0f b6 c0   movzx       eax, al
  0003d 85 c0        test        eax, eax
  0003f 74 0d        je  SHORT $LN2@erase

; 1501 :                  clear();

  00041 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00044 e8 00 00 00 00     call    ?clear@?$vector@IV?$allocator@_N@std@@@std@@QAEXXZ ; std::vector<unsigned int,std::allocator<bool> >::clear
  00049 e9 88 00 00 00     jmp     $LN3@erase
$LN2@erase:

; 1502 :              else if (_First_arg != _Last_arg)

  0004e 8d 4d 10   lea         ecx, DWORD PTR __Last_arg$[ebp]
  00051 51                 push    ecx
  00052 8d 4d 0c   lea         ecx, DWORD PTR __First_arg$[ebp]
  00055 e8 00 00 00 00     call    ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator!=
  0005a 0f b6 d0   movzx       edx, al
  0005d 85 d2        test        edx, edx
  0005f 74 75        je  SHORT $LN3@erase

; 1503 :                  {       // clear partial
; 1504 :                  iterator _First = _Make_iter(_First_arg);

  00061 8b 45 0c   mov         eax, DWORD PTR __First_arg$[ebp]
  00064 50                 push    eax
  00065 8d 4d f8   lea         ecx, DWORD PTR __First$5[ebp]
  00068 51                 push    ecx
  00069 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0006c e8 00 00 00 00     call    ?_Make_iter@?$vector@IV?$allocator@_N@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@@Z ; std::vector<unsigned int,std::allocator<bool> >::_Make_iter

; 1505 :                  iterator _Last = _Make_iter(_Last_arg);

  00071 8b 55 10   mov         edx, DWORD PTR __Last_arg$[ebp]
  00074 52                 push    edx
  00075 8d 45 f4   lea         eax, DWORD PTR __Last$4[ebp]
  00078 50                 push    eax
  00079 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0007c e8 00 00 00 00     call    ?_Make_iter@?$vector@IV?$allocator@_N@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@@Z ; std::vector<unsigned int,std::allocator<bool> >::_Make_iter

; 1506 :
; 1507 :                  if (_First != _Last)

  00081 8d 4d f4   lea         ecx, DWORD PTR __Last$4[ebp]
  00084 51                 push    ecx
  00085 8d 4d f8   lea         ecx, DWORD PTR __First$5[ebp]
  00088 e8 00 00 00 00     call    ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator!=
  0008d 0f b6 d0   movzx       edx, al
  00090 85 d2        test        edx, edx
  00092 74 42        je  SHORT $LN3@erase

; 1508 :                          {       // worth doing, copy down over hole
; 1509 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1510 :                          if (_Last < _First || _VICONT(_First) != &this->_Get_data()
; 1511 :                                  || _VIPTR(_First) < this->_Myfirst()
; 1512 :                                  || this->_Mylast() < _VIPTR(_Last))
; 1513 :                                  _DEBUG_ERROR("vector erase iterator outside range");
; 1514 :                          pointer _Ptr = _Move_unchecked(_VIPTR(_Last), this->_Mylast(),
; 1515 :                                  _VIPTR(_First));
; 1516 :                          _Orphan_range(_VIPTR(_First), this->_Mylast());
; 1517 :
; 1518 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1519 :                          pointer _Ptr = _Move_unchecked(_VIPTR(_Last), this->_Mylast(),

  00094 8b 45 f8   mov         eax, DWORD PTR __First$5[ebp]
  00097 50                 push    eax
  00098 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0009b e8 00 00 00 00     call    ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Mylast
  000a0 8b 08        mov         ecx, DWORD PTR [eax]
  000a2 51                 push    ecx
  000a3 8b 55 f4   mov         edx, DWORD PTR __Last$4[ebp]
  000a6 52                 push    edx
  000a7 e8 00 00 00 00     call    ??$_Move_unchecked@PAIPAI@std@@YAPAIPAI00@Z ; std::_Move_unchecked<unsigned int *,unsigned int *>
  000ac 83 c4 0c   add         esp, 12                        ; 0000000cH
  000af 89 45 f0   mov         DWORD PTR __Ptr$3[ebp], eax

; 1520 :                                  _VIPTR(_First));
; 1521 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1522 :
; 1523 :                          _Destroy(_Ptr, this->_Mylast());

  000b2 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000b5 e8 00 00 00 00     call    ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Mylast
  000ba 8b 00        mov         eax, DWORD PTR [eax]
  000bc 50                 push    eax
  000bd 8b 4d f0   mov         ecx, DWORD PTR __Ptr$3[ebp]
  000c0 51                 push    ecx
  000c1 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000c4 e8 00 00 00 00     call    ?_Destroy@?$vector@IV?$allocator@_N@std@@@std@@IAEXPAI0@Z ; std::vector<unsigned int,std::allocator<bool> >::_Destroy

; 1524 :                          this->_Mylast() = _Ptr;

  000c9 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000cc e8 00 00 00 00     call    ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Mylast
  000d1 8b 55 f0   mov         edx, DWORD PTR __Ptr$3[ebp]
  000d4 89 10        mov         DWORD PTR [eax], edx
$LN3@erase:

; 1525 :                          }
; 1526 :                  }
; 1527 :              return (_Make_iter(_First_arg));

  000d6 8b 45 0c   mov         eax, DWORD PTR __First_arg$[ebp]
  000d9 50                 push    eax
  000da 8b 4d 08   mov         ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000dd 51                 push    ecx
  000de 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000e1 e8 00 00 00 00     call    ?_Make_iter@?$vector@IV?$allocator@_N@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@@Z ; std::vector<unsigned int,std::allocator<bool> >::_Make_iter
  000e6 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1528 :              }

  000e9 8b e5        mov         esp, ebp
  000eb 5d                 pop     ebp
  000ec c2 0c 00   ret         12           ; 0000000cH
?erase@?$vector@IV?$allocator@_N@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@0@Z ENDP ; std::vector<unsigned int,std::allocator<bool> >::erase
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??A?$vector@IV?$allocator@_N@std@@@std@@QAEAAII@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Pos$ = 8                                          ; size = 4
??A?$vector@IV?$allocator@_N@std@@@std@@QAEAAII@Z PROC  ; std::vector<unsigned int,std::allocator<bool> >::operator[], COMDAT
; _this$ = ecx

; 1232 :              {   // subscript mutable sequence

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1233 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1234 :              if (size() <= _Pos)
; 1235 :                  {       // report error
; 1236 :                  _DEBUG_ERROR("vector subscript out of range");
; 1237 :                  _SCL_SECURE_OUT_OF_RANGE;
; 1238 :                  }
; 1239 :
; 1240 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1241 :              _SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1243 :
; 1244 :              return (*(this->_Myfirst() + _Pos));

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myfirst
  0000f 8b 00        mov         eax, DWORD PTR [eax]
  00011 8b 4d 08   mov         ecx, DWORD PTR __Pos$[ebp]
  00014 8d 04 88   lea         eax, DWORD PTR [eax+ecx*4]

; 1245 :              }

  00017 8b e5        mov         esp, ebp
  00019 5d                 pop     ebp
  0001a c2 04 00   ret         4
??A?$vector@IV?$allocator@_N@std@@@std@@QAEAAII@Z ENDP  ; std::vector<unsigned int,std::allocator<bool> >::operator[]
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?max_size@?$vector@IV?$allocator@_N@std@@@std@@QBEIXZ
_TEXT   SEGMENT
_this$ = -8                                   ; size = 4
$T1 = -1                                                ; size = 1
?max_size@?$vector@IV?$allocator@_N@std@@@std@@QBEIXZ PROC ; std::vector<unsigned int,std::allocator<bool> >::max_size, COMDAT
; _this$ = ecx

; 1187 :              {   // return maximum possible length of sequence

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d f8   mov         DWORD PTR _this$[ebp], ecx

; 1188 :              return (this->_Getal().max_size());

  00009 0f b6 45 ff        movzx         eax, BYTE PTR $T1[ebp]
  0000d 50                 push    eax
  0000e 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00011 e8 00 00 00 00     call    ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Getal
  00016 8b c8        mov         ecx, eax
  00018 e8 00 00 00 00     call    ?max_size@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<unsigned int> >::max_size

; 1189 :              }

  0001d 8b e5        mov         esp, ebp
  0001f 5d                 pop     ebp
  00020 c3                 ret     0
?max_size@?$vector@IV?$allocator@_N@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned int,std::allocator<bool> >::max_size
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?size@?$vector@IV?$allocator@_N@std@@@std@@QBEIXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?size@?$vector@IV?$allocator@_N@std@@@std@@QBEIXZ PROC  ; std::vector<unsigned int,std::allocator<bool> >::size, COMDAT
; _this$ = ecx

; 1182 :              {   // return length of sequence

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 56                 push    esi
  00005 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1183 :              return (this->_Mylast() - this->_Myfirst());

  00008 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000b e8 00 00 00 00     call    ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABQAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Mylast
  00010 8b f0        mov         esi, eax
  00012 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00015 e8 00 00 00 00     call    ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABQAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myfirst
  0001a 8b 0e        mov         ecx, DWORD PTR [esi]
  0001c 2b 08        sub         ecx, DWORD PTR [eax]
  0001e c1 f9 02   sar         ecx, 2
  00021 8b c1        mov         eax, ecx

; 1184 :              }

  00023 5e                 pop     esi
  00024 8b e5        mov         esp, ebp
  00026 5d                 pop     ebp
  00027 c3                 ret     0
?size@?$vector@IV?$allocator@_N@std@@@std@@QBEIXZ ENDP  ; std::vector<unsigned int,std::allocator<bool> >::size
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?resize@?$vector@IV?$allocator@_N@std@@@std@@QAEXIABI@Z
_TEXT   SEGMENT
__Idx$2 = -32                                     ; size = 4
tv170 = -28                                   ; size = 4
__Ptr$3 = -24                                     ; size = 4
_this$ = -20                                            ; size = 4
__$EHRec$ = -16                               ; size = 16
__Newsize$ = 8                                      ; size = 4
__Val$ = 12                                   ; size = 4
?resize@?$vector@IV?$allocator@_N@std@@@std@@QAEXIABI@Z PROC ; std::vector<unsigned int,std::allocator<bool> >::resize, COMDAT
; _this$ = ecx

; 1154 :              {   // determine new length, padding with _Val elements as needed

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 6a ff        push        -1
  00005 68 00 00 00 00     push    __ehhandler$?resize@?$vector@IV?$allocator@_N@std@@@std@@QAEXIABI@Z
  0000a 64 a1 00 00 00
        00           mov     eax, DWORD PTR fs:0
  00010 50                 push    eax
  00011 51                 push    ecx
  00012 83 ec 10   sub         esp, 16                        ; 00000010H
  00015 53                 push    ebx
  00016 56                 push    esi
  00017 57                 push    edi
  00018 a1 00 00 00 00     mov     eax, DWORD PTR ___security_cookie
  0001d 33 c5        xor         eax, ebp
  0001f 50                 push    eax
  00020 8d 45 f4   lea         eax, DWORD PTR __$EHRec$[ebp+4]
  00023 64 a3 00 00 00
        00           mov     DWORD PTR fs:0, eax
  00029 89 65 f0   mov         DWORD PTR __$EHRec$[ebp], esp
  0002c 89 4d ec   mov         DWORD PTR _this$[ebp], ecx

; 1155 :              if (_Newsize < size())

  0002f 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  00032 e8 00 00 00 00     call    ?size@?$vector@IV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<bool> >::size
  00037 39 45 08   cmp         DWORD PTR __Newsize$[ebp], eax
  0003a 73 19        jae         SHORT $LN2@resize

; 1156 :                  _Pop_back_n(size() - _Newsize);

  0003c 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  0003f e8 00 00 00 00     call    ?size@?$vector@IV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<bool> >::size
  00044 2b 45 08   sub         eax, DWORD PTR __Newsize$[ebp]
  00047 50                 push    eax
  00048 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  0004b e8 00 00 00 00     call    ?_Pop_back_n@?$vector@IV?$allocator@_N@std@@@std@@QAEXI@Z ; std::vector<unsigned int,std::allocator<bool> >::_Pop_back_n
  00050 e9 15 01 00 00     jmp     $LN8@resize
$LN2@resize:

; 1157 :              else if (size() < _Newsize)

  00055 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  00058 e8 00 00 00 00     call    ?size@?$vector@IV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<bool> >::size
  0005d 3b 45 08   cmp         eax, DWORD PTR __Newsize$[ebp]
  00060 0f 83 04 01 00
        00           jae     $LN8@resize

; 1158 :                  {       // pad as needed
; 1159 :                  const value_type *_Ptr = _STD addressof(_Val);

  00066 8b 45 0c   mov         eax, DWORD PTR __Val$[ebp]
  00069 50                 push    eax
  0006a e8 00 00 00 00     call    ??$addressof@$$CBI@std@@YAPBIABI@Z ; std::addressof<unsigned int const >
  0006f 83 c4 04   add         esp, 4
  00072 89 45 e8   mov         DWORD PTR __Ptr$3[ebp], eax

; 1160 :
; 1161 :                  if (_Inside(_Ptr))

  00075 8b 4d e8   mov         ecx, DWORD PTR __Ptr$3[ebp]
  00078 51                 push    ecx
  00079 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  0007c e8 00 00 00 00     call    ?_Inside@?$vector@IV?$allocator@_N@std@@@std@@IBE_NPBI@Z ; std::vector<unsigned int,std::allocator<bool> >::_Inside
  00081 0f b6 d0   movzx       edx, al
  00084 85 d2        test        edx, edx
  00086 74 52        je  SHORT $LN5@resize

; 1162 :                          {       // padding is inside vector, recompute _Ptr after reserve
; 1163 :                          const difference_type _Idx = _Ptr
; 1164 :                                  - _STD addressof(*this->_Myfirst());

  00088 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  0008b e8 00 00 00 00     call    ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myfirst
  00090 8b 00        mov         eax, DWORD PTR [eax]
  00092 50                 push    eax
  00093 e8 00 00 00 00     call    ??$addressof@I@std@@YAPAIAAI@Z ; std::addressof<unsigned int>
  00098 83 c4 04   add         esp, 4
  0009b 8b 4d e8   mov         ecx, DWORD PTR __Ptr$3[ebp]
  0009e 2b c8        sub         ecx, eax
  000a0 c1 f9 02   sar         ecx, 2
  000a3 89 4d e0   mov         DWORD PTR __Idx$2[ebp], ecx

; 1165 :                          _Reserve(_Newsize - size());

  000a6 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  000a9 e8 00 00 00 00     call    ?size@?$vector@IV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<bool> >::size
  000ae 8b 55 08   mov         edx, DWORD PTR __Newsize$[ebp]
  000b1 2b d0        sub         edx, eax
  000b3 52                 push    edx
  000b4 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  000b7 e8 00 00 00 00     call    ?_Reserve@?$vector@IV?$allocator@_N@std@@@std@@IAEXI@Z ; std::vector<unsigned int,std::allocator<bool> >::_Reserve

; 1166 :                          _Ptr = _STD addressof(*this->_Myfirst()) + _Idx;

  000bc 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  000bf e8 00 00 00 00     call    ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myfirst
  000c4 8b 00        mov         eax, DWORD PTR [eax]
  000c6 50                 push    eax
  000c7 e8 00 00 00 00     call    ??$addressof@I@std@@YAPAIAAI@Z ; std::addressof<unsigned int>
  000cc 83 c4 04   add         esp, 4
  000cf 8b 4d e0   mov         ecx, DWORD PTR __Idx$2[ebp]
  000d2 8d 14 88   lea         edx, DWORD PTR [eax+ecx*4]
  000d5 89 55 e8   mov         DWORD PTR __Ptr$3[ebp], edx

; 1167 :                          }
; 1168 :                  else

  000d8 eb 16        jmp         SHORT $LN6@resize
$LN5@resize:

; 1169 :                          _Reserve(_Newsize - size());

  000da 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  000dd e8 00 00 00 00     call    ?size@?$vector@IV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<bool> >::size
  000e2 8b 4d 08   mov         ecx, DWORD PTR __Newsize$[ebp]
  000e5 2b c8        sub         ecx, eax
  000e7 51                 push    ecx
  000e8 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  000eb e8 00 00 00 00     call    ?_Reserve@?$vector@IV?$allocator@_N@std@@@std@@IAEXI@Z ; std::vector<unsigned int,std::allocator<bool> >::_Reserve
$LN6@resize:

; 1170 :
; 1171 :                  _TRY_BEGIN

  000f0 c7 45 fc 00 00
        00 00          mov         DWORD PTR __$EHRec$[ebp+12], 0

; 1172 :                  _Ufill(this->_Mylast(), _Newsize - size(), _Ptr);

  000f7 8b 55 e8   mov         edx, DWORD PTR __Ptr$3[ebp]
  000fa 52                 push    edx
  000fb 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  000fe e8 00 00 00 00     call    ?size@?$vector@IV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<bool> >::size
  00103 8b 4d 08   mov         ecx, DWORD PTR __Newsize$[ebp]
  00106 2b c8        sub         ecx, eax
  00108 51                 push    ecx
  00109 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  0010c e8 00 00 00 00     call    ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Mylast
  00111 8b 10        mov         edx, DWORD PTR [eax]
  00113 52                 push    edx
  00114 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  00117 e8 00 00 00 00     call    ?_Ufill@?$vector@IV?$allocator@_N@std@@@std@@IAEPAIPAIIPBI@Z ; std::vector<unsigned int,std::allocator<bool> >::_Ufill
  0011c eb 17        jmp         SHORT $LN9@resize
__catch$?resize@?$vector@IV?$allocator@_N@std@@@std@@QAEXIABI@Z$0:

; 1173 :                  _CATCH_ALL
; 1174 :                  _Tidy();

  0011e 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  00121 e8 00 00 00 00     call    ?_Tidy@?$vector@IV?$allocator@_N@std@@@std@@IAEXXZ ; std::vector<unsigned int,std::allocator<bool> >::_Tidy

; 1175 :                  _RERAISE;

  00126 6a 00        push        0
  00128 6a 00        push        0
  0012a e8 00 00 00 00     call    __CxxThrowException@8

; 1176 :                  _CATCH_END

  0012f b8 00 00 00 00     mov     eax, $LN12@resize
  00134 c3                 ret     0
$LN9@resize:
  00135 c7 45 fc ff ff
        ff ff          mov         DWORD PTR __$EHRec$[ebp+12], -1
  0013c eb 07        jmp         SHORT __tryend$?resize@?$vector@IV?$allocator@_N@std@@@std@@QAEXIABI@Z$1
$LN12@resize:
  0013e c7 45 fc ff ff
        ff ff          mov         DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?resize@?$vector@IV?$allocator@_N@std@@@std@@QAEXIABI@Z$1:

; 1177 :                  this->_Mylast() += _Newsize - size();

  00145 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  00148 e8 00 00 00 00     call    ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Mylast
  0014d 89 45 e4   mov         DWORD PTR tv170[ebp], eax
  00150 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  00153 e8 00 00 00 00     call    ?size@?$vector@IV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<bool> >::size
  00158 8b 4d 08   mov         ecx, DWORD PTR __Newsize$[ebp]
  0015b 2b c8        sub         ecx, eax
  0015d 8b 55 e4   mov         edx, DWORD PTR tv170[ebp]
  00160 8b 02        mov         eax, DWORD PTR [edx]
  00162 8d 0c 88   lea         ecx, DWORD PTR [eax+ecx*4]
  00165 8b 55 e4   mov         edx, DWORD PTR tv170[ebp]
  00168 89 0a        mov         DWORD PTR [edx], ecx
$LN8@resize:

; 1178 :                  }
; 1179 :              }

  0016a 8b 4d f4   mov         ecx, DWORD PTR __$EHRec$[ebp+4]
  0016d 64 89 0d 00 00
        00 00          mov         DWORD PTR fs:0, ecx
  00174 59                 pop     ecx
  00175 5f                 pop     edi
  00176 5e                 pop     esi
  00177 5b                 pop     ebx
  00178 8b e5        mov         esp, ebp
  0017a 5d                 pop     ebp
  0017b c2 08 00   ret         8
_TEXT   ENDS
;       COMDAT text$x
text$x  SEGMENT
__ehhandler$?resize@?$vector@IV?$allocator@_N@std@@@std@@QAEXIABI@Z:
  00000 8b 54 24 08        mov   edx, DWORD PTR [esp+8]
  00004 8d 42 0c   lea         eax, DWORD PTR [edx+12]
  00007 8b 4a dc   mov         ecx, DWORD PTR [edx-36]
  0000a 33 c8        xor         ecx, eax
  0000c e8 00 00 00 00     call    @__security_check_cookie@4
  00011 b8 00 00 00 00     mov     eax, OFFSET __ehfuncinfo$?resize@?$vector@IV?$allocator@_N@std@@@std@@QAEXIABI@Z
  00016 e9 00 00 00 00     jmp     ___CxxFrameHandler3
text$x  ENDS
?resize@?$vector@IV?$allocator@_N@std@@@std@@QAEXIABI@Z ENDP ; std::vector<unsigned int,std::allocator<bool> >::resize
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Make_iter@?$vector@IV?$allocator@_N@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
___$ReturnUdt$ = 8                                  ; size = 4
__Where$ = 12                                     ; size = 4
?_Make_iter@?$vector@IV?$allocator@_N@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@@Z PROC ; std::vector<unsigned int,std::allocator<bool> >::_Make_iter, COMDAT
; _this$ = ecx

; 1080 :              {   // make iterator from const_iterator

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1081 :              return (iterator(_Where._Ptr, &this->_Get_data()));

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@I@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Get_data
  0000f 50                 push    eax
  00010 8b 45 0c   mov         eax, DWORD PTR __Where$[ebp]
  00013 50                 push    eax
  00014 8b 4d 08   mov         ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00017 e8 00 00 00 00     call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >
  0001c 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1082 :              }

  0001f 8b e5        mov         esp, ebp
  00021 5d                 pop     ebp
  00022 c2 08 00   ret         8
?_Make_iter@?$vector@IV?$allocator@_N@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@@Z ENDP ; std::vector<unsigned int,std::allocator<bool> >::_Make_iter
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?end@?$vector@IV?$allocator@_N@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
___$ReturnUdt$ = 8                                  ; size = 4
?end@?$vector@IV?$allocator@_N@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ PROC ; std::vector<unsigned int,std::allocator<bool> >::end, COMDAT
; _this$ = ecx

; 1070 :              {   // return iterator for end of mutable sequence

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1071 :              return (iterator(this->_Mylast(), &this->_Get_data()));

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@I@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Get_data
  0000f 50                 push    eax
  00010 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00013 e8 00 00 00 00     call    ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Mylast
  00018 8b 00        mov         eax, DWORD PTR [eax]
  0001a 50                 push    eax
  0001b 8b 4d 08   mov         ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001e e8 00 00 00 00     call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >
  00023 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1072 :              }

  00026 8b e5        mov         esp, ebp
  00028 5d                 pop     ebp
  00029 c2 04 00   ret         4
?end@?$vector@IV?$allocator@_N@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ ENDP ; std::vector<unsigned int,std::allocator<bool> >::end
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?begin@?$vector@IV?$allocator@_N@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
___$ReturnUdt$ = 8                                  ; size = 4
?begin@?$vector@IV?$allocator@_N@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ PROC ; std::vector<unsigned int,std::allocator<bool> >::begin, COMDAT
; _this$ = ecx

; 1060 :              {   // return iterator for beginning of mutable sequence

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1061 :              return (iterator(this->_Myfirst(), &this->_Get_data()));

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@I@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Get_data
  0000f 50                 push    eax
  00010 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00013 e8 00 00 00 00     call    ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myfirst
  00018 8b 00        mov         eax, DWORD PTR [eax]
  0001a 50                 push    eax
  0001b 8b 4d 08   mov         ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001e e8 00 00 00 00     call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >
  00023 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1062 :              }

  00026 8b e5        mov         esp, ebp
  00028 5d                 pop     ebp
  00029 c2 04 00   ret         4
?begin@?$vector@IV?$allocator@_N@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ ENDP ; std::vector<unsigned int,std::allocator<bool> >::begin
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Unused_capacity@?$vector@IV?$allocator@_N@std@@@std@@QBEIXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Unused_capacity@?$vector@IV?$allocator@_N@std@@@std@@QBEIXZ PROC ; std::vector<unsigned int,std::allocator<bool> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1050 :              {   // micro-optimization for capacity() - size()

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 56                 push    esi
  00005 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1051 :              return (this->_Myend() - this->_Mylast());

  00008 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000b e8 00 00 00 00     call    ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABQAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myend
  00010 8b f0        mov         esi, eax
  00012 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00015 e8 00 00 00 00     call    ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABQAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Mylast
  0001a 8b 0e        mov         ecx, DWORD PTR [esi]
  0001c 2b 08        sub         ecx, DWORD PTR [eax]
  0001e c1 f9 02   sar         ecx, 2
  00021 8b c1        mov         eax, ecx

; 1052 :              }

  00023 5e                 pop     esi
  00024 8b e5        mov         esp, ebp
  00026 5d                 pop     ebp
  00027 c3                 ret     0
?_Unused_capacity@?$vector@IV?$allocator@_N@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned int,std::allocator<bool> >::_Unused_capacity
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?capacity@?$vector@IV?$allocator@_N@std@@@std@@QBEIXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?capacity@?$vector@IV?$allocator@_N@std@@@std@@QBEIXZ PROC ; std::vector<unsigned int,std::allocator<bool> >::capacity, COMDAT
; _this$ = ecx

; 1045 :              {   // return current length of allocated storage

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 56                 push    esi
  00005 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1046 :              return (this->_Myend() - this->_Myfirst());

  00008 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000b e8 00 00 00 00     call    ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABQAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myend
  00010 8b f0        mov         esi, eax
  00012 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00015 e8 00 00 00 00     call    ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABQAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myfirst
  0001a 8b 0e        mov         ecx, DWORD PTR [esi]
  0001c 2b 08        sub         ecx, DWORD PTR [eax]
  0001e c1 f9 02   sar         ecx, 2
  00021 8b c1        mov         eax, ecx

; 1047 :              }

  00023 5e                 pop     esi
  00024 8b e5        mov         esp, ebp
  00026 5d                 pop     ebp
  00027 c3                 ret     0
?capacity@?$vector@IV?$allocator@_N@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned int,std::allocator<bool> >::capacity
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??1?$vector@IV?$allocator@_N@std@@@std@@QAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??1?$vector@IV?$allocator@_N@std@@@std@@QAE@XZ PROC     ; std::vector<unsigned int,std::allocator<bool> >::~vector<unsigned int,std::allocator<bool> >, COMDAT
; _this$ = ecx

; 978  :              {   // destroy the object

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 979  :              _Tidy();

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Tidy@?$vector@IV?$allocator@_N@std@@@std@@IAEXXZ ; std::vector<unsigned int,std::allocator<bool> >::_Tidy

; 980  :              }

  0000f 8b e5        mov         esp, ebp
  00011 5d                 pop     ebp
  00012 c3                 ret     0
??1?$vector@IV?$allocator@_N@std@@@std@@QAE@XZ ENDP     ; std::vector<unsigned int,std::allocator<bool> >::~vector<unsigned int,std::allocator<bool> >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Construct_n@?$vector@IV?$allocator@_N@std@@@std@@QAEXIPBI@Z
_TEXT   SEGMENT
_this$ = -20                                            ; size = 4
__$EHRec$ = -16                               ; size = 16
__Count$ = 8                                            ; size = 4
__Pval$ = 12                                            ; size = 4
?_Construct_n@?$vector@IV?$allocator@_N@std@@@std@@QAEXIPBI@Z PROC ; std::vector<unsigned int,std::allocator<bool> >::_Construct_n, COMDAT
; _this$ = ecx

; 830  :              {   // construct from _Count * *_Pval

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 6a ff        push        -1
  00005 68 00 00 00 00     push    __ehhandler$?_Construct_n@?$vector@IV?$allocator@_N@std@@@std@@QAEXIPBI@Z
  0000a 64 a1 00 00 00
        00           mov     eax, DWORD PTR fs:0
  00010 50                 push    eax
  00011 51                 push    ecx
  00012 51                 push    ecx
  00013 53                 push    ebx
  00014 56                 push    esi
  00015 57                 push    edi
  00016 a1 00 00 00 00     mov     eax, DWORD PTR ___security_cookie
  0001b 33 c5        xor         eax, ebp
  0001d 50                 push    eax
  0001e 8d 45 f4   lea         eax, DWORD PTR __$EHRec$[ebp+4]
  00021 64 a3 00 00 00
        00           mov     DWORD PTR fs:0, eax
  00027 89 65 f0   mov         DWORD PTR __$EHRec$[ebp], esp
  0002a 89 4d ec   mov         DWORD PTR _this$[ebp], ecx

; 831  :              if (_Buy(_Count))

  0002d 8b 45 08   mov         eax, DWORD PTR __Count$[ebp]
  00030 50                 push    eax
  00031 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  00034 e8 00 00 00 00     call    ?_Buy@?$vector@IV?$allocator@_N@std@@@std@@IAE_NI@Z ; std::vector<unsigned int,std::allocator<bool> >::_Buy
  00039 0f b6 c8   movzx       ecx, al
  0003c 85 c9        test        ecx, ecx
  0003e 74 57        je  SHORT $LN4@Construct_

; 832  :                  {       // nonzero, fill it
; 833  :                  _TRY_BEGIN

  00040 c7 45 fc 00 00
        00 00          mov         DWORD PTR __$EHRec$[ebp+12], 0

; 834  :                  this->_Mylast() = _Ufill(this->_Myfirst(), _Count, _Pval);

  00047 8b 55 0c   mov         edx, DWORD PTR __Pval$[ebp]
  0004a 52                 push    edx
  0004b 8b 45 08   mov         eax, DWORD PTR __Count$[ebp]
  0004e 50                 push    eax
  0004f 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  00052 e8 00 00 00 00     call    ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myfirst
  00057 8b 08        mov         ecx, DWORD PTR [eax]
  00059 51                 push    ecx
  0005a 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  0005d e8 00 00 00 00     call    ?_Ufill@?$vector@IV?$allocator@_N@std@@@std@@IAEPAIPAIIPBI@Z ; std::vector<unsigned int,std::allocator<bool> >::_Ufill
  00062 8b f0        mov         esi, eax
  00064 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  00067 e8 00 00 00 00     call    ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Mylast
  0006c 89 30        mov         DWORD PTR [eax], esi
  0006e eb 17        jmp         SHORT $LN5@Construct_
__catch$?_Construct_n@?$vector@IV?$allocator@_N@std@@@std@@QAEXIPBI@Z$0:

; 835  :                  _CATCH_ALL
; 836  :                  _Tidy();

  00070 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  00073 e8 00 00 00 00     call    ?_Tidy@?$vector@IV?$allocator@_N@std@@@std@@IAEXXZ ; std::vector<unsigned int,std::allocator<bool> >::_Tidy

; 837  :                  _RERAISE;

  00078 6a 00        push        0
  0007a 6a 00        push        0
  0007c e8 00 00 00 00     call    __CxxThrowException@8

; 838  :                  _CATCH_END

  00081 b8 00 00 00 00     mov     eax, $LN8@Construct_
  00086 c3                 ret     0
$LN5@Construct_:
  00087 c7 45 fc ff ff
        ff ff          mov         DWORD PTR __$EHRec$[ebp+12], -1
  0008e eb 07        jmp         SHORT $LN4@Construct_
$LN8@Construct_:
  00090 c7 45 fc ff ff
        ff ff          mov         DWORD PTR __$EHRec$[ebp+12], -1
$LN4@Construct_:

; 839  :                  }
; 840  :              }

  00097 8b 4d f4   mov         ecx, DWORD PTR __$EHRec$[ebp+4]
  0009a 64 89 0d 00 00
        00 00          mov         DWORD PTR fs:0, ecx
  000a1 59                 pop     ecx
  000a2 5f                 pop     edi
  000a3 5e                 pop     esi
  000a4 5b                 pop     ebx
  000a5 8b e5        mov         esp, ebp
  000a7 5d                 pop     ebp
  000a8 c2 08 00   ret         8
_TEXT   ENDS
;       COMDAT text$x
text$x  SEGMENT
__ehhandler$?_Construct_n@?$vector@IV?$allocator@_N@std@@@std@@QAEXIPBI@Z:
  00000 8b 54 24 08        mov   edx, DWORD PTR [esp+8]
  00004 8d 42 0c   lea         eax, DWORD PTR [edx+12]
  00007 8b 4a e8   mov         ecx, DWORD PTR [edx-24]
  0000a 33 c8        xor         ecx, eax
  0000c e8 00 00 00 00     call    @__security_check_cookie@4
  00011 b8 00 00 00 00     mov     eax, OFFSET __ehfuncinfo$?_Construct_n@?$vector@IV?$allocator@_N@std@@@std@@QAEXIPBI@Z
  00016 e9 00 00 00 00     jmp     ___CxxFrameHandler3
text$x  ENDS
?_Construct_n@?$vector@IV?$allocator@_N@std@@@std@@QAEXIPBI@Z ENDP ; std::vector<unsigned int,std::allocator<bool> >::_Construct_n
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??0?$vector@IV?$allocator@_N@std@@@std@@QAE@IABIABV?$allocator@_N@1@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Count$ = 8                                            ; size = 4
__Val$ = 12                                   ; size = 4
__Al$ = 16                                          ; size = 4
??0?$vector@IV?$allocator@_N@std@@@std@@QAE@IABIABV?$allocator@_N@1@@Z PROC ; std::vector<unsigned int,std::allocator<bool> >::vector<unsigned int,std::allocator<bool> >, COMDAT
; _this$ = ecx

; 742  :              {   // construct from _Count * _Val, allocator

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 741  :              : _Mybase(_Al)

  00007 8b 45 10   mov         eax, DWORD PTR __Al$[ebp]
  0000a 50                 push    eax
  0000b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000e e8 00 00 00 00     call    ??$?0ABV?$allocator@_N@std@@@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAE@ABV?$allocator@_N@1@@Z ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > ><std::allocator<bool> const &>

; 743  :              _Construct_n(_Count, _STD addressof(_Val));

  00013 8b 4d 0c   mov         ecx, DWORD PTR __Val$[ebp]
  00016 51                 push    ecx
  00017 e8 00 00 00 00     call    ??$addressof@$$CBI@std@@YAPBIABI@Z ; std::addressof<unsigned int const >
  0001c 83 c4 04   add         esp, 4
  0001f 50                 push    eax
  00020 8b 55 08   mov         edx, DWORD PTR __Count$[ebp]
  00023 52                 push    edx
  00024 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00027 e8 00 00 00 00     call    ?_Construct_n@?$vector@IV?$allocator@_N@std@@@std@@QAEXIPBI@Z ; std::vector<unsigned int,std::allocator<bool> >::_Construct_n

; 744  :              }

  0002c 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0002f 8b e5        mov         esp, ebp
  00031 5d                 pop     ebp
  00032 c2 0c 00   ret         12           ; 0000000cH
??0?$vector@IV?$allocator@_N@std@@@std@@QAE@IABIABV?$allocator@_N@1@@Z ENDP ; std::vector<unsigned int,std::allocator<bool> >::vector<unsigned int,std::allocator<bool> >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@I@std@@@2@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@I@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned int> >,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 318  :              {   // return const reference to second

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 319  :              return (_Myval2);

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]

; 320  :              }

  0000a 8b e5        mov         esp, ebp
  0000c 5d                 pop     ebp
  0000d c3                 ret     0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@I@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned int> >,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_second
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@I@std@@@2@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@I@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned int> >,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 313  :              {   // return reference to second

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 314  :              return (_Myval2);

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]

; 315  :              }

  0000a 8b e5        mov         esp, ebp
  0000c 5d                 pop     ebp
  0000d c3                 ret     0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@I@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned int> >,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_second
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned int> >,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 298  :              {   // return const reference to first

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 299  :              return (*this);

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]

; 300  :              }

  0000a 8b e5        mov         esp, ebp
  0000c 5d                 pop     ebp
  0000d c3                 ret     0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned int> >,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_first
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned int> >,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 293  :              {   // return reference to first

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 294  :              return (*this);

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]

; 295  :              }

  0000a 8b e5        mov         esp, ebp
  0000c 5d                 pop     ebp
  0000d c3                 ret     0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned int> >,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_first
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<unsigned int> >::_Vector_val<std::_Simple_types<unsigned int> >, COMDAT
; _this$ = ecx

; 478  :        _Vector_val()

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 479  :              {   // initialize values
; 480  :              _Myfirst = pointer();

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a c7 00 00 00 00
        00           mov     DWORD PTR [eax], 0

; 481  :              _Mylast = pointer();

  00010 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00013 c7 41 04 00 00
        00 00          mov         DWORD PTR [ecx+4], 0

; 482  :              _Myend = pointer();

  0001a 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  0001d c7 42 08 00 00
        00 00          mov         DWORD PTR [edx+8], 0

; 483  :              }

  00024 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00027 8b e5        mov         esp, ebp
  00029 5d                 pop     ebp
  0002a c3                 ret     0
??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<unsigned int> >::_Vector_val<std::_Simple_types<unsigned int> >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABQAIXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABQAIXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myend, COMDAT
; _this$ = ecx

; 670  :              {   // return const reference to _Myend

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 671  :              return (_Get_data()._Myend);

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@I@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Get_data
  0000f 83 c0 08   add         eax, 8

; 672  :              }

  00012 8b e5        mov         esp, ebp
  00014 5d                 pop     ebp
  00015 c3                 ret     0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABQAIXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myend
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myend, COMDAT
; _this$ = ecx

; 665  :              {   // return reference to _Myend

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 666  :              return (_Get_data()._Myend);

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@I@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Get_data
  0000f 83 c0 08   add         eax, 8

; 667  :              }

  00012 8b e5        mov         esp, ebp
  00014 5d                 pop     ebp
  00015 c3                 ret     0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myend
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABQAIXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABQAIXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Mylast, COMDAT
; _this$ = ecx

; 660  :              {   // return const reference to _Mylast

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 661  :              return (_Get_data()._Mylast);

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@I@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Get_data
  0000f 83 c0 04   add         eax, 4

; 662  :              }

  00012 8b e5        mov         esp, ebp
  00014 5d                 pop     ebp
  00015 c3                 ret     0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABQAIXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Mylast
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Mylast, COMDAT
; _this$ = ecx

; 655  :              {   // return reference to _Mylast

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 656  :              return (_Get_data()._Mylast);

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@I@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Get_data
  0000f 83 c0 04   add         eax, 4

; 657  :              }

  00012 8b e5        mov         esp, ebp
  00014 5d                 pop     ebp
  00015 c3                 ret     0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Mylast
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABQAIXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABQAIXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myfirst, COMDAT
; _this$ = ecx

; 650  :              {   // return const reference to _Myfirst

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 651  :              return (_Get_data()._Myfirst);

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@I@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Get_data

; 652  :              }

  0000f 8b e5        mov         esp, ebp
  00011 5d                 pop     ebp
  00012 c3                 ret     0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABQAIXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myfirst
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myfirst, COMDAT
; _this$ = ecx

; 645  :              {   // return reference to _Myfirst

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 646  :              return (_Get_data()._Myfirst);

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@I@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Get_data

; 647  :              }

  0000f 8b e5        mov         esp, ebp
  00011 5d                 pop     ebp
  00012 c3                 ret     0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myfirst
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@I@std@@@2@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@I@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Get_data, COMDAT
; _this$ = ecx

; 640  :              {   // return const reference to _Vector_val

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 641  :              return (_Mypair._Get_second());

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@I@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned int> >,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_second

; 642  :              }

  0000f 8b e5        mov         esp, ebp
  00011 5d                 pop     ebp
  00012 c3                 ret     0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@I@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Get_data
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@I@std@@@2@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@I@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Get_data, COMDAT
; _this$ = ecx

; 635  :              {   // return reference to _Vector_val

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 636  :              return (_Mypair._Get_second());

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@I@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned int> >,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_second

; 637  :              }

  0000f 8b e5        mov         esp, ebp
  00011 5d                 pop     ebp
  00012 c3                 ret     0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@I@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Get_data
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Getal, COMDAT
; _this$ = ecx

; 630  :              {   // return const reference to allocator

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 631  :              return (_Mypair._Get_first());

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned int> >,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_first

; 632  :              }

  0000f 8b e5        mov         esp, ebp
  00011 5d                 pop     ebp
  00012 c3                 ret     0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Getal
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Getal, COMDAT
; _this$ = ecx

; 625  :              {   // return reference to allocator

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 626  :              return (_Mypair._Get_first());

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned int> >,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_first

; 627  :              }

  0000f 8b e5        mov         esp, ebp
  00011 5d                 pop     ebp
  00012 c3                 ret     0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Getal
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;       COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEXXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 615  :              {   // orphan all iterators

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 616  :              _Get_data()._Orphan_all();

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@I@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Get_data
  0000f 8b c8        mov         ecx, eax
  00011 e8 00 00 00 00     call    ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 617  :              }

  00016 8b e5        mov         esp, ebp
  00018 5d                 pop     ebp
  00019 c3                 ret     0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Orphan_all
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;       COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QBEIU_Nil@2@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
___formal$ = 8                                      ; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned int> >::max_size, COMDAT
; _this$ = ecx

; 905  :              {   // get maximum size

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 906  :              return (_Mytraits::max_size(*this));

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a 50                 push    eax
  0000b e8 00 00 00 00     call    ?max_size@?$allocator_traits@V?$allocator@I@std@@@std@@SAIABV?$allocator@I@2@@Z ; std::allocator_traits<std::allocator<unsigned int> >::max_size
  00010 83 c4 04   add         esp, 4

; 907  :              }

  00013 8b e5        mov         esp, ebp
  00015 5d                 pop     ebp
  00016 c2 04 00   ret         4
?max_size@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned int> >::max_size
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;       COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAII@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Ptr$ = 8                                          ; size = 4
__Count$ = 12                                     ; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAII@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned int> >::deallocate, COMDAT
; _this$ = ecx

; 884  :              {   // deallocate object at _Ptr, ignore size

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 885  :              _Mybase::deallocate(_Ptr, _Count);

  00007 8b 45 0c   mov         eax, DWORD PTR __Count$[ebp]
  0000a 50                 push    eax
  0000b 8b 4d 08   mov         ecx, DWORD PTR __Ptr$[ebp]
  0000e 51                 push    ecx
  0000f 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00012 e8 00 00 00 00     call    ?deallocate@?$allocator@I@std@@QAEXPAII@Z ; std::allocator<unsigned int>::deallocate

; 886  :              }

  00017 8b e5        mov         esp, ebp
  00019 5d                 pop     ebp
  0001a c2 08 00   ret         8
?deallocate@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAII@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned int> >::deallocate
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;       COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEPAII@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Count$ = 8                                            ; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEPAII@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned int> >::allocate, COMDAT
; _this$ = ecx

; 873  :              {   // allocate array of _Count elements

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 874  :              return (_Mybase::allocate(_Count));

  00007 8b 45 08   mov         eax, DWORD PTR __Count$[ebp]
  0000a 50                 push    eax
  0000b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000e e8 00 00 00 00     call    ?allocate@?$allocator@I@std@@QAEPAII@Z ; std::allocator<unsigned int>::allocate

; 875  :              }

  00013 8b e5        mov         esp, ebp
  00015 5d                 pop     ebp
  00016 c2 04 00   ret         4
?allocate@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEPAII@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned int> >::allocate
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;       COMDAT ?max_size@?$allocator_traits@V?$allocator@I@std@@@std@@SAIABV?$allocator@I@2@@Z
_TEXT   SEGMENT
__Al$ = 8                                         ; size = 4
?max_size@?$allocator_traits@V?$allocator@I@std@@@std@@SAIABV?$allocator@I@2@@Z PROC ; std::allocator_traits<std::allocator<unsigned int> >::max_size, COMDAT

; 766  :              {   // get maximum size

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 767  :              return (_Al.max_size());

  00003 8b 4d 08   mov         ecx, DWORD PTR __Al$[ebp]
  00006 e8 00 00 00 00     call    ?max_size@?$allocator@I@std@@QBEIXZ ; std::allocator<unsigned int>::max_size

; 768  :              }

  0000b 5d                 pop     ebp
  0000c c3                 ret     0
?max_size@?$allocator_traits@V?$allocator@I@std@@@std@@SAIABV?$allocator@I@2@@Z ENDP ; std::allocator_traits<std::allocator<unsigned int> >::max_size
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;       COMDAT ?max_size@?$allocator@I@std@@QBEIXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?max_size@?$allocator@I@std@@QBEIXZ PROC                ; std::allocator<unsigned int>::max_size, COMDAT
; _this$ = ecx

; 648  :              {   // estimate maximum array size

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 649  :              return ((size_t)(-1) / sizeof (_Ty));

  00007 b8 ff ff ff 3f     mov     eax, 1073741823                ; 3fffffffH

; 650  :              }

  0000c 8b e5        mov         esp, ebp
  0000e 5d                 pop     ebp
  0000f c3                 ret     0
?max_size@?$allocator@I@std@@QBEIXZ ENDP                ; std::allocator<unsigned int>::max_size
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;       COMDAT ?allocate@?$allocator@I@std@@QAEPAII@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Count$ = 8                                            ; size = 4
?allocate@?$allocator@I@std@@QAEPAII@Z PROC       ; std::allocator<unsigned int>::allocate, COMDAT
; _this$ = ecx

; 624  :              {   // allocate array of _Count elements

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 625  :              return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

  00007 6a 01        push        1
  00009 6a 04        push        4
  0000b 8b 45 08   mov         eax, DWORD PTR __Count$[ebp]
  0000e 50                 push    eax
  0000f e8 00 00 00 00     call    ?_Allocate@std@@YAPAXII_N@Z ; std::_Allocate
  00014 83 c4 0c   add         esp, 12                        ; 0000000cH

; 626  :              }

  00017 8b e5        mov         esp, ebp
  00019 5d                 pop     ebp
  0001a c2 04 00   ret         4
?allocate@?$allocator@I@std@@QAEPAII@Z ENDP       ; std::allocator<unsigned int>::allocate
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;       COMDAT ?deallocate@?$allocator@I@std@@QAEXPAII@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Ptr$ = 8                                          ; size = 4
__Count$ = 12                                     ; size = 4
?deallocate@?$allocator@I@std@@QAEXPAII@Z PROC      ; std::allocator<unsigned int>::deallocate, COMDAT
; _this$ = ecx

; 619  :              {   // deallocate object at _Ptr

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 620  :              _Deallocate(_Ptr, _Count, sizeof (_Ty));

  00007 6a 04        push        4
  00009 8b 45 0c   mov         eax, DWORD PTR __Count$[ebp]
  0000c 50                 push    eax
  0000d 8b 4d 08   mov         ecx, DWORD PTR __Ptr$[ebp]
  00010 51                 push    ecx
  00011 e8 00 00 00 00     call    ?_Deallocate@std@@YAXPAXII@Z ; std::_Deallocate
  00016 83 c4 0c   add         esp, 12                        ; 0000000cH

; 621  :              }

  00019 8b e5        mov         esp, ebp
  0001b 5d                 pop     ebp
  0001c c2 08 00   ret         8
?deallocate@?$allocator@I@std@@QAEXPAII@Z ENDP      ; std::allocator<unsigned int>::deallocate
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;       COMDAT ??0?$allocator@_N@std@@QAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??0?$allocator@_N@std@@QAE@XZ PROC                  ; std::allocator<bool>::allocator<bool>, COMDAT
; _this$ = ecx

; 599  :        allocator() _THROW0()

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 600  :              {   // construct default allocator (do nothing)
; 601  :              }

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a 8b e5        mov         esp, ebp
  0000c 5d                 pop     ebp
  0000d c3                 ret     0
??0?$allocator@_N@std@@QAE@XZ ENDP                  ; std::allocator<bool>::allocator<bool>
_TEXT   ENDS
; Function compile flags: /Odtp
;       COMDAT ??_G_Node_rep@std@@UAEPAXI@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
___flags$ = 8                                     ; size = 4
??_G_Node_rep@std@@UAEPAXI@Z PROC                 ; std::_Node_rep::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ??1_Node_rep@std@@UAE@XZ
  0000f 8b 45 08   mov         eax, DWORD PTR ___flags$[ebp]
  00012 83 e0 01   and         eax, 1
  00015 74 0e        je  SHORT $LN2@scalar
  00017 6a 28        push        40             ; 00000028H
  00019 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001c 51                 push    ecx
  0001d e8 00 00 00 00     call    ??3@YAXPAXI@Z                ; operator delete
  00022 83 c4 08   add         esp, 8
$LN2@scalar:
  00025 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00028 8b e5        mov         esp, ebp
  0002a 5d                 pop     ebp
  0002b c2 04 00   ret         4
??_G_Node_rep@std@@UAEPAXI@Z ENDP                 ; std::_Node_rep::`scalar deleting destructor'
_TEXT   ENDS
; Function compile flags: /Odtp
;       COMDAT ??1_Node_rep@std@@UAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??1_Node_rep@std@@UAE@XZ PROC                     ; std::_Node_rep::~_Node_rep, COMDAT
; _this$ = ecx
  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ??1_Node_base@std@@UAE@XZ ; std::_Node_base::~_Node_base
  0000f 8b e5        mov         esp, ebp
  00011 5d                 pop     ebp
  00012 c3                 ret     0
??1_Node_rep@std@@UAE@XZ ENDP                     ; std::_Node_rep::~_Node_rep
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ??0_Node_rep@std@@QAE@_NHHPAV_Node_end_rep@1@I@Z
_TEXT   SEGMENT
tv72 = -8                                         ; size = 4
_this$ = -4                                   ; size = 4
__Greedy$ = 8                                     ; size = 1
__Mn$ = 12                                          ; size = 4
__Mx$ = 16                                          ; size = 4
__End$ = 20                                   ; size = 4
__Number$ = 24                                      ; size = 4
??0_Node_rep@std@@QAE@_NHHPAV_Node_end_rep@1@I@Z PROC   ; std::_Node_rep::_Node_rep, COMDAT
; _this$ = ecx

; 1967 :              {   // construct

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1961 :              : _Node_base(_N_rep, _Greedy ? _Fl_greedy : _Fl_none),

  00009 0f b6 45 08        movzx         eax, BYTE PTR __Greedy$[ebp]
  0000d 85 c0        test        eax, eax
  0000f 74 09        je  SHORT $LN3@Node_rep
  00011 c7 45 f8 02 00
        00 00          mov         DWORD PTR tv72[ebp], 2
  00018 eb 07        jmp         SHORT $LN4@Node_rep
$LN3@Node_rep:
  0001a c7 45 f8 00 00
        00 00          mov         DWORD PTR tv72[ebp], 0
$LN4@Node_rep:
  00021 8b 4d f8   mov         ecx, DWORD PTR tv72[ebp]
  00024 51                 push    ecx
  00025 6a 12        push        18             ; 00000012H
  00027 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0002a e8 00 00 00 00     call    ??0_Node_base@std@@QAE@W4_Node_type@1@W4_Node_flags@1@@Z ; std::_Node_base::_Node_base

; 1967 :              {   // construct

  0002f 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  00032 c7 02 00 00 00
        00           mov     DWORD PTR [edx], OFFSET ??_7_Node_rep@std@@6B@

; 1962 :                  _Min(_Mn),

  00038 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0003b 8b 4d 0c   mov         ecx, DWORD PTR __Mn$[ebp]
  0003e 89 48 14   mov         DWORD PTR [eax+20], ecx

; 1963 :                  _Max(_Mx),

  00041 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  00044 8b 45 10   mov         eax, DWORD PTR __Mx$[ebp]
  00047 89 42 18   mov         DWORD PTR [edx+24], eax

; 1964 :                  _End_rep(_End),

  0004a 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0004d 8b 55 14   mov         edx, DWORD PTR __End$[ebp]
  00050 89 51 1c   mov         DWORD PTR [ecx+28], edx

; 1965 :                  _Loop_number(_Number),

  00053 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00056 8b 4d 18   mov         ecx, DWORD PTR __Number$[ebp]
  00059 89 48 20   mov         DWORD PTR [eax+32], ecx

; 1966 :                  _Simple_loop(-1)

  0005c 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  0005f c7 42 24 ff ff
        ff ff          mov         DWORD PTR [edx+36], -1

; 1968 :              }

  00066 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00069 8b e5        mov         esp, ebp
  0006b 5d                 pop     ebp
  0006c c2 14 00   ret         20           ; 00000014H
??0_Node_rep@std@@QAE@_NHHPAV_Node_end_rep@1@I@Z ENDP   ; std::_Node_rep::_Node_rep
_TEXT   ENDS
; Function compile flags: /Odtp
;       COMDAT ??_G_Node_end_rep@std@@UAEPAXI@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
___flags$ = 8                                     ; size = 4
??_G_Node_end_rep@std@@UAEPAXI@Z PROC             ; std::_Node_end_rep::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ??1_Node_end_rep@std@@UAE@XZ
  0000f 8b 45 08   mov         eax, DWORD PTR ___flags$[ebp]
  00012 83 e0 01   and         eax, 1
  00015 74 0e        je  SHORT $LN2@scalar
  00017 6a 18        push        24             ; 00000018H
  00019 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001c 51                 push    ecx
  0001d e8 00 00 00 00     call    ??3@YAXPAXI@Z                ; operator delete
  00022 83 c4 08   add         esp, 8
$LN2@scalar:
  00025 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00028 8b e5        mov         esp, ebp
  0002a 5d                 pop     ebp
  0002b c2 04 00   ret         4
??_G_Node_end_rep@std@@UAEPAXI@Z ENDP             ; std::_Node_end_rep::`scalar deleting destructor'
_TEXT   ENDS
; Function compile flags: /Odtp
;       COMDAT ??1_Node_end_rep@std@@UAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??1_Node_end_rep@std@@UAE@XZ PROC                 ; std::_Node_end_rep::~_Node_end_rep, COMDAT
; _this$ = ecx
  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ??1_Node_base@std@@UAE@XZ ; std::_Node_base::~_Node_base
  0000f 8b e5        mov         esp, ebp
  00011 5d                 pop     ebp
  00012 c3                 ret     0
??1_Node_end_rep@std@@UAE@XZ ENDP                 ; std::_Node_end_rep::~_Node_end_rep
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ??0_Node_end_rep@std@@QAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??0_Node_end_rep@std@@QAE@XZ PROC                 ; std::_Node_end_rep::_Node_end_rep, COMDAT
; _this$ = ecx

; 1938 :              {   // construct

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1936 :              : _Node_base(_N_end_rep),

  00007 6a 00        push        0
  00009 6a 13        push        19             ; 00000013H
  0000b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000e e8 00 00 00 00     call    ??0_Node_base@std@@QAE@W4_Node_type@1@W4_Node_flags@1@@Z ; std::_Node_base::_Node_base

; 1938 :              {   // construct

  00013 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00016 c7 00 00 00 00
        00           mov     DWORD PTR [eax], OFFSET ??_7_Node_end_rep@std@@6B@

; 1937 :                  _Begin_rep(0)

  0001c 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001f c7 41 14 00 00
        00 00          mov         DWORD PTR [ecx+20], 0

; 1939 :              }

  00026 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00029 8b e5        mov         esp, ebp
  0002b 5d                 pop     ebp
  0002c c3                 ret     0
??0_Node_end_rep@std@@QAE@XZ ENDP                 ; std::_Node_end_rep::_Node_end_rep
_TEXT   ENDS
; Function compile flags: /Odtp
;       COMDAT ??_G_Node_if@std@@UAEPAXI@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
___flags$ = 8                                     ; size = 4
??_G_Node_if@std@@UAEPAXI@Z PROC                        ; std::_Node_if::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ??1_Node_if@std@@UAE@XZ      ; std::_Node_if::~_Node_if
  0000f 8b 45 08   mov         eax, DWORD PTR ___flags$[ebp]
  00012 83 e0 01   and         eax, 1
  00015 74 0e        je  SHORT $LN2@scalar
  00017 6a 1c        push        28             ; 0000001cH
  00019 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001c 51                 push    ecx
  0001d e8 00 00 00 00     call    ??3@YAXPAXI@Z                ; operator delete
  00022 83 c4 08   add         esp, 8
$LN2@scalar:
  00025 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00028 8b e5        mov         esp, ebp
  0002a 5d                 pop     ebp
  0002b c2 04 00   ret         4
??_G_Node_if@std@@UAEPAXI@Z ENDP                        ; std::_Node_if::`scalar deleting destructor'
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ??1_Node_if@std@@UAE@XZ
_TEXT   SEGMENT
__Tmp$1 = -12                                     ; size = 4
_this$ = -8                                   ; size = 4
__Cur$ = -4                                   ; size = 4
??1_Node_if@std@@UAE@XZ PROC                            ; std::_Node_if::~_Node_if, COMDAT
; _this$ = ecx

; 1913 :              {   // destroy branches of if node

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 0c   sub         esp, 12                        ; 0000000cH
  00006 89 4d f8   mov         DWORD PTR _this$[ebp], ecx
  00009 8b 45 f8   mov         eax, DWORD PTR _this$[ebp]
  0000c c7 00 00 00 00
        00           mov     DWORD PTR [eax], OFFSET ??_7_Node_if@std@@6B@

; 1914 :              _Node_if *_Cur = _Child;

  00012 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00015 8b 51 18   mov         edx, DWORD PTR [ecx+24]
  00018 89 55 fc   mov         DWORD PTR __Cur$[ebp], edx
$LN2@Node_if:

; 1915 :              while (_Cur)

  0001b 83 7d fc 00        cmp   DWORD PTR __Cur$[ebp], 0
  0001f 74 2e        je  SHORT $LN1@Node_if

; 1916 :                  {       // destroy branch
; 1917 :                  _Node_if *_Tmp = _Cur;

  00021 8b 45 fc   mov         eax, DWORD PTR __Cur$[ebp]
  00024 89 45 f4   mov         DWORD PTR __Tmp$1[ebp], eax

; 1918 :                  _Cur = _Cur->_Child;

  00027 8b 4d fc   mov         ecx, DWORD PTR __Cur$[ebp]
  0002a 8b 51 18   mov         edx, DWORD PTR [ecx+24]
  0002d 89 55 fc   mov         DWORD PTR __Cur$[ebp], edx

; 1919 :                  _Tmp->_Child = 0;

  00030 8b 45 f4   mov         eax, DWORD PTR __Tmp$1[ebp]
  00033 c7 40 18 00 00
        00 00          mov         DWORD PTR [eax+24], 0

; 1920 :                  _Destroy_node(_Tmp, _Endif);

  0003a 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  0003d 8b 51 14   mov         edx, DWORD PTR [ecx+20]
  00040 52                 push    edx
  00041 8b 45 f4   mov         eax, DWORD PTR __Tmp$1[ebp]
  00044 50                 push    eax
  00045 e8 00 00 00 00     call    ?_Destroy_node@std@@YAXPAV_Node_base@1@0@Z ; std::_Destroy_node
  0004a 83 c4 08   add         esp, 8

; 1921 :                  }

  0004d eb cc        jmp         SHORT $LN2@Node_if
$LN1@Node_if:

; 1922 :              }

  0004f 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00052 e8 00 00 00 00     call    ??1_Node_base@std@@UAE@XZ ; std::_Node_base::~_Node_base
  00057 8b e5        mov         esp, ebp
  00059 5d                 pop     ebp
  0005a c3                 ret     0
??1_Node_if@std@@UAE@XZ ENDP                            ; std::_Node_if::~_Node_if
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ??0_Node_if@std@@QAE@PAV_Node_base@1@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__End$ = 8                                          ; size = 4
??0_Node_if@std@@QAE@PAV_Node_base@1@@Z PROC            ; std::_Node_if::_Node_if, COMDAT
; _this$ = ecx

; 1909 :              {   // construct

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1908 :              : _Node_base(_N_if, _Fl_none), _Endif((_Node_endif *)_End), _Child(0)

  00007 6a 00        push        0
  00009 6a 10        push        16             ; 00000010H
  0000b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000e e8 00 00 00 00     call    ??0_Node_base@std@@QAE@W4_Node_type@1@W4_Node_flags@1@@Z ; std::_Node_base::_Node_base

; 1909 :              {   // construct

  00013 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00016 c7 00 00 00 00
        00           mov     DWORD PTR [eax], OFFSET ??_7_Node_if@std@@6B@

; 1908 :              : _Node_base(_N_if, _Fl_none), _Endif((_Node_endif *)_End), _Child(0)

  0001c 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001f 8b 55 08   mov         edx, DWORD PTR __End$[ebp]
  00022 89 51 14   mov         DWORD PTR [ecx+20], edx
  00025 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00028 c7 40 18 00 00
        00 00          mov         DWORD PTR [eax+24], 0

; 1910 :              }

  0002f 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00032 8b e5        mov         esp, ebp
  00034 5d                 pop     ebp
  00035 c2 04 00   ret         4
??0_Node_if@std@@QAE@PAV_Node_base@1@@Z ENDP            ; std::_Node_if::_Node_if
_TEXT   ENDS
; Function compile flags: /Odtp
;       COMDAT ??_G_Node_endif@std@@UAEPAXI@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
___flags$ = 8                                     ; size = 4
??_G_Node_endif@std@@UAEPAXI@Z PROC           ; std::_Node_endif::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ??1_Node_endif@std@@UAE@XZ
  0000f 8b 45 08   mov         eax, DWORD PTR ___flags$[ebp]
  00012 83 e0 01   and         eax, 1
  00015 74 0e        je  SHORT $LN2@scalar
  00017 6a 14        push        20             ; 00000014H
  00019 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001c 51                 push    ecx
  0001d e8 00 00 00 00     call    ??3@YAXPAXI@Z                ; operator delete
  00022 83 c4 08   add         esp, 8
$LN2@scalar:
  00025 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00028 8b e5        mov         esp, ebp
  0002a 5d                 pop     ebp
  0002b c2 04 00   ret         4
??_G_Node_endif@std@@UAEPAXI@Z ENDP           ; std::_Node_endif::`scalar deleting destructor'
_TEXT   ENDS
; Function compile flags: /Odtp
;       COMDAT ??1_Node_endif@std@@UAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??1_Node_endif@std@@UAE@XZ PROC               ; std::_Node_endif::~_Node_endif, COMDAT
; _this$ = ecx
  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ??1_Node_base@std@@UAE@XZ ; std::_Node_base::~_Node_base
  0000f 8b e5        mov         esp, ebp
  00011 5d                 pop     ebp
  00012 c3                 ret     0
??1_Node_endif@std@@UAE@XZ ENDP               ; std::_Node_endif::~_Node_endif
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ??0_Node_endif@std@@QAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??0_Node_endif@std@@QAE@XZ PROC               ; std::_Node_endif::_Node_endif, COMDAT
; _this$ = ecx

; 1898 :              {   // construct

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1897 :              : _Node_base(_N_endif, _Fl_none)

  00007 6a 00        push        0
  00009 6a 11        push        17             ; 00000011H
  0000b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000e e8 00 00 00 00     call    ??0_Node_base@std@@QAE@W4_Node_type@1@W4_Node_flags@1@@Z ; std::_Node_base::_Node_base

; 1898 :              {   // construct

  00013 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00016 c7 00 00 00 00
        00           mov     DWORD PTR [eax], OFFSET ??_7_Node_endif@std@@6B@

; 1899 :              }

  0001c 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0001f 8b e5        mov         esp, ebp
  00021 5d                 pop     ebp
  00022 c3                 ret     0
??0_Node_endif@std@@QAE@XZ ENDP               ; std::_Node_endif::_Node_endif
_TEXT   ENDS
; Function compile flags: /Odtp
;       COMDAT ??_G_Node_back@std@@UAEPAXI@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
___flags$ = 8                                     ; size = 4
??_G_Node_back@std@@UAEPAXI@Z PROC                  ; std::_Node_back::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ??1_Node_back@std@@UAE@XZ
  0000f 8b 45 08   mov         eax, DWORD PTR ___flags$[ebp]
  00012 83 e0 01   and         eax, 1
  00015 74 0e        je  SHORT $LN2@scalar
  00017 6a 18        push        24             ; 00000018H
  00019 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001c 51                 push    ecx
  0001d e8 00 00 00 00     call    ??3@YAXPAXI@Z                ; operator delete
  00022 83 c4 08   add         esp, 8
$LN2@scalar:
  00025 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00028 8b e5        mov         esp, ebp
  0002a 5d                 pop     ebp
  0002b c2 04 00   ret         4
??_G_Node_back@std@@UAEPAXI@Z ENDP                  ; std::_Node_back::`scalar deleting destructor'
_TEXT   ENDS
; Function compile flags: /Odtp
;       COMDAT ??1_Node_back@std@@UAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??1_Node_back@std@@UAE@XZ PROC                      ; std::_Node_back::~_Node_back, COMDAT
; _this$ = ecx
  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ??1_Node_base@std@@UAE@XZ ; std::_Node_base::~_Node_base
  0000f 8b e5        mov         esp, ebp
  00011 5d                 pop     ebp
  00012 c3                 ret     0
??1_Node_back@std@@UAE@XZ ENDP                      ; std::_Node_back::~_Node_back
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ??0_Node_back@std@@QAE@I@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Ix$ = 8                                         ; size = 4
??0_Node_back@std@@QAE@I@Z PROC               ; std::_Node_back::_Node_back, COMDAT
; _this$ = ecx

; 1831 :              {   // construct

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1830 :              : _Node_base(_N_back, _Fl_none), _Idx(_Ix)

  00007 6a 00        push        0
  00009 6a 0f        push        15             ; 0000000fH
  0000b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000e e8 00 00 00 00     call    ??0_Node_base@std@@QAE@W4_Node_type@1@W4_Node_flags@1@@Z ; std::_Node_base::_Node_base

; 1831 :              {   // construct

  00013 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00016 c7 00 00 00 00
        00           mov     DWORD PTR [eax], OFFSET ??_7_Node_back@std@@6B@

; 1830 :              : _Node_base(_N_back, _Fl_none), _Idx(_Ix)

  0001c 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001f 8b 55 08   mov         edx, DWORD PTR __Ix$[ebp]
  00022 89 51 14   mov         DWORD PTR [ecx+20], edx

; 1832 :              }

  00025 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00028 8b e5        mov         esp, ebp
  0002a 5d                 pop     ebp
  0002b c2 04 00   ret         4
??0_Node_back@std@@QAE@I@Z ENDP               ; std::_Node_back::_Node_back
_TEXT   ENDS
; Function compile flags: /Odtp
;       COMDAT ??_G_Node_capture@std@@UAEPAXI@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
___flags$ = 8                                     ; size = 4
??_G_Node_capture@std@@UAEPAXI@Z PROC             ; std::_Node_capture::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ??1_Node_capture@std@@UAE@XZ
  0000f 8b 45 08   mov         eax, DWORD PTR ___flags$[ebp]
  00012 83 e0 01   and         eax, 1
  00015 74 0e        je  SHORT $LN2@scalar
  00017 6a 18        push        24             ; 00000018H
  00019 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001c 51                 push    ecx
  0001d e8 00 00 00 00     call    ??3@YAXPAXI@Z                ; operator delete
  00022 83 c4 08   add         esp, 8
$LN2@scalar:
  00025 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00028 8b e5        mov         esp, ebp
  0002a 5d                 pop     ebp
  0002b c2 04 00   ret         4
??_G_Node_capture@std@@UAEPAXI@Z ENDP             ; std::_Node_capture::`scalar deleting destructor'
_TEXT   ENDS
; Function compile flags: /Odtp
;       COMDAT ??1_Node_capture@std@@UAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??1_Node_capture@std@@UAE@XZ PROC                 ; std::_Node_capture::~_Node_capture, COMDAT
; _this$ = ecx
  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ??1_Node_base@std@@UAE@XZ ; std::_Node_base::~_Node_base
  0000f 8b e5        mov         esp, ebp
  00011 5d                 pop     ebp
  00012 c3                 ret     0
??1_Node_capture@std@@UAE@XZ ENDP                 ; std::_Node_capture::~_Node_capture
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ??0_Node_capture@std@@QAE@I@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Ix$ = 8                                         ; size = 4
??0_Node_capture@std@@QAE@I@Z PROC                  ; std::_Node_capture::_Node_capture, COMDAT
; _this$ = ecx

; 1818 :              {   // construct

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1817 :              : _Node_base(_N_capture, _Fl_none), _Idx(_Ix)

  00007 6a 00        push        0
  00009 6a 0d        push        13             ; 0000000dH
  0000b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000e e8 00 00 00 00     call    ??0_Node_base@std@@QAE@W4_Node_type@1@W4_Node_flags@1@@Z ; std::_Node_base::_Node_base

; 1818 :              {   // construct

  00013 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00016 c7 00 00 00 00
        00           mov     DWORD PTR [eax], OFFSET ??_7_Node_capture@std@@6B@

; 1817 :              : _Node_base(_N_capture, _Fl_none), _Idx(_Ix)

  0001c 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001f 8b 55 08   mov         edx, DWORD PTR __Ix$[ebp]
  00022 89 51 14   mov         DWORD PTR [ecx+20], edx

; 1819 :              }

  00025 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00028 8b e5        mov         esp, ebp
  0002a 5d                 pop     ebp
  0002b c2 04 00   ret         4
??0_Node_capture@std@@QAE@I@Z ENDP                  ; std::_Node_capture::_Node_capture
_TEXT   ENDS
; Function compile flags: /Odtp
;       COMDAT ??_G_Node_assert@std@@UAEPAXI@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
___flags$ = 8                                     ; size = 4
??_G_Node_assert@std@@UAEPAXI@Z PROC                    ; std::_Node_assert::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ??1_Node_assert@std@@UAE@XZ ; std::_Node_assert::~_Node_assert
  0000f 8b 45 08   mov         eax, DWORD PTR ___flags$[ebp]
  00012 83 e0 01   and         eax, 1
  00015 74 0e        je  SHORT $LN2@scalar
  00017 6a 18        push        24             ; 00000018H
  00019 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001c 51                 push    ecx
  0001d e8 00 00 00 00     call    ??3@YAXPAXI@Z                ; operator delete
  00022 83 c4 08   add         esp, 8
$LN2@scalar:
  00025 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00028 8b e5        mov         esp, ebp
  0002a 5d                 pop     ebp
  0002b c2 04 00   ret         4
??_G_Node_assert@std@@UAEPAXI@Z ENDP                    ; std::_Node_assert::`scalar deleting destructor'
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ??1_Node_assert@std@@UAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??1_Node_assert@std@@UAE@XZ PROC                        ; std::_Node_assert::~_Node_assert, COMDAT
; _this$ = ecx

; 1804 :              {   // destroy branch

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a c7 00 00 00 00
        00           mov     DWORD PTR [eax], OFFSET ??_7_Node_assert@std@@6B@

; 1805 :              _Destroy_node(_Child);

  00010 6a 00        push        0
  00012 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00015 8b 51 14   mov         edx, DWORD PTR [ecx+20]
  00018 52                 push    edx
  00019 e8 00 00 00 00     call    ?_Destroy_node@std@@YAXPAV_Node_base@1@0@Z ; std::_Destroy_node
  0001e 83 c4 08   add         esp, 8

; 1806 :              }

  00021 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00024 e8 00 00 00 00     call    ??1_Node_base@std@@UAE@XZ ; std::_Node_base::~_Node_base
  00029 8b e5        mov         esp, ebp
  0002b 5d                 pop     ebp
  0002c c3                 ret     0
??1_Node_assert@std@@UAE@XZ ENDP                        ; std::_Node_assert::~_Node_assert
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ??0_Node_assert@std@@QAE@W4_Node_type@1@W4_Node_flags@1@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Ty$ = 8                                         ; size = 4
__Fl$ = 12                                          ; size = 4
??0_Node_assert@std@@QAE@W4_Node_type@1@W4_Node_flags@1@@Z PROC ; std::_Node_assert::_Node_assert, COMDAT
; _this$ = ecx

; 1800 :              {   // construct

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1799 :              : _Node_base(_Ty, _Fl), _Child(0)

  00007 8b 45 0c   mov         eax, DWORD PTR __Fl$[ebp]
  0000a 50                 push    eax
  0000b 8b 4d 08   mov         ecx, DWORD PTR __Ty$[ebp]
  0000e 51                 push    ecx
  0000f 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00012 e8 00 00 00 00     call    ??0_Node_base@std@@QAE@W4_Node_type@1@W4_Node_flags@1@@Z ; std::_Node_base::_Node_base

; 1800 :              {   // construct

  00017 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  0001a c7 02 00 00 00
        00           mov     DWORD PTR [edx], OFFSET ??_7_Node_assert@std@@6B@

; 1799 :              : _Node_base(_Ty, _Fl), _Child(0)

  00020 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00023 c7 40 14 00 00
        00 00          mov         DWORD PTR [eax+20], 0

; 1801 :              }

  0002a 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0002d 8b e5        mov         esp, ebp
  0002f 5d                 pop     ebp
  00030 c2 08 00   ret         8
??0_Node_assert@std@@QAE@W4_Node_type@1@W4_Node_flags@1@@Z ENDP ; std::_Node_assert::_Node_assert
_TEXT   ENDS
; Function compile flags: /Odtp
;       COMDAT ??_G_Node_end_group@std@@UAEPAXI@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
___flags$ = 8                                     ; size = 4
??_G_Node_end_group@std@@UAEPAXI@Z PROC       ; std::_Node_end_group::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ??1_Node_end_group@std@@UAE@XZ
  0000f 8b 45 08   mov         eax, DWORD PTR ___flags$[ebp]
  00012 83 e0 01   and         eax, 1
  00015 74 0e        je  SHORT $LN2@scalar
  00017 6a 18        push        24             ; 00000018H
  00019 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001c 51                 push    ecx
  0001d e8 00 00 00 00     call    ??3@YAXPAXI@Z                ; operator delete
  00022 83 c4 08   add         esp, 8
$LN2@scalar:
  00025 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00028 8b e5        mov         esp, ebp
  0002a 5d                 pop     ebp
  0002b c2 04 00   ret         4
??_G_Node_end_group@std@@UAEPAXI@Z ENDP       ; std::_Node_end_group::`scalar deleting destructor'
_TEXT   ENDS
; Function compile flags: /Odtp
;       COMDAT ??1_Node_end_group@std@@UAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??1_Node_end_group@std@@UAE@XZ PROC           ; std::_Node_end_group::~_Node_end_group, COMDAT
; _this$ = ecx
  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ??1_Node_base@std@@UAE@XZ ; std::_Node_base::~_Node_base
  0000f 8b e5        mov         esp, ebp
  00011 5d                 pop     ebp
  00012 c3                 ret     0
??1_Node_end_group@std@@UAE@XZ ENDP           ; std::_Node_end_group::~_Node_end_group
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ??0_Node_end_group@std@@QAE@W4_Node_type@1@W4_Node_flags@1@PAV_Node_base@1@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Ty$ = 8                                         ; size = 4
__Fl$ = 12                                          ; size = 4
__Bx$ = 16                                          ; size = 4
??0_Node_end_group@std@@QAE@W4_Node_type@1@W4_Node_flags@1@PAV_Node_base@1@@Z PROC ; std::_Node_end_group::_Node_end_group, COMDAT
; _this$ = ecx

; 1787 :              {   // construct

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1786 :              : _Node_base(_Ty, _Fl), _Back(_Bx)

  00007 8b 45 0c   mov         eax, DWORD PTR __Fl$[ebp]
  0000a 50                 push    eax
  0000b 8b 4d 08   mov         ecx, DWORD PTR __Ty$[ebp]
  0000e 51                 push    ecx
  0000f 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00012 e8 00 00 00 00     call    ??0_Node_base@std@@QAE@W4_Node_type@1@W4_Node_flags@1@@Z ; std::_Node_base::_Node_base

; 1787 :              {   // construct

  00017 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  0001a c7 02 00 00 00
        00           mov     DWORD PTR [edx], OFFSET ??_7_Node_end_group@std@@6B@

; 1786 :              : _Node_base(_Ty, _Fl), _Back(_Bx)

  00020 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00023 8b 4d 10   mov         ecx, DWORD PTR __Bx$[ebp]
  00026 89 48 14   mov         DWORD PTR [eax+20], ecx

; 1788 :              }

  00029 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0002c 8b e5        mov         esp, ebp
  0002e 5d                 pop     ebp
  0002f c2 0c 00   ret         12           ; 0000000cH
??0_Node_end_group@std@@QAE@W4_Node_type@1@W4_Node_flags@1@PAV_Node_base@1@@Z ENDP ; std::_Node_end_group::_Node_end_group
_TEXT   ENDS
; Function compile flags: /Odtp
;       COMDAT ??_G_Root_node@std@@UAEPAXI@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
___flags$ = 8                                     ; size = 4
??_G_Root_node@std@@UAEPAXI@Z PROC                  ; std::_Root_node::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ??1_Root_node@std@@UAE@XZ
  0000f 8b 45 08   mov         eax, DWORD PTR ___flags$[ebp]
  00012 83 e0 01   and         eax, 1
  00015 74 0e        je  SHORT $LN2@scalar
  00017 6a 24        push        36             ; 00000024H
  00019 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001c 51                 push    ecx
  0001d e8 00 00 00 00     call    ??3@YAXPAXI@Z                ; operator delete
  00022 83 c4 08   add         esp, 8
$LN2@scalar:
  00025 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00028 8b e5        mov         esp, ebp
  0002a 5d                 pop     ebp
  0002b c2 04 00   ret         4
??_G_Root_node@std@@UAEPAXI@Z ENDP                  ; std::_Root_node::`scalar deleting destructor'
_TEXT   ENDS
; Function compile flags: /Odtp
;       COMDAT ??1_Root_node@std@@UAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??1_Root_node@std@@UAE@XZ PROC                      ; std::_Root_node::~_Root_node, COMDAT
; _this$ = ecx
  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ??1_Node_base@std@@UAE@XZ ; std::_Node_base::~_Node_base
  0000f 8b e5        mov         esp, ebp
  00011 5d                 pop     ebp
  00012 c3                 ret     0
??1_Root_node@std@@UAE@XZ ENDP                      ; std::_Root_node::~_Root_node
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ??0_Root_node@std@@QAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??0_Root_node@std@@QAE@XZ PROC                      ; std::_Root_node::_Root_node, COMDAT
; _this$ = ecx

; 1769 :              {   // construct

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1768 :              : _Node_base(_N_begin), _Loops(0), _Marks(0), _Refs(0)

  00007 6a 00        push        0
  00009 6a 14        push        20             ; 00000014H
  0000b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000e e8 00 00 00 00     call    ??0_Node_base@std@@QAE@W4_Node_type@1@W4_Node_flags@1@@Z ; std::_Node_base::_Node_base

; 1769 :              {   // construct

  00013 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00016 c7 00 00 00 00
        00           mov     DWORD PTR [eax], OFFSET ??_7_Root_node@std@@6B@

; 1768 :              : _Node_base(_N_begin), _Loops(0), _Marks(0), _Refs(0)

  0001c 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001f c7 41 18 00 00
        00 00          mov         DWORD PTR [ecx+24], 0
  00026 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  00029 c7 42 1c 00 00
        00 00          mov         DWORD PTR [edx+28], 0
  00030 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00033 c7 40 20 00 00
        00 00          mov         DWORD PTR [eax+32], 0

; 1770 :              static_assert(sizeof (_Refs) == sizeof (_Atomic_counter_t),
; 1771 :                  "invalid _Refs size");
; 1772 :              }

  0003a 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0003d 8b e5        mov         esp, ebp
  0003f 5d                 pop     ebp
  00040 c3                 ret     0
??0_Root_node@std@@QAE@XZ ENDP                      ; std::_Root_node::_Root_node
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Destroy_node@std@@YAXPAV_Node_base@1@0@Z
_TEXT   SEGMENT
tv74 = -16                                          ; size = 4
$T1 = -12                                         ; size = 4
__Tmp$2 = -8                                            ; size = 4
$T3 = -4                                                ; size = 4
__Nx$ = 8                                         ; size = 4
__Ne$ = 12                                          ; size = 4
?_Destroy_node@std@@YAXPAV_Node_base@1@0@Z PROC   ; std::_Destroy_node, COMDAT

; 1752 :        {     // destroy sublist of nodes

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 10   sub         esp, 16                        ; 00000010H
$LN2@Destroy_no:

; 1753 :        while (_Nx != _Ne && _Nx != 0)

  00006 8b 45 08   mov         eax, DWORD PTR __Nx$[ebp]
  00009 3b 45 0c   cmp         eax, DWORD PTR __Ne$[ebp]
  0000c 74 4d        je  SHORT $LN1@Destroy_no
  0000e 83 7d 08 00        cmp   DWORD PTR __Nx$[ebp], 0
  00012 74 47        je  SHORT $LN1@Destroy_no

; 1754 :              {   // destroy node
; 1755 :              _Node_base *_Tmp = _Nx;

  00014 8b 4d 08   mov         ecx, DWORD PTR __Nx$[ebp]
  00017 89 4d f8   mov         DWORD PTR __Tmp$2[ebp], ecx

; 1756 :              _Nx = _Nx->_Next;

  0001a 8b 55 08   mov         edx, DWORD PTR __Nx$[ebp]
  0001d 8b 42 0c   mov         eax, DWORD PTR [edx+12]
  00020 89 45 08   mov         DWORD PTR __Nx$[ebp], eax

; 1757 :              _Tmp->_Next = 0;

  00023 8b 4d f8   mov         ecx, DWORD PTR __Tmp$2[ebp]
  00026 c7 41 0c 00 00
        00 00          mov         DWORD PTR [ecx+12], 0

; 1758 :              delete _Tmp;

  0002d 8b 55 f8   mov         edx, DWORD PTR __Tmp$2[ebp]
  00030 89 55 f4   mov         DWORD PTR $T1[ebp], edx
  00033 8b 45 f4   mov         eax, DWORD PTR $T1[ebp]
  00036 89 45 fc   mov         DWORD PTR $T3[ebp], eax
  00039 83 7d fc 00        cmp   DWORD PTR $T3[ebp], 0
  0003d 74 13        je  SHORT $LN5@Destroy_no
  0003f 6a 01        push        1
  00041 8b 4d fc   mov         ecx, DWORD PTR $T3[ebp]
  00044 8b 11        mov         edx, DWORD PTR [ecx]
  00046 8b 4d fc   mov         ecx, DWORD PTR $T3[ebp]
  00049 8b 02        mov         eax, DWORD PTR [edx]
  0004b ff d0        call        eax
  0004d 89 45 f0   mov         DWORD PTR tv74[ebp], eax
  00050 eb 07        jmp         SHORT $LN6@Destroy_no
$LN5@Destroy_no:
  00052 c7 45 f0 00 00
        00 00          mov         DWORD PTR tv74[ebp], 0
$LN6@Destroy_no:

; 1759 :              }

  00059 eb ab        jmp         SHORT $LN2@Destroy_no
$LN1@Destroy_no:

; 1760 :        }

  0005b 8b e5        mov         esp, ebp
  0005d 5d                 pop     ebp
  0005e c3                 ret     0
?_Destroy_node@std@@YAXPAV_Node_base@1@0@Z ENDP   ; std::_Destroy_node
_TEXT   ENDS
; Function compile flags: /Odtp
;       COMDAT ??_G_Node_base@std@@UAEPAXI@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
___flags$ = 8                                     ; size = 4
??_G_Node_base@std@@UAEPAXI@Z PROC                  ; std::_Node_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ??1_Node_base@std@@UAE@XZ ; std::_Node_base::~_Node_base
  0000f 8b 45 08   mov         eax, DWORD PTR ___flags$[ebp]
  00012 83 e0 01   and         eax, 1
  00015 74 0e        je  SHORT $LN2@scalar
  00017 6a 14        push        20             ; 00000014H
  00019 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001c 51                 push    ecx
  0001d e8 00 00 00 00     call    ??3@YAXPAXI@Z                ; operator delete
  00022 83 c4 08   add         esp, 8
$LN2@scalar:
  00025 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00028 8b e5        mov         esp, ebp
  0002a 5d                 pop     ebp
  0002b c2 04 00   ret         4
??_G_Node_base@std@@UAEPAXI@Z ENDP                  ; std::_Node_base::`scalar deleting destructor'
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ??1_Node_base@std@@UAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??1_Node_base@std@@UAE@XZ PROC                      ; std::_Node_base::~_Node_base, COMDAT
; _this$ = ecx

; 1745 :              {   // destroy

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a c7 00 00 00 00
        00           mov     DWORD PTR [eax], OFFSET ??_7_Node_base@std@@6B@

; 1746 :              }

  00010 8b e5        mov         esp, ebp
  00012 5d                 pop     ebp
  00013 c3                 ret     0
??1_Node_base@std@@UAE@XZ ENDP                      ; std::_Node_base::~_Node_base
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ??0_Node_base@std@@QAE@W4_Node_type@1@W4_Node_flags@1@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Ty$ = 8                                         ; size = 4
__Fl$ = 12                                          ; size = 4
??0_Node_base@std@@QAE@W4_Node_type@1@W4_Node_flags@1@@Z PROC ; std::_Node_base::_Node_base, COMDAT
; _this$ = ecx

; 1736 :              {   // construct

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a c7 00 00 00 00
        00           mov     DWORD PTR [eax], OFFSET ??_7_Node_base@std@@6B@

; 1735 :              : _Kind(_Ty), _Flags(_Fl), _Next(0), _Prev(0)

  00010 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00013 8b 55 08   mov         edx, DWORD PTR __Ty$[ebp]
  00016 89 51 04   mov         DWORD PTR [ecx+4], edx
  00019 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0001c 8b 4d 0c   mov         ecx, DWORD PTR __Fl$[ebp]
  0001f 89 48 08   mov         DWORD PTR [eax+8], ecx
  00022 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  00025 c7 42 0c 00 00
        00 00          mov         DWORD PTR [edx+12], 0
  0002c 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0002f c7 40 10 00 00
        00 00          mov         DWORD PTR [eax+16], 0

; 1737 :              }

  00036 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00039 8b e5        mov         esp, ebp
  0003b 5d                 pop     ebp
  0003c c2 08 00   ret         8
??0_Node_base@std@@QAE@W4_Node_type@1@W4_Node_flags@1@@Z ENDP ; std::_Node_base::_Node_base
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ??0_Bitmap@std@@QAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??0_Bitmap@std@@QAE@XZ PROC                   ; std::_Bitmap::_Bitmap, COMDAT
; _this$ = ecx

; 1691 :        _Bitmap()

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1692 :              {   // construct
; 1693 :              _CSTD memset(_Chrs, '\0', _Bmp_size);

  00007 6a 20        push        32             ; 00000020H
  00009 6a 00        push        0
  0000b 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000e 50                 push    eax
  0000f e8 00 00 00 00     call    _memset
  00014 83 c4 0c   add         esp, 12                        ; 0000000cH

; 1694 :              }

  00017 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0001a 8b e5        mov         esp, ebp
  0001c 5d                 pop     ebp
  0001d c3                 ret     0
??0_Bitmap@std@@QAE@XZ ENDP                   ; std::_Bitmap::_Bitmap
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ??_6std@@YA?AW4_Node_flags@0@AAW410@W410@@Z
_TEXT   SEGMENT
__Left$ = 8                                   ; size = 4
__Right$ = 12                                     ; size = 4
??_6std@@YA?AW4_Node_flags@0@AAW410@W410@@Z PROC        ; std::operator^=, COMDAT

; 1587 :        {     // bitwise xor

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 1588 :        return (_Left = _Node_flags((int)_Left ^ _Right));

  00003 8b 45 08   mov         eax, DWORD PTR __Left$[ebp]
  00006 8b 08        mov         ecx, DWORD PTR [eax]
  00008 33 4d 0c   xor         ecx, DWORD PTR __Right$[ebp]
  0000b 8b 55 08   mov         edx, DWORD PTR __Left$[ebp]
  0000e 89 0a        mov         DWORD PTR [edx], ecx
  00010 8b 45 08   mov         eax, DWORD PTR __Left$[ebp]
  00013 8b 00        mov         eax, DWORD PTR [eax]

; 1589 :        }

  00015 5d                 pop     ebp
  00016 c3                 ret     0
??_6std@@YA?AW4_Node_flags@0@AAW410@W410@@Z ENDP        ; std::operator^=
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ??_5std@@YA?AW4_Node_flags@0@AAW410@W410@@Z
_TEXT   SEGMENT
__Left$ = 8                                   ; size = 4
__Right$ = 12                                     ; size = 4
??_5std@@YA?AW4_Node_flags@0@AAW410@W410@@Z PROC        ; std::operator|=, COMDAT

; 1582 :        {     // bitwise or

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 1583 :        return (_Left = _Node_flags((int)_Left | _Right));

  00003 8b 45 08   mov         eax, DWORD PTR __Left$[ebp]
  00006 8b 08        mov         ecx, DWORD PTR [eax]
  00008 0b 4d 0c   or  ecx, DWORD PTR __Right$[ebp]
  0000b 8b 55 08   mov         edx, DWORD PTR __Left$[ebp]
  0000e 89 0a        mov         DWORD PTR [edx], ecx
  00010 8b 45 08   mov         eax, DWORD PTR __Left$[ebp]
  00013 8b 00        mov         eax, DWORD PTR [eax]

; 1584 :        }

  00015 5d                 pop     ebp
  00016 c3                 ret     0
??_5std@@YA?AW4_Node_flags@0@AAW410@W410@@Z ENDP        ; std::operator|=
_TEXT   ENDS
; Function compile flags: /Odtp
;       COMDAT ??1?$regex_traits@D@std@@QAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??1?$regex_traits@D@std@@QAE@XZ PROC                    ; std::regex_traits<char>::~regex_traits<char>, COMDAT
; _this$ = ecx
  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ??1?$_Regex_traits@D@std@@QAE@XZ
  0000f 8b e5        mov         esp, ebp
  00011 5d                 pop     ebp
  00012 c3                 ret     0
??1?$regex_traits@D@std@@QAE@XZ ENDP                    ; std::regex_traits<char>::~regex_traits<char>
_TEXT   ENDS
; Function compile flags: /Odtp
;       COMDAT ??0?$regex_traits@D@std@@QAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??0?$regex_traits@D@std@@QAE@XZ PROC                    ; std::regex_traits<char>::regex_traits<char>, COMDAT
; _this$ = ecx
  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ??0?$_Regex_traits@D@std@@QAE@XZ ; std::_Regex_traits<char>::_Regex_traits<char>
  0000f 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00012 8b e5        mov         esp, ebp
  00014 5d                 pop     ebp
  00015 c3                 ret     0
??0?$regex_traits@D@std@@QAE@XZ ENDP                    ; std::regex_traits<char>::regex_traits<char>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?value@?$regex_traits@D@std@@QBEHDH@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Ch$ = 8                                         ; size = 1
__Base$ = 12                                            ; size = 4
?value@?$regex_traits@D@std@@QBEHDH@Z PROC          ; std::regex_traits<char>::value, COMDAT
; _this$ = ecx

; 436  :              {   // map character value to numeric value

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 437  :              if ((_Base != 8 && '0' <= _Ch && _Ch <= '9')
; 438  :                  || (_Base == 8 && '0' <= _Ch && _Ch <= '7'))

  00007 83 7d 0c 08        cmp   DWORD PTR __Base$[ebp], 8
  0000b 74 12        je  SHORT $LN5@value
  0000d 0f be 45 08        movsx         eax, BYTE PTR __Ch$[ebp]
  00011 83 f8 30   cmp         eax, 48                        ; 00000030H
  00014 7c 09        jl  SHORT $LN5@value
  00016 0f be 4d 08        movsx         ecx, BYTE PTR __Ch$[ebp]
  0001a 83 f9 39   cmp         ecx, 57                        ; 00000039H
  0001d 7e 18        jle         SHORT $LN4@value
$LN5@value:
  0001f 83 7d 0c 08        cmp   DWORD PTR __Base$[ebp], 8
  00023 75 1d        jne         SHORT $LN2@value
  00025 0f be 55 08        movsx         edx, BYTE PTR __Ch$[ebp]
  00029 83 fa 30   cmp         edx, 48                        ; 00000030H
  0002c 7c 14        jl  SHORT $LN2@value
  0002e 0f be 45 08        movsx         eax, BYTE PTR __Ch$[ebp]
  00032 83 f8 37   cmp         eax, 55                        ; 00000037H
  00035 7f 0b        jg  SHORT $LN2@value
$LN4@value:

; 439  :                  return (_Ch - '0');

  00037 0f be 45 08        movsx         eax, BYTE PTR __Ch$[ebp]
  0003b 83 e8 30   sub         eax, 48                        ; 00000030H
  0003e eb 45        jmp         SHORT $LN1@value
  00040 eb 40        jmp         SHORT $LN3@value
$LN2@value:

; 440  :              else if (_Base != 16)

  00042 83 7d 0c 10        cmp   DWORD PTR __Base$[ebp], 16 ; 00000010H
  00046 74 02        je  SHORT $LN6@value
  00048 eb 38        jmp         SHORT $LN3@value
$LN6@value:

; 441  :                  ;
; 442  :              else if ('a' <= _Ch && _Ch <= 'f')

  0004a 0f be 4d 08        movsx         ecx, BYTE PTR __Ch$[ebp]
  0004e 83 f9 61   cmp         ecx, 97                        ; 00000061H
  00051 7c 14        jl  SHORT $LN8@value
  00053 0f be 55 08        movsx         edx, BYTE PTR __Ch$[ebp]
  00057 83 fa 66   cmp         edx, 102             ; 00000066H
  0005a 7f 0b        jg  SHORT $LN8@value

; 443  :                  return (_Ch - 'a' + 10);

  0005c 0f be 45 08        movsx         eax, BYTE PTR __Ch$[ebp]
  00060 83 e8 57   sub         eax, 87                        ; 00000057H
  00063 eb 20        jmp         SHORT $LN1@value
  00065 eb 1b        jmp         SHORT $LN3@value
$LN8@value:

; 444  :              else if ('A' <= _Ch && _Ch <= 'F')

  00067 0f be 45 08        movsx         eax, BYTE PTR __Ch$[ebp]
  0006b 83 f8 41   cmp         eax, 65                        ; 00000041H
  0006e 7c 12        jl  SHORT $LN3@value
  00070 0f be 4d 08        movsx         ecx, BYTE PTR __Ch$[ebp]
  00074 83 f9 46   cmp         ecx, 70                        ; 00000046H
  00077 7f 09        jg  SHORT $LN3@value

; 445  :                  return (_Ch - 'A' + 10);

  00079 0f be 45 08        movsx         eax, BYTE PTR __Ch$[ebp]
  0007d 83 e8 37   sub         eax, 55                        ; 00000037H
  00080 eb 03        jmp         SHORT $LN1@value
$LN3@value:

; 446  :              return (-1);

  00082 83 c8 ff   or  eax, -1
$LN1@value:

; 447  :              }

  00085 8b e5        mov         esp, ebp
  00087 5d                 pop     ebp
  00088 c2 08 00   ret         8
?value@?$regex_traits@D@std@@QBEHDH@Z ENDP          ; std::regex_traits<char>::value
_TEXT   ENDS
; Function compile flags: /Odtp
;       COMDAT ??1?$_Regex_traits@D@std@@QAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??1?$_Regex_traits@D@std@@QAE@XZ PROC             ; std::_Regex_traits<char>::~_Regex_traits<char>, COMDAT
; _this$ = ecx
  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a 83 c1 08   add         ecx, 8
  0000d e8 00 00 00 00     call    ??1locale@std@@QAE@XZ        ; std::locale::~locale
  00012 8b e5        mov         esp, ebp
  00014 5d                 pop     ebp
  00015 c3                 ret     0
??1?$_Regex_traits@D@std@@QAE@XZ ENDP             ; std::_Regex_traits<char>::~_Regex_traits<char>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Cache_locale@?$_Regex_traits@D@std@@AAEXXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Cache_locale@?$_Regex_traits@D@std@@AAEXXZ PROC       ; std::_Regex_traits<char>::_Cache_locale, COMDAT
; _this$ = ecx

; 419  :              {   // populate _Pcoll and _Pctype with _Loc locale

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 420  :              _Pcoll = &_USE(_Loc, collate<_Elem>);

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a 83 c0 08   add         eax, 8
  0000d 50                 push    eax
  0000e e8 00 00 00 00     call    ??$use_facet@V?$collate@D@std@@@std@@YAABV?$collate@D@0@ABVlocale@0@@Z ; std::use_facet<std::collate<char> >
  00013 83 c4 04   add         esp, 4
  00016 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00019 89 01        mov         DWORD PTR [ecx], eax

; 421  :              _Pctype = &_USE(_Loc, ctype<_Elem>);

  0001b 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  0001e 83 c2 08   add         edx, 8
  00021 52                 push    edx
  00022 e8 00 00 00 00     call    ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
  00027 83 c4 04   add         esp, 4
  0002a 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0002d 89 41 04   mov         DWORD PTR [ecx+4], eax

; 422  :              }

  00030 8b e5        mov         esp, ebp
  00032 5d                 pop     ebp
  00033 c3                 ret     0
?_Cache_locale@?$_Regex_traits@D@std@@AAEXXZ ENDP       ; std::_Regex_traits<char>::_Cache_locale
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Getctype@?$_Regex_traits@D@std@@QBEPBV?$ctype@D@2@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Getctype@?$_Regex_traits@D@std@@QBEPBV?$ctype@D@2@XZ PROC ; std::_Regex_traits<char>::_Getctype, COMDAT
; _this$ = ecx

; 413  :              {   // get ctype facet pointer

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 414  :              return (_Pctype);

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a 8b 40 04   mov         eax, DWORD PTR [eax+4]

; 415  :              }

  0000d 8b e5        mov         esp, ebp
  0000f 5d                 pop     ebp
  00010 c3                 ret     0
?_Getctype@?$_Regex_traits@D@std@@QBEPBV?$ctype@D@2@XZ ENDP ; std::_Regex_traits<char>::_Getctype
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?_Getcoll@?$_Regex_traits@D@std@@QBEPBV?$collate@D@2@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Getcoll@?$_Regex_traits@D@std@@QBEPBV?$collate@D@2@XZ PROC ; std::_Regex_traits<char>::_Getcoll, COMDAT
; _this$ = ecx

; 408  :              {   // get collate facet pointer

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 409  :              return (_Pcoll);

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a 8b 00        mov         eax, DWORD PTR [eax]

; 410  :              }

  0000c 8b e5        mov         esp, ebp
  0000e 5d                 pop     ebp
  0000f c3                 ret     0
?_Getcoll@?$_Regex_traits@D@std@@QBEPBV?$collate@D@2@XZ ENDP ; std::_Regex_traits<char>::_Getcoll
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?isctype@?$_Regex_traits@D@std@@QBE_NDF@Z
_TEXT   SEGMENT
tv82 = -8                                         ; size = 4
_this$ = -4                                   ; size = 4
__Ch$ = 8                                         ; size = 1
__Fx$ = 12                                          ; size = 2
?isctype@?$_Regex_traits@D@std@@QBE_NDF@Z PROC      ; std::_Regex_traits<char>::isctype, COMDAT
; _this$ = ecx

; 336  :              {   // return true if _Ch is in character class _Fx

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 337  :              if (_Fx != (char_class_type)(-1))

  00009 0f bf 45 0c        movsx         eax, WORD PTR __Fx$[ebp]
  0000d 83 f8 ff   cmp         eax, -1
  00010 74 1d        je  SHORT $LN2@isctype

; 338  :                  return (_Getctype()->is(_Fx, _Ch));

  00012 0f b6 4d 08        movzx         ecx, BYTE PTR __Ch$[ebp]
  00016 51                 push    ecx
  00017 0f b7 55 0c        movzx         edx, WORD PTR __Fx$[ebp]
  0001b 52                 push    edx
  0001c 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001f e8 00 00 00 00     call    ?_Getctype@?$_Regex_traits@D@std@@QBEPBV?$ctype@D@2@XZ ; std::_Regex_traits<char>::_Getctype
  00024 8b c8        mov         ecx, eax
  00026 e8 00 00 00 00     call    ?is@?$ctype@D@std@@QBE_NFD@Z ; std::ctype<char>::is
  0002b eb 3e        jmp         SHORT $LN1@isctype

; 339  :              else

  0002d eb 3c        jmp         SHORT $LN1@isctype
$LN2@isctype:

; 340  :                  return (_Ch == '_'      // assumes L'_' == '_'

  0002f 0f be 45 08        movsx         eax, BYTE PTR __Ch$[ebp]
  00033 83 f8 5f   cmp         eax, 95                        ; 0000005fH
  00036 74 29        je  SHORT $LN5@isctype
  00038 0f b6 4d 08        movzx         ecx, BYTE PTR __Ch$[ebp]
  0003c 51                 push    ecx
  0003d 68 07 01 00 00     push    263              ; 00000107H
  00042 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00045 e8 00 00 00 00     call    ?_Getctype@?$_Regex_traits@D@std@@QBEPBV?$ctype@D@2@XZ ; std::_Regex_traits<char>::_Getctype
  0004a 8b c8        mov         ecx, eax
  0004c e8 00 00 00 00     call    ?is@?$ctype@D@std@@QBE_NFD@Z ; std::ctype<char>::is
  00051 0f b6 d0   movzx       edx, al
  00054 85 d2        test        edx, edx
  00056 75 09        jne         SHORT $LN5@isctype
  00058 c7 45 f8 00 00
        00 00          mov         DWORD PTR tv82[ebp], 0
  0005f eb 07        jmp         SHORT $LN6@isctype
$LN5@isctype:
  00061 c7 45 f8 01 00
        00 00          mov         DWORD PTR tv82[ebp], 1
$LN6@isctype:
  00068 8a 45 f8   mov         al, BYTE PTR tv82[ebp]
$LN1@isctype:

; 341  :                          || _Getctype()->is(_Ch_alnum, _Ch));
; 342  :              }

  0006b 8b e5        mov         esp, ebp
  0006d 5d                 pop     ebp
  0006e c2 08 00   ret         8
?isctype@?$_Regex_traits@D@std@@QBE_NDF@Z ENDP      ; std::_Regex_traits<char>::isctype
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?translate_nocase@?$_Regex_traits@D@std@@QBEDD@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Ch$ = 8                                         ; size = 1
?translate_nocase@?$_Regex_traits@D@std@@QBEDD@Z PROC   ; std::_Regex_traits<char>::translate_nocase, COMDAT
; _this$ = ecx

; 308  :              {   // provide case-insensitive mapping

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 309  :              return (_Getctype()->tolower(_Ch));

  00007 0f b6 45 08        movzx         eax, BYTE PTR __Ch$[ebp]
  0000b 50                 push    eax
  0000c 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000f e8 00 00 00 00     call    ?_Getctype@?$_Regex_traits@D@std@@QBEPBV?$ctype@D@2@XZ ; std::_Regex_traits<char>::_Getctype
  00014 8b c8        mov         ecx, eax
  00016 e8 00 00 00 00     call    ?tolower@?$ctype@D@std@@QBEDD@Z ; std::ctype<char>::tolower

; 310  :              }

  0001b 8b e5        mov         esp, ebp
  0001d 5d                 pop     ebp
  0001e c2 04 00   ret         4
?translate_nocase@?$_Regex_traits@D@std@@QBEDD@Z ENDP   ; std::_Regex_traits<char>::translate_nocase
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?translate@?$_Regex_traits@D@std@@QBEDD@Z
_TEXT   SEGMENT
_this$ = -36                                            ; size = 4
$T1 = -30                                         ; size = 1
tv79 = -29                                          ; size = 1
__Res$ = -28                                            ; size = 24
__$ArrayPad$ = -4                                 ; size = 4
__Ch$ = 8                                         ; size = 1
?translate@?$_Regex_traits@D@std@@QBEDD@Z PROC      ; std::_Regex_traits<char>::translate, COMDAT
; _this$ = ecx

; 302  :              {   // provide locale-sensitive mapping

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 24   sub         esp, 36                        ; 00000024H
  00006 a1 00 00 00 00     mov     eax, DWORD PTR ___security_cookie
  0000b 33 c5        xor         eax, ebp
  0000d 89 45 fc   mov         DWORD PTR __$ArrayPad$[ebp], eax
  00010 89 4d dc   mov         DWORD PTR _this$[ebp], ecx

; 303  :              string_type _Res = _Getcoll()->transform(&_Ch, &_Ch + 1);

  00013 8d 45 09   lea         eax, DWORD PTR __Ch$[ebp+1]
  00016 50                 push    eax
  00017 8d 4d 08   lea         ecx, DWORD PTR __Ch$[ebp]
  0001a 51                 push    ecx
  0001b 8d 55 e4   lea         edx, DWORD PTR __Res$[ebp]
  0001e 52                 push    edx
  0001f 8b 4d dc   mov         ecx, DWORD PTR _this$[ebp]
  00022 e8 00 00 00 00     call    ?_Getcoll@?$_Regex_traits@D@std@@QBEPBV?$collate@D@2@XZ ; std::_Regex_traits<char>::_Getcoll
  00027 8b c8        mov         ecx, eax
  00029 e8 00 00 00 00     call    ?transform@?$collate@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PBD0@Z ; std::collate<char>::transform

; 304  :              return (_Res.length() == 1 ? _Res[0] : _Ch);

  0002e 8d 4d e4   lea         ecx, DWORD PTR __Res$[ebp]
  00031 e8 00 00 00 00     call    ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
  00036 83 f8 01   cmp         eax, 1
  00039 75 11        jne         SHORT $LN3@translate
  0003b 6a 00        push        0
  0003d 8d 4d e4   lea         ecx, DWORD PTR __Res$[ebp]
  00040 e8 00 00 00 00     call    ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
  00045 8a 00        mov         al, BYTE PTR [eax]
  00047 88 45 e3   mov         BYTE PTR tv79[ebp], al
  0004a eb 06        jmp         SHORT $LN4@translate
$LN3@translate:
  0004c 8a 4d 08   mov         cl, BYTE PTR __Ch$[ebp]
  0004f 88 4d e3   mov         BYTE PTR tv79[ebp], cl
$LN4@translate:
  00052 8a 55 e3   mov         dl, BYTE PTR tv79[ebp]
  00055 88 55 e2   mov         BYTE PTR $T1[ebp], dl
  00058 8d 4d e4   lea         ecx, DWORD PTR __Res$[ebp]
  0005b e8 00 00 00 00     call    ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00060 8a 45 e2   mov         al, BYTE PTR $T1[ebp]

; 305  :              }

  00063 8b 4d fc   mov         ecx, DWORD PTR __$ArrayPad$[ebp]
  00066 33 cd        xor         ecx, ebp
  00068 e8 00 00 00 00     call    @__security_check_cookie@4
  0006d 8b e5        mov         esp, ebp
  0006f 5d                 pop     ebp
  00070 c2 04 00   ret         4
?translate@?$_Regex_traits@D@std@@QBEDD@Z ENDP      ; std::_Regex_traits<char>::translate
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ??0?$_Regex_traits@D@std@@QAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??0?$_Regex_traits@D@std@@QAE@XZ PROC             ; std::_Regex_traits<char>::_Regex_traits<char>, COMDAT
; _this$ = ecx

; 283  :        _Regex_traits()

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 284  :              {   // default construct

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a 83 c1 08   add         ecx, 8
  0000d e8 00 00 00 00     call    ??0locale@std@@QAE@XZ        ; std::locale::locale

; 285  :              _Cache_locale();

  00012 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00015 e8 00 00 00 00     call    ?_Cache_locale@?$_Regex_traits@D@std@@AAEXXZ ; std::_Regex_traits<char>::_Cache_locale

; 286  :              }

  0001a 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0001d 8b e5        mov         esp, ebp
  0001f 5d                 pop     ebp
  00020 c3                 ret     0
??0?$_Regex_traits@D@std@@QAE@XZ ENDP             ; std::_Regex_traits<char>::_Regex_traits<char>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ?length@?$_Regex_traits@D@std@@SAIPBD@Z
_TEXT   SEGMENT
__Str$ = 8                                          ; size = 4
?length@?$_Regex_traits@D@std@@SAIPBD@Z PROC            ; std::_Regex_traits<char>::length, COMDAT

; 276  :              {   // return length of _Str

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 277  :              if (_Str == 0)

  00003 83 7d 08 00        cmp   DWORD PTR __Str$[ebp], 0
  00007 75 07        jne         SHORT $LN2@length

; 278  :                  _Xregex_error(

  00009 6a 0d        push        13             ; 0000000dH
  0000b e8 00 00 00 00     call    ?_Xregex_error@std@@YAXW4error_type@regex_constants@1@@Z ; std::_Xregex_error
$LN2@length:

; 279  :                          regex_constants::error_parse);  // to quiet diagnostics
; 280  :              return (char_traits<_Elem>::length(_Str));

  00010 8b 45 08   mov         eax, DWORD PTR __Str$[ebp]
  00013 50                 push    eax
  00014 e8 00 00 00 00     call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length
  00019 83 c4 04   add         esp, 4
$LN3@length:

; 281  :              }

  0001c 5d                 pop     ebp
  0001d c3                 ret     0
?length@?$_Regex_traits@D@std@@SAIPBD@Z ENDP            ; std::_Regex_traits<char>::length
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ??$_Get@D@_Cl_names@std@@QBEPBDXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??$_Get@D@_Cl_names@std@@QBEPBDXZ PROC              ; std::_Cl_names::_Get<char>, COMDAT
; _this$ = ecx

; 180  :        {     // get narrow pointer

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 181  :        return (_Narrow);

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a 8b 00        mov         eax, DWORD PTR [eax]

; 182  :        }

  0000c 8b e5        mov         esp, ebp
  0000e 5d                 pop     ebp
  0000f c3                 ret     0
??$_Get@D@_Cl_names@std@@QBEPBDXZ ENDP              ; std::_Cl_names::_Get<char>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ??Uregex_constants@std@@YA?AW4syntax_option_type@01@W4201@0@Z
_TEXT   SEGMENT
__Left$ = 8                                   ; size = 4
__Right$ = 12                                     ; size = 4
??Uregex_constants@std@@YA?AW4syntax_option_type@01@W4201@0@Z PROC ; std::regex_constants::operator|, COMDAT

; 118  : _BITMASK_OPS(syntax_option_type)

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 8b 45 08   mov         eax, DWORD PTR __Left$[ebp]
  00006 0b 45 0c   or  eax, DWORD PTR __Right$[ebp]
  00009 5d                 pop     ebp
  0000a c3                 ret     0
??Uregex_constants@std@@YA?AW4syntax_option_type@01@W4201@0@Z ENDP ; std::regex_constants::operator|
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\regex
;       COMDAT ??Iregex_constants@std@@YA?AW4syntax_option_type@01@W4201@0@Z
_TEXT   SEGMENT
__Left$ = 8                                   ; size = 4
__Right$ = 12                                     ; size = 4
??Iregex_constants@std@@YA?AW4syntax_option_type@01@W4201@0@Z PROC ; std::regex_constants::operator&, COMDAT

; 118  : _BITMASK_OPS(syntax_option_type)

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 8b 45 08   mov         eax, DWORD PTR __Left$[ebp]
  00006 23 45 0c   and         eax, DWORD PTR __Right$[ebp]
  00009 5d                 pop     ebp
  0000a c3                 ret     0
??Iregex_constants@std@@YA?AW4syntax_option_type@01@W4201@0@Z ENDP ; std::regex_constants::operator&
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;       COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT   SEGMENT
$T1 = -36                                         ; size = 12
$T2 = -24                                         ; size = 4
__Lock$3 = -20                                      ; size = 4
__Id$4 = -16                                            ; size = 4
__Pfmod$5 = -12                               ; size = 4
__Pf$6 = -8                                   ; size = 4
__Psave$7 = -4                                      ; size = 4
__Loc$ = 8                                          ; size = 4
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z PROC ; std::use_facet<std::ctype<char> >, COMDAT

; 553  :        {     // get facet reference from locale

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 24   sub         esp, 36                        ; 00000024H

; 554  :  #if _NO_LOCALES
; 555  :        static _Wrap_facet<_Facet> _Wfac;
; 556  :        return (*(_Facet *)&_Wfac);
; 557  :
; 558  :  #else /* _NO_LOCALES */
; 559  :        _BEGIN_LOCK(_LOCK_LOCALE)     // the thread lock, make get atomic

  00006 6a 00        push        0
  00008 8d 4d ec   lea         ecx, DWORD PTR __Lock$3[ebp]
  0000b e8 00 00 00 00     call    ??0_Lockit@std@@QAE@H@Z      ; std::_Lockit::_Lockit

; 560  :              const locale::facet *_Psave =
; 561  :                  _Facetptr<_Facet>::_Psave;      // static pointer to lazy facet

  00010 a1 00 00 00 00     mov     eax, DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
  00015 89 45 fc   mov         DWORD PTR __Psave$7[ebp], eax

; 562  :
; 563  :              size_t _Id = _Facet::id;

  00018 b9 00 00 00 00     mov     ecx, OFFSET ?id@?$ctype@D@std@@2V0locale@2@A ; std::ctype<char>::id
  0001d e8 00 00 00 00     call    ??Bid@locale@std@@QAEIXZ ; std::locale::id::operator unsigned int
  00022 89 45 f0   mov         DWORD PTR __Id$4[ebp], eax

; 564  :              const locale::facet *_Pf = _Loc._Getfacet(_Id);

  00025 8b 4d f0   mov         ecx, DWORD PTR __Id$4[ebp]
  00028 51                 push    ecx
  00029 8b 4d 08   mov         ecx, DWORD PTR __Loc$[ebp]
  0002c e8 00 00 00 00     call    ?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ; std::locale::_Getfacet
  00031 89 45 f8   mov         DWORD PTR __Pf$6[ebp], eax

; 565  :
; 566  :              if (_Pf != 0)

  00034 83 7d f8 00        cmp   DWORD PTR __Pf$6[ebp], 0
  00038 74 02        je  SHORT $LN2@use_facet
  0003a eb 69        jmp         SHORT $LN3@use_facet
$LN2@use_facet:

; 567  :                  ;       // got facet from locale
; 568  :              else if (_Psave != 0)

  0003c 83 7d fc 00        cmp   DWORD PTR __Psave$7[ebp], 0
  00040 74 08        je  SHORT $LN4@use_facet

; 569  :                  _Pf = _Psave;   // lazy facet already allocated

  00042 8b 55 fc   mov         edx, DWORD PTR __Psave$7[ebp]
  00045 89 55 f8   mov         DWORD PTR __Pf$6[ebp], edx
  00048 eb 5b        jmp         SHORT $LN3@use_facet
$LN4@use_facet:

; 570  :              else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

  0004a 8b 45 08   mov         eax, DWORD PTR __Loc$[ebp]
  0004d 50                 push    eax
  0004e 8d 4d fc   lea         ecx, DWORD PTR __Psave$7[ebp]
  00051 51                 push    ecx
  00052 e8 00 00 00 00     call    ?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::ctype<char>::_Getcat
  00057 83 c4 08   add         esp, 8
  0005a 83 f8 ff   cmp         eax, -1
  0005d 75 18        jne         SHORT $LN6@use_facet

; 571  :
; 572  :  #if _HAS_EXCEPTIONS
; 573  :
; 574  :                  _THROW_NCEE(_XSTD bad_cast, _EMPTY_ARGUMENT);   // lazy disallowed

  0005f 8d 4d dc   lea         ecx, DWORD PTR $T1[ebp]
  00062 e8 00 00 00 00     call    ??0bad_cast@std@@QAE@XZ      ; std::bad_cast::bad_cast
  00067 68 00 00 00 00     push    OFFSET __TI2?AVbad_cast@std@@
  0006c 8d 55 dc   lea         edx, DWORD PTR $T1[ebp]
  0006f 52                 push    edx
  00070 e8 00 00 00 00     call    __CxxThrowException@8

; 575  :
; 576  :  #else /* _HAS_EXCEPTIONS */
; 577  :                  abort();        // lazy disallowed
; 578  :  #endif /* _HAS_EXCEPTIONS */
; 579  :
; 580  :              else

  00075 eb 2e        jmp         SHORT $LN3@use_facet
$LN6@use_facet:

; 581  :                  {       // queue up lazy facet for destruction
; 582  :                  _Pf = _Psave;

  00077 8b 45 fc   mov         eax, DWORD PTR __Psave$7[ebp]
  0007a 89 45 f8   mov         DWORD PTR __Pf$6[ebp], eax

; 583  :                  _Facetptr<_Facet>::_Psave = _Psave;

  0007d 8b 4d fc   mov         ecx, DWORD PTR __Psave$7[ebp]
  00080 89 0d 00 00 00
        00           mov     DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B, ecx ; std::_Facetptr<std::ctype<char> >::_Psave

; 584  :
; 585  :                  locale::facet *_Pfmod = (_Facet *)_Psave;

  00086 8b 55 fc   mov         edx, DWORD PTR __Psave$7[ebp]
  00089 89 55 f4   mov         DWORD PTR __Pfmod$5[ebp], edx

; 586  :                  _Pfmod->_Incref();

  0008c 8b 45 f4   mov         eax, DWORD PTR __Pfmod$5[ebp]
  0008f 8b 10        mov         edx, DWORD PTR [eax]
  00091 8b 4d f4   mov         ecx, DWORD PTR __Pfmod$5[ebp]
  00094 8b 42 04   mov         eax, DWORD PTR [edx+4]
  00097 ff d0        call        eax

; 587  :
; 588  :  #if defined(_M_CEE)
; 589  :                  _Facet_Register_m(_Pfmod);
; 590  :
; 591  :  #else /* defined(_M_CEE) */
; 592  :                  _Facet_Register(_Pfmod);

  00099 8b 4d f4   mov         ecx, DWORD PTR __Pfmod$5[ebp]
  0009c 51                 push    ecx
  0009d e8 00 00 00 00     call    ?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register
  000a2 83 c4 04   add         esp, 4
$LN3@use_facet:

; 593  :  #endif /* defined(_M_CEE) */
; 594  :                  }
; 595  :
; 596  :              return ((const _Facet&)(*_Pf));     // should be dynamic_cast

  000a5 8b 55 f8   mov         edx, DWORD PTR __Pf$6[ebp]
  000a8 89 55 e8   mov         DWORD PTR $T2[ebp], edx
  000ab 8d 4d ec   lea         ecx, DWORD PTR __Lock$3[ebp]
  000ae e8 00 00 00 00     call    ??1_Lockit@std@@QAE@XZ       ; std::_Lockit::~_Lockit
  000b3 8b 45 e8   mov         eax, DWORD PTR $T2[ebp]
$LN8@use_facet:

; 597  :        _END_LOCK()
; 598  :  #endif /* _NO_LOCALES */
; 599  :        }     // end of use_facet body

  000b6 8b e5        mov         esp, ebp
  000b8 5d                 pop     ebp
  000b9 c3                 ret     0
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::ctype<char> >
_TEXT   ENDS
; Function compile flags: /Odtp
;       COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
___flags$ = 8                                     ; size = 4
??_G?$ctype@D@std@@MAEPAXI@Z PROC                 ; std::ctype<char>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ??1?$ctype@D@std@@MAE@XZ ; std::ctype<char>::~ctype<char>
  0000f 8b 45 08   mov         eax, DWORD PTR ___flags$[ebp]
  00012 83 e0 01   and         eax, 1
  00015 74 0e        je  SHORT $LN2@scalar
  00017 6a 18        push        24             ; 00000018H
  00019 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001c 51                 push    ecx
  0001d e8 00 00 00 00     call    ??3@YAXPAXI@Z                ; operator delete
  00022 83 c4 08   add         esp, 8
$LN2@scalar:
  00025 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00028 8b e5        mov         esp, ebp
  0002a 5d                 pop     ebp
  0002b c2 04 00   ret         4
??_G?$ctype@D@std@@MAEPAXI@Z ENDP                 ; std::ctype<char>::`scalar deleting destructor'
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;       COMDAT ?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__First$ = 8                                            ; size = 4
__Last$ = 12                                            ; size = 4
___formal$ = 16                               ; size = 1
__Dest$ = 20                                            ; size = 4
?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z PROC   ; std::ctype<char>::do_narrow, COMDAT
; _this$ = ecx

; 2558 :              {   // narrow elements in [_First, _Last) to chars

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2559 :              _DEBUG_RANGE_PTR(_First, _Last, _Dest);
; 2560 :              _CSTD memcpy(_Dest, _First, _Last - _First);

  00007 8b 45 0c   mov         eax, DWORD PTR __Last$[ebp]
  0000a 2b 45 08   sub         eax, DWORD PTR __First$[ebp]
  0000d 50                 push    eax
  0000e 8b 4d 08   mov         ecx, DWORD PTR __First$[ebp]
  00011 51                 push    ecx
  00012 8b 55 14   mov         edx, DWORD PTR __Dest$[ebp]
  00015 52                 push    edx
  00016 e8 00 00 00 00     call    _memcpy
  0001b 83 c4 0c   add         esp, 12                        ; 0000000cH

; 2561 :              return (_Last);

  0001e 8b 45 0c   mov         eax, DWORD PTR __Last$[ebp]

; 2562 :              }

  00021 8b e5        mov         esp, ebp
  00023 5d                 pop     ebp
  00024 c2 10 00   ret         16           ; 00000010H
?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z ENDP   ; std::ctype<char>::do_narrow
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;       COMDAT ?do_narrow@?$ctype@D@std@@MBEDDD@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Ch$ = 8                                         ; size = 1
___formal$ = 12                               ; size = 1
?do_narrow@?$ctype@D@std@@MBEDDD@Z PROC       ; std::ctype<char>::do_narrow, COMDAT
; _this$ = ecx

; 2552 :              {   // narrow char

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2553 :              return (_Ch);

  00007 8a 45 08   mov         al, BYTE PTR __Ch$[ebp]

; 2554 :              }

  0000a 8b e5        mov         esp, ebp
  0000c 5d                 pop     ebp
  0000d c2 08 00   ret         8
?do_narrow@?$ctype@D@std@@MBEDDD@Z ENDP       ; std::ctype<char>::do_narrow
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;       COMDAT ?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__First$ = 8                                            ; size = 4
__Last$ = 12                                            ; size = 4
__Dest$ = 16                                            ; size = 4
?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z PROC         ; std::ctype<char>::do_widen, COMDAT
; _this$ = ecx

; 2545 :              {   // widen chars in [_First, _Last)

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2546 :              _DEBUG_RANGE_PTR(_First, _Last, _Dest);
; 2547 :              _CSTD memcpy(_Dest, _First, _Last - _First);

  00007 8b 45 0c   mov         eax, DWORD PTR __Last$[ebp]
  0000a 2b 45 08   sub         eax, DWORD PTR __First$[ebp]
  0000d 50                 push    eax
  0000e 8b 4d 08   mov         ecx, DWORD PTR __First$[ebp]
  00011 51                 push    ecx
  00012 8b 55 10   mov         edx, DWORD PTR __Dest$[ebp]
  00015 52                 push    edx
  00016 e8 00 00 00 00     call    _memcpy
  0001b 83 c4 0c   add         esp, 12                        ; 0000000cH

; 2548 :              return (_Last);

  0001e 8b 45 0c   mov         eax, DWORD PTR __Last$[ebp]

; 2549 :              }

  00021 8b e5        mov         esp, ebp
  00023 5d                 pop     ebp
  00024 c2 0c 00   ret         12           ; 0000000cH
?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z ENDP         ; std::ctype<char>::do_widen
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;       COMDAT ?do_widen@?$ctype@D@std@@MBEDD@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Byte$ = 8                                   ; size = 1
?do_widen@?$ctype@D@std@@MBEDD@Z PROC             ; std::ctype<char>::do_widen, COMDAT
; _this$ = ecx

; 2539 :              {   // widen char

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2540 :              return (_Byte);

  00007 8a 45 08   mov         al, BYTE PTR __Byte$[ebp]

; 2541 :              }

  0000a 8b e5        mov         esp, ebp
  0000c 5d                 pop     ebp
  0000d c2 04 00   ret         4
?do_widen@?$ctype@D@std@@MBEDD@Z ENDP             ; std::ctype<char>::do_widen
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;       COMDAT ?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__First$ = 8                                            ; size = 4
__Last$ = 12                                            ; size = 4
?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z PROC      ; std::ctype<char>::do_toupper, COMDAT
; _this$ = ecx

; 2531 :              {   // convert [_First, _Last) in place to upper case

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2532 :              _DEBUG_RANGE((const _Elem *)_First, _Last);
; 2533 :              for (; _First != _Last; ++_First)

  00007 eb 09        jmp         SHORT $LN4@do_toupper
$LN2@do_toupper:
  00009 8b 45 08   mov         eax, DWORD PTR __First$[ebp]
  0000c 83 c0 01   add         eax, 1
  0000f 89 45 08   mov         DWORD PTR __First$[ebp], eax
$LN4@do_toupper:
  00012 8b 4d 08   mov         ecx, DWORD PTR __First$[ebp]
  00015 3b 4d 0c   cmp         ecx, DWORD PTR __Last$[ebp]
  00018 74 1d        je  SHORT $LN3@do_toupper

; 2534 :                  *_First = (_Elem)_Toupper((unsigned char)*_First, &_Ctype);

  0001a 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  0001d 83 c2 08   add         edx, 8
  00020 52                 push    edx
  00021 8b 45 08   mov         eax, DWORD PTR __First$[ebp]
  00024 0f b6 08   movzx       ecx, BYTE PTR [eax]
  00027 51                 push    ecx
  00028 e8 00 00 00 00     call    __Toupper
  0002d 83 c4 08   add         esp, 8
  00030 8b 55 08   mov         edx, DWORD PTR __First$[ebp]
  00033 88 02        mov         BYTE PTR [edx], al
  00035 eb d2        jmp         SHORT $LN2@do_toupper
$LN3@do_toupper:

; 2535 :              return ((const _Elem *)_First);

  00037 8b 45 08   mov         eax, DWORD PTR __First$[ebp]

; 2536 :              }

  0003a 8b e5        mov         esp, ebp
  0003c 5d                 pop     ebp
  0003d c2 08 00   ret         8
?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z ENDP      ; std::ctype<char>::do_toupper
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;       COMDAT ?do_toupper@?$ctype@D@std@@MBEDD@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Ch$ = 8                                         ; size = 1
?do_toupper@?$ctype@D@std@@MBEDD@Z PROC       ; std::ctype<char>::do_toupper, COMDAT
; _this$ = ecx

; 2525 :              {   // convert element to upper case

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2526 :              return ((_Elem)_Toupper((unsigned char)_Ch, &_Ctype));

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a 83 c0 08   add         eax, 8
  0000d 50                 push    eax
  0000e 0f b6 4d 08        movzx         ecx, BYTE PTR __Ch$[ebp]
  00012 51                 push    ecx
  00013 e8 00 00 00 00     call    __Toupper
  00018 83 c4 08   add         esp, 8

; 2527 :              }

  0001b 8b e5        mov         esp, ebp
  0001d 5d                 pop     ebp
  0001e c2 04 00   ret         4
?do_toupper@?$ctype@D@std@@MBEDD@Z ENDP       ; std::ctype<char>::do_toupper
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;       COMDAT ?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__First$ = 8                                            ; size = 4
__Last$ = 12                                            ; size = 4
?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z PROC      ; std::ctype<char>::do_tolower, COMDAT
; _this$ = ecx

; 2517 :              {   // convert [_First, _Last) in place to lower case

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2518 :              _DEBUG_RANGE((const _Elem *)_First, _Last);
; 2519 :              for (; _First != _Last; ++_First)

  00007 eb 09        jmp         SHORT $LN4@do_tolower
$LN2@do_tolower:
  00009 8b 45 08   mov         eax, DWORD PTR __First$[ebp]
  0000c 83 c0 01   add         eax, 1
  0000f 89 45 08   mov         DWORD PTR __First$[ebp], eax
$LN4@do_tolower:
  00012 8b 4d 08   mov         ecx, DWORD PTR __First$[ebp]
  00015 3b 4d 0c   cmp         ecx, DWORD PTR __Last$[ebp]
  00018 74 1d        je  SHORT $LN3@do_tolower

; 2520 :                  *_First = (_Elem)_Tolower((unsigned char)*_First, &_Ctype);

  0001a 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  0001d 83 c2 08   add         edx, 8
  00020 52                 push    edx
  00021 8b 45 08   mov         eax, DWORD PTR __First$[ebp]
  00024 0f b6 08   movzx       ecx, BYTE PTR [eax]
  00027 51                 push    ecx
  00028 e8 00 00 00 00     call    __Tolower
  0002d 83 c4 08   add         esp, 8
  00030 8b 55 08   mov         edx, DWORD PTR __First$[ebp]
  00033 88 02        mov         BYTE PTR [edx], al
  00035 eb d2        jmp         SHORT $LN2@do_tolower
$LN3@do_tolower:

; 2521 :              return ((const _Elem *)_First);

  00037 8b 45 08   mov         eax, DWORD PTR __First$[ebp]

; 2522 :              }

  0003a 8b e5        mov         esp, ebp
  0003c 5d                 pop     ebp
  0003d c2 08 00   ret         8
?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z ENDP      ; std::ctype<char>::do_tolower
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;       COMDAT ?do_tolower@?$ctype@D@std@@MBEDD@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Ch$ = 8                                         ; size = 1
?do_tolower@?$ctype@D@std@@MBEDD@Z PROC       ; std::ctype<char>::do_tolower, COMDAT
; _this$ = ecx

; 2511 :              {   // convert element to lower case

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2512 :              return ((_Elem)_Tolower((unsigned char)_Ch, &_Ctype));

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a 83 c0 08   add         eax, 8
  0000d 50                 push    eax
  0000e 0f b6 4d 08        movzx         ecx, BYTE PTR __Ch$[ebp]
  00012 51                 push    ecx
  00013 e8 00 00 00 00     call    __Tolower
  00018 83 c4 08   add         esp, 8

; 2513 :              }

  0001b 8b e5        mov         esp, ebp
  0001d 5d                 pop     ebp
  0001e c2 04 00   ret         4
?do_tolower@?$ctype@D@std@@MBEDD@Z ENDP       ; std::ctype<char>::do_tolower
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;       COMDAT ?_Tidy@?$ctype@D@std@@IAEXXZ
_TEXT   SEGMENT
$T1 = -8                                                ; size = 4
_this$ = -4                                   ; size = 4
?_Tidy@?$ctype@D@std@@IAEXXZ PROC                 ; std::ctype<char>::_Tidy, COMDAT
; _this$ = ecx

; 2501 :              {   // free any allocated storage

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2502 :              if (0 < _Ctype._Delfl)

  00009 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000c 83 78 10 00        cmp   DWORD PTR [eax+16], 0
  00010 7e 11        jle         SHORT $LN2@Tidy

; 2503 :                  _CSTD free((void *)_Ctype._Table);

  00012 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00015 8b 51 0c   mov         edx, DWORD PTR [ecx+12]
  00018 52                 push    edx
  00019 e8 00 00 00 00     call    _free
  0001e 83 c4 04   add         esp, 4
  00021 eb 1e        jmp         SHORT $LN3@Tidy
$LN2@Tidy:

; 2504 :              else if (_Ctype._Delfl < 0)

  00023 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00026 83 78 10 00        cmp   DWORD PTR [eax+16], 0
  0002a 7d 15        jge         SHORT $LN3@Tidy

; 2505 :                  delete[] _Ctype._Table;

  0002c 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0002f 8b 51 0c   mov         edx, DWORD PTR [ecx+12]
  00032 89 55 f8   mov         DWORD PTR $T1[ebp], edx
  00035 8b 45 f8   mov         eax, DWORD PTR $T1[ebp]
  00038 50                 push    eax
  00039 e8 00 00 00 00     call    ??_V@YAXPAX@Z                ; operator delete[]
  0003e 83 c4 04   add         esp, 4
$LN3@Tidy:

; 2506 :
; 2507 :              _CSTD free(_Ctype._LocaleName);

  00041 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00044 8b 51 14   mov         edx, DWORD PTR [ecx+20]
  00047 52                 push    edx
  00048 e8 00 00 00 00     call    _free
  0004d 83 c4 04   add         esp, 4

; 2508 :              }

  00050 8b e5        mov         esp, ebp
  00052 5d                 pop     ebp
  00053 c3                 ret     0
?_Tidy@?$ctype@D@std@@IAEXXZ ENDP                 ; std::ctype<char>::_Tidy
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;       COMDAT ?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z
_TEXT   SEGMENT
$T1 = -20                                         ; size = 16
_this$ = -4                                   ; size = 4
__Lobj$ = 8                                   ; size = 4
?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z PROC   ; std::ctype<char>::_Init, COMDAT
; _this$ = ecx

; 2496 :              {   // initialize from _Lobj

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 14   sub         esp, 20                        ; 00000014H
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2497 :              _Ctype = _Lobj._Getctype();

  00009 8d 45 ec   lea         eax, DWORD PTR $T1[ebp]
  0000c 50                 push    eax
  0000d 8b 4d 08   mov         ecx, DWORD PTR __Lobj$[ebp]
  00010 e8 00 00 00 00     call    ?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ ; std::_Locinfo::_Getctype
  00015 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00018 83 c1 08   add         ecx, 8
  0001b 8b 10        mov         edx, DWORD PTR [eax]
  0001d 89 11        mov         DWORD PTR [ecx], edx
  0001f 8b 50 04   mov         edx, DWORD PTR [eax+4]
  00022 89 51 04   mov         DWORD PTR [ecx+4], edx
  00025 8b 50 08   mov         edx, DWORD PTR [eax+8]
  00028 89 51 08   mov         DWORD PTR [ecx+8], edx
  0002b 8b 40 0c   mov         eax, DWORD PTR [eax+12]
  0002e 89 41 0c   mov         DWORD PTR [ecx+12], eax

; 2498 :              }

  00031 8b e5        mov         esp, ebp
  00033 5d                 pop     ebp
  00034 c2 04 00   ret         4
?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z ENDP   ; std::ctype<char>::_Init
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;       COMDAT ??1?$ctype@D@std@@MAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??1?$ctype@D@std@@MAE@XZ PROC                     ; std::ctype<char>::~ctype<char>, COMDAT
; _this$ = ecx

; 2491 :              {   // destroy the object

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a c7 00 00 00 00
        00           mov     DWORD PTR [eax], OFFSET ??_7?$ctype@D@std@@6B@

; 2492 :              _Tidy();

  00010 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00013 e8 00 00 00 00     call    ?_Tidy@?$ctype@D@std@@IAEXXZ ; std::ctype<char>::_Tidy

; 2493 :              }

  00018 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001b e8 00 00 00 00     call    ??1ctype_base@std@@UAE@XZ ; std::ctype_base::~ctype_base
  00020 8b e5        mov         esp, ebp
  00022 5d                 pop     ebp
  00023 c3                 ret     0
??1?$ctype@D@std@@MAE@XZ ENDP                     ; std::ctype<char>::~ctype<char>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;       COMDAT ?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT   SEGMENT
$T1 = -64                                         ; size = 52
tv86 = -12                                          ; size = 4
$T2 = -8                                                ; size = 4
$T3 = -4                                                ; size = 4
__Ppf$ = 8                                          ; size = 4
__Ploc$ = 12                                            ; size = 4
?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::ctype<char>::_Getcat, COMDAT

; 2468 :              {   // return locale category mask and construct standard facet

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 40   sub         esp, 64                        ; 00000040H
  00006 c7 45 fc 00 00
        00 00          mov         DWORD PTR $T3[ebp], 0

; 2469 :              if (_Ppf != 0 && *_Ppf == 0)

  0000d 83 7d 08 00        cmp   DWORD PTR __Ppf$[ebp], 0
  00011 74 63        je  SHORT $LN2@Getcat
  00013 8b 45 08   mov         eax, DWORD PTR __Ppf$[ebp]
  00016 83 38 00   cmp         DWORD PTR [eax], 0
  00019 75 5b        jne         SHORT $LN2@Getcat

; 2470 :                  *_Ppf = new ctype<_Elem>(

  0001b 6a 18        push        24             ; 00000018H
  0001d e8 00 00 00 00     call    ??2@YAPAXI@Z   ; operator new
  00022 83 c4 04   add         esp, 4
  00025 89 45 f8   mov         DWORD PTR $T2[ebp], eax
  00028 83 7d f8 00        cmp   DWORD PTR $T2[ebp], 0
  0002c 74 25        je  SHORT $LN4@Getcat
  0002e 6a 00        push        0
  00030 8b 4d 0c   mov         ecx, DWORD PTR __Ploc$[ebp]
  00033 e8 00 00 00 00     call    ?c_str@locale@std@@QBEPBDXZ ; std::locale::c_str
  00038 50                 push    eax
  00039 8d 4d c0   lea         ecx, DWORD PTR $T1[ebp]
  0003c e8 00 00 00 00     call    ??0_Locinfo@std@@QAE@PBD@Z ; std::_Locinfo::_Locinfo
  00041 83 4d fc 01        or    DWORD PTR $T3[ebp], 1
  00045 50                 push    eax
  00046 8b 4d f8   mov         ecx, DWORD PTR $T2[ebp]
  00049 e8 00 00 00 00     call    ??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z ; std::ctype<char>::ctype<char>
  0004e 89 45 f4   mov         DWORD PTR tv86[ebp], eax
  00051 eb 07        jmp         SHORT $LN5@Getcat
$LN4@Getcat:
  00053 c7 45 f4 00 00
        00 00          mov         DWORD PTR tv86[ebp], 0
$LN5@Getcat:
  0005a 8b 4d 08   mov         ecx, DWORD PTR __Ppf$[ebp]
  0005d 8b 55 f4   mov         edx, DWORD PTR tv86[ebp]
  00060 89 11        mov         DWORD PTR [ecx], edx
  00062 8b 45 fc   mov         eax, DWORD PTR $T3[ebp]
  00065 83 e0 01   and         eax, 1
  00068 74 0c        je  SHORT $LN2@Getcat
  0006a 83 65 fc fe        and   DWORD PTR $T3[ebp], -2     ; fffffffeH
  0006e 8d 4d c0   lea         ecx, DWORD PTR $T1[ebp]
  00071 e8 00 00 00 00     call    ??1_Locinfo@std@@QAE@XZ      ; std::_Locinfo::~_Locinfo
$LN2@Getcat:

; 2471 :                          _Locinfo(_Ploc->c_str()));
; 2472 :              return (_X_CTYPE);

  00076 b8 02 00 00 00     mov     eax, 2

; 2473 :              }

  0007b 8b e5        mov         esp, ebp
  0007d 5d                 pop     ebp
  0007e c3                 ret     0
?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::ctype<char>::_Getcat
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;       COMDAT ??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Lobj$ = 8                                   ; size = 4
__Refs$ = 12                                            ; size = 4
??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z PROC            ; std::ctype<char>::ctype<char>, COMDAT
; _this$ = ecx

; 2462 :              {   // construct from current locale

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2461 :              : ctype_base(_Refs)

  00007 8b 45 0c   mov         eax, DWORD PTR __Refs$[ebp]
  0000a 50                 push    eax
  0000b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000e e8 00 00 00 00     call    ??0ctype_base@std@@QAE@I@Z ; std::ctype_base::ctype_base

; 2462 :              {   // construct from current locale

  00013 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00016 c7 01 00 00 00
        00           mov     DWORD PTR [ecx], OFFSET ??_7?$ctype@D@std@@6B@

; 2463 :              _Init(_Lobj);

  0001c 8b 55 08   mov         edx, DWORD PTR __Lobj$[ebp]
  0001f 52                 push    edx
  00020 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00023 e8 00 00 00 00     call    ?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z ; std::ctype<char>::_Init

; 2464 :              }

  00028 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0002b 8b e5        mov         esp, ebp
  0002d 5d                 pop     ebp
  0002e c2 08 00   ret         8
??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z ENDP            ; std::ctype<char>::ctype<char>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;       COMDAT ?tolower@?$ctype@D@std@@QBEPBDPADPBD@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__First$ = 8                                            ; size = 4
__Last$ = 12                                            ; size = 4
?tolower@?$ctype@D@std@@QBEPBDPADPBD@Z PROC       ; std::ctype<char>::tolower, COMDAT
; _this$ = ecx

; 2400 :              {   // convert [_First, _Last) in place to lower case

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2401 :              return (do_tolower(_First, _Last));

  00007 8b 45 0c   mov         eax, DWORD PTR __Last$[ebp]
  0000a 50                 push    eax
  0000b 8b 4d 08   mov         ecx, DWORD PTR __First$[ebp]
  0000e 51                 push    ecx
  0000f 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  00012 8b 02        mov         eax, DWORD PTR [edx]
  00014 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00017 8b 50 0c   mov         edx, DWORD PTR [eax+12]
  0001a ff d2        call        edx

; 2402 :              }

  0001c 8b e5        mov         esp, ebp
  0001e 5d                 pop     ebp
  0001f c2 08 00   ret         8
?tolower@?$ctype@D@std@@QBEPBDPADPBD@Z ENDP       ; std::ctype<char>::tolower
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;       COMDAT ?tolower@?$ctype@D@std@@QBEDD@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Ch$ = 8                                         ; size = 1
?tolower@?$ctype@D@std@@QBEDD@Z PROC                    ; std::ctype<char>::tolower, COMDAT
; _this$ = ecx

; 2395 :              {   // convert element to lower case

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2396 :              return (do_tolower(_Ch));

  00007 0f b6 45 08        movzx         eax, BYTE PTR __Ch$[ebp]
  0000b 50                 push    eax
  0000c 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000f 8b 11        mov         edx, DWORD PTR [ecx]
  00011 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00014 8b 42 10   mov         eax, DWORD PTR [edx+16]
  00017 ff d0        call        eax

; 2397 :              }

  00019 8b e5        mov         esp, ebp
  0001b 5d                 pop     ebp
  0001c c2 04 00   ret         4
?tolower@?$ctype@D@std@@QBEDD@Z ENDP                    ; std::ctype<char>::tolower
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;       COMDAT ?is@?$ctype@D@std@@QBE_NFD@Z
_TEXT   SEGMENT
_this$ = -8                                   ; size = 4
tv73 = -4                                         ; size = 4
__Maskval$ = 8                                      ; size = 2
__Ch$ = 12                                          ; size = 1
?is@?$ctype@D@std@@QBE_NFD@Z PROC                 ; std::ctype<char>::is, COMDAT
; _this$ = ecx

; 2363 :              {   // test if element fits any mask classifications

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d f8   mov         DWORD PTR _this$[ebp], ecx

; 2364 :              return ((_Ctype._Table[(unsigned char)_Ch] & _Maskval) != 0);

  00009 0f b6 45 0c        movzx         eax, BYTE PTR __Ch$[ebp]
  0000d 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00010 8b 51 0c   mov         edx, DWORD PTR [ecx+12]
  00013 0f bf 04 42        movsx         eax, WORD PTR [edx+eax*2]
  00017 0f bf 4d 08        movsx         ecx, WORD PTR __Maskval$[ebp]
  0001b 23 c1        and         eax, ecx
  0001d 74 09        je  SHORT $LN3@is
  0001f c7 45 fc 01 00
        00 00          mov         DWORD PTR tv73[ebp], 1
  00026 eb 07        jmp         SHORT $LN4@is
$LN3@is:
  00028 c7 45 fc 00 00
        00 00          mov         DWORD PTR tv73[ebp], 0
$LN4@is:
  0002f 8a 45 fc   mov         al, BYTE PTR tv73[ebp]

; 2365 :              }

  00032 8b e5        mov         esp, ebp
  00034 5d                 pop     ebp
  00035 c2 08 00   ret         8
?is@?$ctype@D@std@@QBE_NFD@Z ENDP                 ; std::ctype<char>::is
_TEXT   ENDS
; Function compile flags: /Odtp
;       COMDAT ??_Gctype_base@std@@UAEPAXI@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
___flags$ = 8                                     ; size = 4
??_Gctype_base@std@@UAEPAXI@Z PROC                  ; std::ctype_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ??1ctype_base@std@@UAE@XZ ; std::ctype_base::~ctype_base
  0000f 8b 45 08   mov         eax, DWORD PTR ___flags$[ebp]
  00012 83 e0 01   and         eax, 1
  00015 74 0e        je  SHORT $LN2@scalar
  00017 6a 08        push        8
  00019 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001c 51                 push    ecx
  0001d e8 00 00 00 00     call    ??3@YAXPAXI@Z                ; operator delete
  00022 83 c4 08   add         esp, 8
$LN2@scalar:
  00025 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00028 8b e5        mov         esp, ebp
  0002a 5d                 pop     ebp
  0002b c2 04 00   ret         4
??_Gctype_base@std@@UAEPAXI@Z ENDP                  ; std::ctype_base::`scalar deleting destructor'
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;       COMDAT ??1ctype_base@std@@UAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??1ctype_base@std@@UAE@XZ PROC                      ; std::ctype_base::~ctype_base, COMDAT
; _this$ = ecx

; 2107 :              {   // destroy the object

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a c7 00 00 00 00
        00           mov     DWORD PTR [eax], OFFSET ??_7ctype_base@std@@6B@

; 2108 :              }

  00010 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00013 e8 00 00 00 00     call    ??1facet@locale@std@@MAE@XZ ; std::locale::facet::~facet
  00018 8b e5        mov         esp, ebp
  0001a 5d                 pop     ebp
  0001b c3                 ret     0
??1ctype_base@std@@UAE@XZ ENDP                      ; std::ctype_base::~ctype_base
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;       COMDAT ??0ctype_base@std@@QAE@I@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Refs$ = 8                                   ; size = 4
??0ctype_base@std@@QAE@I@Z PROC               ; std::ctype_base::ctype_base, COMDAT
; _this$ = ecx

; 2103 :              {   // default constructor

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2102 :              : locale::facet(_Refs)

  00007 8b 45 08   mov         eax, DWORD PTR __Refs$[ebp]
  0000a 50                 push    eax
  0000b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000e e8 00 00 00 00     call    ??0facet@locale@std@@IAE@I@Z ; std::locale::facet::facet

; 2103 :              {   // default constructor

  00013 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00016 c7 01 00 00 00
        00           mov     DWORD PTR [ecx], OFFSET ??_7ctype_base@std@@6B@

; 2104 :              }

  0001c 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0001f 8b e5        mov         esp, ebp
  00021 5d                 pop     ebp
  00022 c2 04 00   ret         4
??0ctype_base@std@@QAE@I@Z ENDP               ; std::ctype_base::ctype_base
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;       COMDAT ?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z
_TEXT   SEGMENT
tv83 = -20                                          ; size = 4
__Ptr0$1 = -16                                      ; size = 4
__Facptr$ = -12                               ; size = 4
tv71 = -8                                         ; size = 4
_this$ = -4                                   ; size = 4
__Id$ = 8                                         ; size = 4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z PROC      ; std::locale::_Getfacet, COMDAT
; _this$ = ecx

; 458  :              {   // look up a facet in locale object

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 14   sub         esp, 20                        ; 00000014H
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 459  :              const facet *_Facptr = _Id < _Ptr->_Facetcount

  00009 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000c 8b 48 04   mov         ecx, DWORD PTR [eax+4]
  0000f 8b 55 08   mov         edx, DWORD PTR __Id$[ebp]
  00012 3b 51 0c   cmp         edx, DWORD PTR [ecx+12]
  00015 73 14        jae         SHORT $LN6@Getfacet
  00017 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0001a 8b 48 04   mov         ecx, DWORD PTR [eax+4]
  0001d 8b 51 08   mov         edx, DWORD PTR [ecx+8]
  00020 8b 45 08   mov         eax, DWORD PTR __Id$[ebp]
  00023 8b 0c 82   mov         ecx, DWORD PTR [edx+eax*4]
  00026 89 4d f8   mov         DWORD PTR tv71[ebp], ecx
  00029 eb 07        jmp         SHORT $LN7@Getfacet
$LN6@Getfacet:
  0002b c7 45 f8 00 00
        00 00          mov         DWORD PTR tv71[ebp], 0
$LN7@Getfacet:
  00032 8b 55 f8   mov         edx, DWORD PTR tv71[ebp]
  00035 89 55 f4   mov         DWORD PTR __Facptr$[ebp], edx

; 460  :                  ? _Ptr->_Facetvec[_Id] : 0;     // null if id off end
; 461  :              if (_Facptr != 0 || !_Ptr->_Xparent)

  00038 83 7d f4 00        cmp   DWORD PTR __Facptr$[ebp], 0
  0003c 75 0e        jne         SHORT $LN4@Getfacet
  0003e 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00041 8b 48 04   mov         ecx, DWORD PTR [eax+4]
  00044 0f b6 51 14        movzx         edx, BYTE PTR [ecx+20]
  00048 85 d2        test        edx, edx
  0004a 75 07        jne         SHORT $LN2@Getfacet
$LN4@Getfacet:

; 462  :                  return (_Facptr);       // found facet or not transparent

  0004c 8b 45 f4   mov         eax, DWORD PTR __Facptr$[ebp]
  0004f eb 30        jmp         SHORT $LN1@Getfacet

; 463  :              else

  00051 eb 2e        jmp         SHORT $LN1@Getfacet
$LN2@Getfacet:

; 464  :                  {       // look in current locale
; 465  :                  locale::_Locimp *_Ptr0 = _Getgloballocale();

  00053 e8 00 00 00 00     call    ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
  00058 89 45 f0   mov         DWORD PTR __Ptr0$1[ebp], eax

; 466  :                  return (_Id < _Ptr0->_Facetcount

  0005b 8b 45 f0   mov         eax, DWORD PTR __Ptr0$1[ebp]
  0005e 8b 4d 08   mov         ecx, DWORD PTR __Id$[ebp]
  00061 3b 48 0c   cmp         ecx, DWORD PTR [eax+12]
  00064 73 11        jae         SHORT $LN8@Getfacet
  00066 8b 55 f0   mov         edx, DWORD PTR __Ptr0$1[ebp]
  00069 8b 42 08   mov         eax, DWORD PTR [edx+8]
  0006c 8b 4d 08   mov         ecx, DWORD PTR __Id$[ebp]
  0006f 8b 14 88   mov         edx, DWORD PTR [eax+ecx*4]
  00072 89 55 ec   mov         DWORD PTR tv83[ebp], edx
  00075 eb 07        jmp         SHORT $LN9@Getfacet
$LN8@Getfacet:
  00077 c7 45 ec 00 00
        00 00          mov         DWORD PTR tv83[ebp], 0
$LN9@Getfacet:
  0007e 8b 45 ec   mov         eax, DWORD PTR tv83[ebp]
$LN1@Getfacet:

; 467  :                          ? _Ptr0->_Facetvec[_Id] // get from current locale
; 468  :                          : 0);   // no entry in current locale
; 469  :                  }
; 470  :              }

  00081 8b e5        mov         esp, ebp
  00083 5d                 pop     ebp
  00084 c2 04 00   ret         4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ENDP      ; std::locale::_Getfacet
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;       COMDAT ?c_str@locale@std@@QBEPBDXZ
_TEXT   SEGMENT
tv70 = -8                                         ; size = 4
_this$ = -4                                   ; size = 4
?c_str@locale@std@@QBEPBDXZ PROC                        ; std::locale::c_str, COMDAT
; _this$ = ecx

; 453  :              {   // return locale name as NTBS

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 454  :              return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());

  00009 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000c 83 78 04 00        cmp   DWORD PTR [eax+4], 0
  00010 75 09        jne         SHORT $LN3@c_str
  00012 c7 45 f8 00 00
        00 00          mov         DWORD PTR tv70[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
  00019 eb 11        jmp         SHORT $LN4@c_str
$LN3@c_str:
  0001b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001e 8b 49 04   mov         ecx, DWORD PTR [ecx+4]
  00021 83 c1 18   add         ecx, 24                        ; 00000018H
  00024 e8 00 00 00 00     call    ?c_str@?$_Yarn@D@std@@QBEPBDXZ ; std::_Yarn<char>::c_str
  00029 89 45 f8   mov         DWORD PTR tv70[ebp], eax
$LN4@c_str:
  0002c 8b 45 f8   mov         eax, DWORD PTR tv70[ebp]

; 455  :              }

  0002f 8b e5        mov         esp, ebp
  00031 5d                 pop     ebp
  00032 c3                 ret     0
?c_str@locale@std@@QBEPBDXZ ENDP                        ; std::locale::c_str
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;       COMDAT ?name@locale@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT   SEGMENT
$T1 = -68                                         ; size = 4
tv81 = -64                                          ; size = 4
_this$ = -60                                            ; size = 4
$T2 = -56                                         ; size = 4
$T3 = -52                                         ; size = 24
$T4 = -28                                         ; size = 24
__$ArrayPad$ = -4                                 ; size = 4
___$ReturnUdt$ = 8                                  ; size = 4
?name@locale@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::locale::name, COMDAT
; _this$ = ecx

; 448  :              {   // return locale name

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 44   sub         esp, 68                        ; 00000044H
  00006 a1 00 00 00 00     mov     eax, DWORD PTR ___security_cookie
  0000b 33 c5        xor         eax, ebp
  0000d 89 45 fc   mov         DWORD PTR __$ArrayPad$[ebp], eax
  00010 89 4d c4   mov         DWORD PTR _this$[ebp], ecx
  00013 c7 45 c8 00 00
        00 00          mov         DWORD PTR $T2[ebp], 0

; 449  :              return (_Ptr == 0 ? string() : _Ptr->_Name.c_str());

  0001a 8b 45 c4   mov         eax, DWORD PTR _this$[ebp]
  0001d 83 78 04 00        cmp   DWORD PTR [eax+4], 0
  00021 75 11        jne         SHORT $LN3@name
  00023 8d 4d cc   lea         ecx, DWORD PTR $T3[ebp]
  00026 e8 00 00 00 00     call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0002b 83 4d c8 01        or    DWORD PTR $T2[ebp], 1
  0002f 89 45 c0   mov         DWORD PTR tv81[ebp], eax
  00032 eb 1e        jmp         SHORT $LN4@name
$LN3@name:
  00034 8b 4d c4   mov         ecx, DWORD PTR _this$[ebp]
  00037 8b 49 04   mov         ecx, DWORD PTR [ecx+4]
  0003a 83 c1 18   add         ecx, 24                        ; 00000018H
  0003d e8 00 00 00 00     call    ?c_str@?$_Yarn@D@std@@QBEPBDXZ ; std::_Yarn<char>::c_str
  00042 50                 push    eax
  00043 8d 4d e4   lea         ecx, DWORD PTR $T4[ebp]
  00046 e8 00 00 00 00     call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0004b 83 4d c8 02        or    DWORD PTR $T2[ebp], 2
  0004f 89 45 c0   mov         DWORD PTR tv81[ebp], eax
$LN4@name:
  00052 8b 55 c0   mov         edx, DWORD PTR tv81[ebp]
  00055 89 55 bc   mov         DWORD PTR $T1[ebp], edx
  00058 8b 45 bc   mov         eax, DWORD PTR $T1[ebp]
  0005b 50                 push    eax
  0005c 8b 4d 08   mov         ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0005f e8 00 00 00 00     call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00064 8b 4d c8   mov         ecx, DWORD PTR $T2[ebp]
  00067 83 e1 02   and         ecx, 2
  0006a 74 0c        je  SHORT $LN5@name
  0006c 83 65 c8 fd        and   DWORD PTR $T2[ebp], -3     ; fffffffdH
  00070 8d 4d e4   lea         ecx, DWORD PTR $T4[ebp]
  00073 e8 00 00 00 00     call    ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN5@name:
  00078 8b 55 c8   mov         edx, DWORD PTR $T2[ebp]
  0007b 83 e2 01   and         edx, 1
  0007e 74 0c        je  SHORT $LN6@name
  00080 83 65 c8 fe        and   DWORD PTR $T2[ebp], -2     ; fffffffeH
  00084 8d 4d cc   lea         ecx, DWORD PTR $T3[ebp]
  00087 e8 00 00 00 00     call    ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN6@name:
  0008c 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]

; 450  :              }

  0008f 8b 4d fc   mov         ecx, DWORD PTR __$ArrayPad$[ebp]
  00092 33 cd        xor         ecx, ebp
  00094 e8 00 00 00 00     call    @__security_check_cookie@4
  00099 8b e5        mov         esp, ebp
  0009b 5d                 pop     ebp
  0009c c2 04 00   ret         4
?name@locale@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::locale::name
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;       COMDAT ??1locale@std@@QAE@XZ
_TEXT   SEGMENT
tv84 = -16                                          ; size = 4
$T1 = -12                                         ; size = 4
$T2 = -8                                                ; size = 4
_this$ = -4                                   ; size = 4
??1locale@std@@QAE@XZ PROC                          ; std::locale::~locale, COMDAT
; _this$ = ecx

; 430  :              {   // destroy the object

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 10   sub         esp, 16                        ; 00000010H
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 431  :              if (_Ptr != 0)

  00009 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000c 83 78 04 00        cmp   DWORD PTR [eax+4], 0
  00010 74 3c        je  SHORT $LN1@locale

; 432  :                  delete _Ptr->_Decref();

  00012 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00015 8b 51 04   mov         edx, DWORD PTR [ecx+4]
  00018 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0001b 8b 12        mov         edx, DWORD PTR [edx]
  0001d 8b 48 04   mov         ecx, DWORD PTR [eax+4]
  00020 8b 42 08   mov         eax, DWORD PTR [edx+8]
  00023 ff d0        call        eax
  00025 89 45 f4   mov         DWORD PTR $T1[ebp], eax
  00028 8b 4d f4   mov         ecx, DWORD PTR $T1[ebp]
  0002b 89 4d f8   mov         DWORD PTR $T2[ebp], ecx
  0002e 83 7d f8 00        cmp   DWORD PTR $T2[ebp], 0
  00032 74 13        je  SHORT $LN4@locale
  00034 6a 01        push        1
  00036 8b 55 f8   mov         edx, DWORD PTR $T2[ebp]
  00039 8b 02        mov         eax, DWORD PTR [edx]
  0003b 8b 4d f8   mov         ecx, DWORD PTR $T2[ebp]
  0003e 8b 10        mov         edx, DWORD PTR [eax]
  00040 ff d2        call        edx
  00042 89 45 f0   mov         DWORD PTR tv84[ebp], eax
  00045 eb 07        jmp         SHORT $LN1@locale
$LN4@locale:
  00047 c7 45 f0 00 00
        00 00          mov         DWORD PTR tv84[ebp], 0
$LN1@locale:

; 433  :              }

  0004e 8b e5        mov         esp, ebp
  00050 5d                 pop     ebp
  00051 c3                 ret     0
??1locale@std@@QAE@XZ ENDP                          ; std::locale::~locale
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;       COMDAT ??0locale@std@@QAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??0locale@std@@QAE@XZ PROC                          ; std::locale::locale, COMDAT
; _this$ = ecx

; 331  :              {   // construct from current locale

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 330  :              : _Ptr(_Init(true))

  00007 6a 01        push        1
  00009 e8 00 00 00 00     call    ?_Init@locale@std@@CAPAV_Locimp@12@_N@Z ; std::locale::_Init
  0000e 83 c4 04   add         esp, 4
  00011 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00014 89 41 04   mov         DWORD PTR [ecx+4], eax

; 332  :              }

  00017 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0001a 8b e5        mov         esp, ebp
  0001c 5d                 pop     ebp
  0001d c3                 ret     0
??0locale@std@@QAE@XZ ENDP                          ; std::locale::locale
_TEXT   ENDS
; Function compile flags: /Odtp
;       COMDAT ??_Gfacet@locale@std@@MAEPAXI@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
___flags$ = 8                                     ; size = 4
??_Gfacet@locale@std@@MAEPAXI@Z PROC                    ; std::locale::facet::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ??1facet@locale@std@@MAE@XZ ; std::locale::facet::~facet
  0000f 8b 45 08   mov         eax, DWORD PTR ___flags$[ebp]
  00012 83 e0 01   and         eax, 1
  00015 74 0e        je  SHORT $LN2@scalar
  00017 6a 08        push        8
  00019 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001c 51                 push    ecx
  0001d e8 00 00 00 00     call    ??3@YAXPAXI@Z                ; operator delete
  00022 83 c4 08   add         esp, 8
$LN2@scalar:
  00025 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00028 8b e5        mov         esp, ebp
  0002a 5d                 pop     ebp
  0002b c2 04 00   ret         4
??_Gfacet@locale@std@@MAEPAXI@Z ENDP                    ; std::locale::facet::`scalar deleting destructor'
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;       COMDAT ??1facet@locale@std@@MAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??1facet@locale@std@@MAE@XZ PROC                        ; std::locale::facet::~facet, COMDAT
; _this$ = ecx

; 171  :                  {       // ensure that derived classes can be destroyed properly

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a c7 00 00 00 00
        00           mov     DWORD PTR [eax], OFFSET ??_7facet@locale@std@@6B@

; 172  :                  }

  00010 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00013 e8 00 00 00 00     call    ??1_Facet_base@std@@UAE@XZ ; std::_Facet_base::~_Facet_base
  00018 8b e5        mov         esp, ebp
  0001a 5d                 pop     ebp
  0001b c3                 ret     0
??1facet@locale@std@@MAE@XZ ENDP                        ; std::locale::facet::~facet
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;       COMDAT ??0facet@locale@std@@IAE@I@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Initrefs$ = 8                               ; size = 4
??0facet@locale@std@@IAE@I@Z PROC                 ; std::locale::facet::facet, COMDAT
; _this$ = ecx

; 165  :              explicit __CLR_OR_THIS_CALL facet(size_t _Initrefs = 0)

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 166  :                  {       // construct with initial reference count

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ??0_Facet_base@std@@QAE@XZ
  0000f 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00012 c7 00 00 00 00
        00           mov     DWORD PTR [eax], OFFSET ??_7facet@locale@std@@6B@

; 167  :                  _Init_atomic_counter(_Myrefs, (_Atomic_integral_t)_Initrefs);

  00018 8b 4d 08   mov         ecx, DWORD PTR __Initrefs$[ebp]
  0001b 51                 push    ecx
  0001c 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  0001f 83 c2 04   add         edx, 4
  00022 52                 push    edx
  00023 e8 00 00 00 00     call    ?_Init_atomic_counter@std@@YAXAAKK@Z ; std::_Init_atomic_counter
  00028 83 c4 08   add         esp, 8

; 168  :                  }

  0002b 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0002e 8b e5        mov         esp, ebp
  00030 5d                 pop     ebp
  00031 c2 04 00   ret         4
??0facet@locale@std@@IAE@I@Z ENDP                 ; std::locale::facet::facet
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;       COMDAT ?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ PROC  ; std::locale::facet::_Decref, COMDAT
; _this$ = ecx

; 154  :                  {       // decrement use count

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 155  :                  if (_MT_DECR(_Myrefs) == 0)

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a 83 c0 04   add         eax, 4
  0000d 83 c9 ff   or  ecx, -1
  00010 f0 0f c1 08        lock   xadd     DWORD PTR [eax], ecx
  00014 49                 dec     ecx
  00015 75 07        jne         SHORT $LN2@Decref

; 156  :                          return (this);

  00017 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0001a eb 04        jmp         SHORT $LN1@Decref

; 157  :                  else

  0001c eb 02        jmp         SHORT $LN1@Decref
$LN2@Decref:

; 158  :                          return (0);

  0001e 33 c0        xor         eax, eax
$LN1@Decref:

; 159  :                  }

  00020 8b e5        mov         esp, ebp
  00022 5d                 pop     ebp
  00023 c3                 ret     0
?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ ENDP  ; std::locale::facet::_Decref
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;       COMDAT ?_Incref@facet@locale@std@@UAEXXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Incref@facet@locale@std@@UAEXXZ PROC              ; std::locale::facet::_Incref, COMDAT
; _this$ = ecx

; 149  :                  {       // increment use count

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 150  :                  _MT_INCR(_Myrefs);

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a 83 c0 04   add         eax, 4
  0000d f0 ff 00   lock         inc  DWORD PTR [eax]

; 151  :                  }

  00010 8b e5        mov         esp, ebp
  00012 5d                 pop     ebp
  00013 c3                 ret     0
?_Incref@facet@locale@std@@UAEXXZ ENDP              ; std::locale::facet::_Incref
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;       COMDAT ??Bid@locale@std@@QAEIXZ
_TEXT   SEGMENT
__Lock$1 = -8                                     ; size = 4
_this$ = -4                                   ; size = 4
??Bid@locale@std@@QAEIXZ PROC                     ; std::locale::id::operator unsigned int, COMDAT
; _this$ = ecx

; 114  :                  {       // get stamp, with lazy allocation

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 115  :                  if (_Id == 0)

  00009 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000c 83 38 00   cmp         DWORD PTR [eax], 0
  0000f 75 34        jne         SHORT $LN2@operator

; 116  :                          {       // still zero, allocate stamp
; 117  :                          _BEGIN_LOCK(_LOCK_LOCALE)

  00011 6a 00        push        0
  00013 8d 4d f8   lea         ecx, DWORD PTR __Lock$1[ebp]
  00016 e8 00 00 00 00     call    ??0_Lockit@std@@QAE@H@Z      ; std::_Lockit::_Lockit

; 118  :                                  if (_Id == 0)

  0001b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001e 83 39 00   cmp         DWORD PTR [ecx], 0
  00021 75 1a        jne         SHORT $LN3@operator

; 119  :                                          _Id = ++_Id_cnt;

  00023 8b 15 00 00 00
        00           mov     edx, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
  00029 83 c2 01   add         edx, 1
  0002c 89 15 00 00 00
        00           mov     DWORD PTR ?_Id_cnt@id@locale@std@@0HA, edx ; std::locale::id::_Id_cnt
  00032 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00035 8b 0d 00 00 00
        00           mov     ecx, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
  0003b 89 08        mov         DWORD PTR [eax], ecx
$LN3@operator:

; 120  :                          _END_LOCK()

  0003d 8d 4d f8   lea         ecx, DWORD PTR __Lock$1[ebp]
  00040 e8 00 00 00 00     call    ??1_Lockit@std@@QAE@XZ       ; std::_Lockit::~_Lockit
$LN2@operator:

; 121  :                          }
; 122  :                  return (_Id);

  00045 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  00048 8b 02        mov         eax, DWORD PTR [edx]

; 123  :                  }

  0004a 8b e5        mov         esp, ebp
  0004c 5d                 pop     ebp
  0004d c3                 ret     0
??Bid@locale@std@@QAEIXZ ENDP                     ; std::locale::id::operator unsigned int
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;       COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Val$ = 8                                          ; size = 4
??0id@locale@std@@QAE@I@Z PROC                      ; std::locale::id::id, COMDAT
; _this$ = ecx

; 110  :                  {       // construct with specified stamp value

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 109  :                  : _Id(_Val)

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a 8b 4d 08   mov         ecx, DWORD PTR __Val$[ebp]
  0000d 89 08        mov         DWORD PTR [eax], ecx

; 111  :                  }

  0000f 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00012 8b e5        mov         esp, ebp
  00014 5d                 pop     ebp
  00015 c2 04 00   ret         4
??0id@locale@std@@QAE@I@Z ENDP                      ; std::locale::id::id
_TEXT   ENDS
; Function compile flags: /Odtp
;       COMDAT ??_G_Facet_base@std@@UAEPAXI@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
___flags$ = 8                                     ; size = 4
??_G_Facet_base@std@@UAEPAXI@Z PROC           ; std::_Facet_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ??1_Facet_base@std@@UAE@XZ ; std::_Facet_base::~_Facet_base
  0000f 8b 45 08   mov         eax, DWORD PTR ___flags$[ebp]
  00012 83 e0 01   and         eax, 1
  00015 74 0e        je  SHORT $LN2@scalar
  00017 6a 04        push        4
  00019 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001c 51                 push    ecx
  0001d e8 00 00 00 00     call    ??3@YAXPAXI@Z                ; operator delete
  00022 83 c4 08   add         esp, 8
$LN2@scalar:
  00025 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00028 8b e5        mov         esp, ebp
  0002a 5d                 pop     ebp
  0002b c2 04 00   ret         4
??_G_Facet_base@std@@UAEPAXI@Z ENDP           ; std::_Facet_base::`scalar deleting destructor'
_TEXT   ENDS
; Function compile flags: /Odtp
;       COMDAT ??0_Facet_base@std@@QAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??0_Facet_base@std@@QAE@XZ PROC               ; std::_Facet_base::_Facet_base, COMDAT
; _this$ = ecx
  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a c7 00 00 00 00
        00           mov     DWORD PTR [eax], OFFSET ??_7_Facet_base@std@@6B@
  00010 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00013 8b e5        mov         esp, ebp
  00015 5d                 pop     ebp
  00016 c3                 ret     0
??0_Facet_base@std@@QAE@XZ ENDP               ; std::_Facet_base::_Facet_base
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xfacet
;       COMDAT ??1_Facet_base@std@@UAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??1_Facet_base@std@@UAE@XZ PROC               ; std::_Facet_base::~_Facet_base, COMDAT
; _this$ = ecx

; 24   :              {   // ensure that derived classes can be destroyed properly

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a c7 00 00 00 00
        00           mov     DWORD PTR [eax], OFFSET ??_7_Facet_base@std@@6B@

; 25   :              }

  00010 8b e5        mov         esp, ebp
  00012 5d                 pop     ebp
  00013 c3                 ret     0
??1_Facet_base@std@@UAE@XZ ENDP               ; std::_Facet_base::~_Facet_base
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocinfo
;       COMDAT ??$_LStrxfrm@D@std@@YAIPAD0PBD1PBU_Collvec@@@Z
_TEXT   SEGMENT
__First1$ = 8                                     ; size = 4
__Last1$ = 12                                     ; size = 4
__First2$ = 16                                      ; size = 4
__Last2$ = 20                                     ; size = 4
__Vector$ = 24                                      ; size = 4
??$_LStrxfrm@D@std@@YAIPAD0PBD1PBU_Collvec@@@Z PROC     ; std::_LStrxfrm<char>, COMDAT

; 284  :        {     // perform locale-specific transform of chars [_First1, _Last1)

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 285  :        return (_Strxfrm(_First1, _Last1, _First2, _Last2, _Vector));

  00003 8b 45 18   mov         eax, DWORD PTR __Vector$[ebp]
  00006 50                 push    eax
  00007 8b 4d 14   mov         ecx, DWORD PTR __Last2$[ebp]
  0000a 51                 push    ecx
  0000b 8b 55 10   mov         edx, DWORD PTR __First2$[ebp]
  0000e 52                 push    edx
  0000f 8b 45 0c   mov         eax, DWORD PTR __Last1$[ebp]
  00012 50                 push    eax
  00013 8b 4d 08   mov         ecx, DWORD PTR __First1$[ebp]
  00016 51                 push    ecx
  00017 e8 00 00 00 00     call    __Strxfrm
  0001c 83 c4 14   add         esp, 20                        ; 00000014H

; 286  :        }

  0001f 5d                 pop     ebp
  00020 c3                 ret     0
??$_LStrxfrm@D@std@@YAIPAD0PBD1PBU_Collvec@@@Z ENDP     ; std::_LStrxfrm<char>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocinfo
;       COMDAT ??$_LStrcoll@D@std@@YAHPBD000PBU_Collvec@@@Z
_TEXT   SEGMENT
__First1$ = 8                                     ; size = 4
__Last1$ = 12                                     ; size = 4
__First2$ = 16                                      ; size = 4
__Last2$ = 20                                     ; size = 4
__Vector$ = 24                                      ; size = 4
??$_LStrcoll@D@std@@YAHPBD000PBU_Collvec@@@Z PROC       ; std::_LStrcoll<char>, COMDAT

; 254  :        {     // perform locale-specific comparison of char sequences

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 255  :        return (_Strcoll(_First1, _Last1, _First2, _Last2, _Vector));

  00003 8b 45 18   mov         eax, DWORD PTR __Vector$[ebp]
  00006 50                 push    eax
  00007 8b 4d 14   mov         ecx, DWORD PTR __Last2$[ebp]
  0000a 51                 push    ecx
  0000b 8b 55 10   mov         edx, DWORD PTR __First2$[ebp]
  0000e 52                 push    edx
  0000f 8b 45 0c   mov         eax, DWORD PTR __Last1$[ebp]
  00012 50                 push    eax
  00013 8b 4d 08   mov         ecx, DWORD PTR __First1$[ebp]
  00016 51                 push    ecx
  00017 e8 00 00 00 00     call    __Strcoll
  0001c 83 c4 14   add         esp, 20                        ; 00000014H

; 256  :        }

  0001f 5d                 pop     ebp
  00020 c3                 ret     0
??$_LStrcoll@D@std@@YAHPBD000PBU_Collvec@@@Z ENDP       ; std::_LStrcoll<char>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ?_Tidy@?$_Yarn@_W@std@@AAEXXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Tidy@?$_Yarn@_W@std@@AAEXXZ PROC                  ; std::_Yarn<wchar_t>::_Tidy, COMDAT
; _this$ = ecx

; 3688 :              {   // discard any string

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 3689 :              if (_Myptr != 0)

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a 83 38 00   cmp         DWORD PTR [eax], 0
  0000d 74 0e        je  SHORT $LN2@Tidy

; 3690 :
; 3691 :  #ifdef _DEBUG
; 3692 :                  _free_dbg(_Myptr, _CRT_BLOCK);
; 3693 :
; 3694 :  #else /* _DEBUG */
; 3695 :                  _CSTD free(_Myptr);

  0000f 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00012 8b 11        mov         edx, DWORD PTR [ecx]
  00014 52                 push    edx
  00015 e8 00 00 00 00     call    _free
  0001a 83 c4 04   add         esp, 4
$LN2@Tidy:

; 3696 :  #endif /* _DEBUG */
; 3697 :
; 3698 :              _Myptr = 0;

  0001d 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00020 c7 00 00 00 00
        00           mov     DWORD PTR [eax], 0

; 3699 :              }

  00026 8b e5        mov         esp, ebp
  00028 5d                 pop     ebp
  00029 c3                 ret     0
?_Tidy@?$_Yarn@_W@std@@AAEXXZ ENDP                  ; std::_Yarn<wchar_t>::_Tidy
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ??1?$_Yarn@_W@std@@QAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??1?$_Yarn@_W@std@@QAE@XZ PROC                      ; std::_Yarn<wchar_t>::~_Yarn<wchar_t>, COMDAT
; _this$ = ecx

; 3662 :              {   // destroy the object

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 3663 :              _Tidy();

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Tidy@?$_Yarn@_W@std@@AAEXXZ ; std::_Yarn<wchar_t>::_Tidy

; 3664 :              }

  0000f 8b e5        mov         esp, ebp
  00011 5d                 pop     ebp
  00012 c3                 ret     0
??1?$_Yarn@_W@std@@QAE@XZ ENDP                      ; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ??0?$_Yarn@_W@std@@QAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??0?$_Yarn@_W@std@@QAE@XZ PROC                      ; std::_Yarn<wchar_t>::_Yarn<wchar_t>, COMDAT
; _this$ = ecx

; 3613 :              {   // default construct

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 3612 :              : _Myptr(0), _Nul(0)

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a c7 00 00 00 00
        00           mov     DWORD PTR [eax], 0
  00010 33 c9        xor         ecx, ecx
  00012 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  00015 66 89 4a 04        mov   WORD PTR [edx+4], cx

; 3614 :              }

  00019 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0001c 8b e5        mov         esp, ebp
  0001e 5d                 pop     ebp
  0001f c3                 ret     0
??0?$_Yarn@_W@std@@QAE@XZ ENDP                      ; std::_Yarn<wchar_t>::_Yarn<wchar_t>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ?_Tidy@?$_Yarn@D@std@@AAEXXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Tidy@?$_Yarn@D@std@@AAEXXZ PROC                 ; std::_Yarn<char>::_Tidy, COMDAT
; _this$ = ecx

; 3688 :              {   // discard any string

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 3689 :              if (_Myptr != 0)

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a 83 38 00   cmp         DWORD PTR [eax], 0
  0000d 74 0e        je  SHORT $LN2@Tidy

; 3690 :
; 3691 :  #ifdef _DEBUG
; 3692 :                  _free_dbg(_Myptr, _CRT_BLOCK);
; 3693 :
; 3694 :  #else /* _DEBUG */
; 3695 :                  _CSTD free(_Myptr);

  0000f 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00012 8b 11        mov         edx, DWORD PTR [ecx]
  00014 52                 push    edx
  00015 e8 00 00 00 00     call    _free
  0001a 83 c4 04   add         esp, 4
$LN2@Tidy:

; 3696 :  #endif /* _DEBUG */
; 3697 :
; 3698 :              _Myptr = 0;

  0001d 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00020 c7 00 00 00 00
        00           mov     DWORD PTR [eax], 0

; 3699 :              }

  00026 8b e5        mov         esp, ebp
  00028 5d                 pop     ebp
  00029 c3                 ret     0
?_Tidy@?$_Yarn@D@std@@AAEXXZ ENDP                 ; std::_Yarn<char>::_Tidy
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ?c_str@?$_Yarn@D@std@@QBEPBDXZ
_TEXT   SEGMENT
tv68 = -8                                         ; size = 4
_this$ = -4                                   ; size = 4
?c_str@?$_Yarn@D@std@@QBEPBDXZ PROC           ; std::_Yarn<char>::c_str, COMDAT
; _this$ = ecx

; 3672 :              {   // return NTBS

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 3673 :              return (_Myptr != 0 ? _Myptr : &_Nul);

  00009 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000c 83 38 00   cmp         DWORD PTR [eax], 0
  0000f 74 0a        je  SHORT $LN3@c_str
  00011 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00014 8b 11        mov         edx, DWORD PTR [ecx]
  00016 89 55 f8   mov         DWORD PTR tv68[ebp], edx
  00019 eb 09        jmp         SHORT $LN4@c_str
$LN3@c_str:
  0001b 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0001e 83 c0 04   add         eax, 4
  00021 89 45 f8   mov         DWORD PTR tv68[ebp], eax
$LN4@c_str:
  00024 8b 45 f8   mov         eax, DWORD PTR tv68[ebp]

; 3674 :              }

  00027 8b e5        mov         esp, ebp
  00029 5d                 pop     ebp
  0002a c3                 ret     0
?c_str@?$_Yarn@D@std@@QBEPBDXZ ENDP           ; std::_Yarn<char>::c_str
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ??1?$_Yarn@D@std@@QAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??1?$_Yarn@D@std@@QAE@XZ PROC                     ; std::_Yarn<char>::~_Yarn<char>, COMDAT
; _this$ = ecx

; 3662 :              {   // destroy the object

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 3663 :              _Tidy();

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Tidy@?$_Yarn@D@std@@AAEXXZ ; std::_Yarn<char>::_Tidy

; 3664 :              }

  0000f 8b e5        mov         esp, ebp
  00011 5d                 pop     ebp
  00012 c3                 ret     0
??1?$_Yarn@D@std@@QAE@XZ ENDP                     ; std::_Yarn<char>::~_Yarn<char>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ??0?$_Yarn@D@std@@QAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??0?$_Yarn@D@std@@QAE@XZ PROC                     ; std::_Yarn<char>::_Yarn<char>, COMDAT
; _this$ = ecx

; 3613 :              {   // default construct

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 3612 :              : _Myptr(0), _Nul(0)

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a c7 00 00 00 00
        00           mov     DWORD PTR [eax], 0
  00010 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00013 c6 41 04 00        mov   BYTE PTR [ecx+4], 0

; 3614 :              }

  00017 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0001a 8b e5        mov         esp, ebp
  0001c 5d                 pop     ebp
  0001d c3                 ret     0
??0?$_Yarn@D@std@@QAE@XZ ENDP                     ; std::_Yarn<char>::_Yarn<char>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocinfo
;       COMDAT ?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ
_TEXT   SEGMENT
$T1 = -36                                         ; size = 16
$T2 = -20                                         ; size = 16
_this$ = -4                                   ; size = 4
___$ReturnUdt$ = 8                                  ; size = 4
?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ PROC       ; std::_Locinfo::_Getctype, COMDAT
; _this$ = ecx

; 116  :              {   // return ctype stuff

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 24   sub         esp, 36                        ; 00000024H
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 117  :              return (::_Getctype());

  00009 8d 45 dc   lea         eax, DWORD PTR $T1[ebp]
  0000c 50                 push    eax
  0000d e8 00 00 00 00     call    __Getctype
  00012 83 c4 04   add         esp, 4
  00015 8b 08        mov         ecx, DWORD PTR [eax]
  00017 89 4d ec   mov         DWORD PTR $T2[ebp], ecx
  0001a 8b 50 04   mov         edx, DWORD PTR [eax+4]
  0001d 89 55 f0   mov         DWORD PTR $T2[ebp+4], edx
  00020 8b 48 08   mov         ecx, DWORD PTR [eax+8]
  00023 89 4d f4   mov         DWORD PTR $T2[ebp+8], ecx
  00026 8b 50 0c   mov         edx, DWORD PTR [eax+12]
  00029 89 55 f8   mov         DWORD PTR $T2[ebp+12], edx
  0002c 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]
  0002f 8b 4d ec   mov         ecx, DWORD PTR $T2[ebp]
  00032 89 08        mov         DWORD PTR [eax], ecx
  00034 8b 55 f0   mov         edx, DWORD PTR $T2[ebp+4]
  00037 89 50 04   mov         DWORD PTR [eax+4], edx
  0003a 8b 4d f4   mov         ecx, DWORD PTR $T2[ebp+8]
  0003d 89 48 08   mov         DWORD PTR [eax+8], ecx
  00040 8b 55 f8   mov         edx, DWORD PTR $T2[ebp+12]
  00043 89 50 0c   mov         DWORD PTR [eax+12], edx
  00046 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]

; 118  :              }

  00049 8b e5        mov         esp, ebp
  0004b 5d                 pop     ebp
  0004c c2 04 00   ret         4
?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ ENDP       ; std::_Locinfo::_Getctype
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocinfo
;       COMDAT ?_Getcoll@_Locinfo@std@@QBE?AU_Collvec@@XZ
_TEXT   SEGMENT
$T1 = -12                                         ; size = 8
_this$ = -4                                   ; size = 4
___$ReturnUdt$ = 8                                  ; size = 4
?_Getcoll@_Locinfo@std@@QBE?AU_Collvec@@XZ PROC   ; std::_Locinfo::_Getcoll, COMDAT
; _this$ = ecx

; 111  :              {   // return collation stuff

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 0c   sub         esp, 12                        ; 0000000cH
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 112  :              return (::_Getcoll());

  00009 e8 00 00 00 00     call    __Getcoll
  0000e 89 45 f4   mov         DWORD PTR $T1[ebp], eax
  00011 89 55 f8   mov         DWORD PTR $T1[ebp+4], edx
  00014 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]
  00017 8b 4d f4   mov         ecx, DWORD PTR $T1[ebp]
  0001a 89 08        mov         DWORD PTR [eax], ecx
  0001c 8b 55 f8   mov         edx, DWORD PTR $T1[ebp+4]
  0001f 89 50 04   mov         DWORD PTR [eax+4], edx
  00022 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]

; 113  :              }

  00025 8b e5        mov         esp, ebp
  00027 5d                 pop     ebp
  00028 c2 04 00   ret         4
?_Getcoll@_Locinfo@std@@QBE?AU_Collvec@@XZ ENDP   ; std::_Locinfo::_Getcoll
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocinfo
;       COMDAT ??1_Locinfo@std@@QAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??1_Locinfo@std@@QAE@XZ PROC                            ; std::_Locinfo::~_Locinfo, COMDAT
; _this$ = ecx

; 94   :              {   // destroy the object

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 95   :              _Locinfo_dtor(this);

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a 50                 push    eax
  0000b e8 00 00 00 00     call    ?_Locinfo_dtor@_Locinfo@std@@SAXPAV12@@Z ; std::_Locinfo::_Locinfo_dtor
  00010 83 c4 04   add         esp, 4

; 96   :              }

  00013 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00016 83 c1 2c   add         ecx, 44                        ; 0000002cH
  00019 e8 00 00 00 00     call    ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
  0001e 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00021 83 c1 24   add         ecx, 36                        ; 00000024H
  00024 e8 00 00 00 00     call    ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
  00029 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0002c 83 c1 1c   add         ecx, 28                        ; 0000001cH
  0002f e8 00 00 00 00     call    ??1?$_Yarn@_W@std@@QAE@XZ ; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
  00034 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00037 83 c1 14   add         ecx, 20                        ; 00000014H
  0003a e8 00 00 00 00     call    ??1?$_Yarn@_W@std@@QAE@XZ ; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
  0003f 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00042 83 c1 0c   add         ecx, 12                        ; 0000000cH
  00045 e8 00 00 00 00     call    ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
  0004a 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0004d 83 c1 04   add         ecx, 4
  00050 e8 00 00 00 00     call    ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
  00055 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00058 e8 00 00 00 00     call    ??1_Lockit@std@@QAE@XZ       ; std::_Lockit::~_Lockit
  0005d 8b e5        mov         esp, ebp
  0005f 5d                 pop     ebp
  00060 c3                 ret     0
??1_Locinfo@std@@QAE@XZ ENDP                            ; std::_Locinfo::~_Locinfo
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocinfo
;       COMDAT ??0_Locinfo@std@@QAE@PBD@Z
_TEXT   SEGMENT
$T1 = -16                                         ; size = 12
_this$ = -4                                   ; size = 4
__Pch$ = 8                                          ; size = 4
??0_Locinfo@std@@QAE@PBD@Z PROC               ; std::_Locinfo::_Locinfo, COMDAT
; _this$ = ecx

; 76   :              {   // construct from NTBS

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 10   sub         esp, 16                        ; 00000010H
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 73   :              : _Lock(_LOCK_LOCALE)

  00009 6a 00        push        0
  0000b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000e e8 00 00 00 00     call    ??0_Lockit@std@@QAE@H@Z      ; std::_Lockit::_Lockit

; 76   :              {   // construct from NTBS

  00013 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00016 83 c1 04   add         ecx, 4
  00019 e8 00 00 00 00     call    ??0?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::_Yarn<char>
  0001e 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00021 83 c1 0c   add         ecx, 12                        ; 0000000cH
  00024 e8 00 00 00 00     call    ??0?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::_Yarn<char>
  00029 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0002c 83 c1 14   add         ecx, 20                        ; 00000014H
  0002f e8 00 00 00 00     call    ??0?$_Yarn@_W@std@@QAE@XZ ; std::_Yarn<wchar_t>::_Yarn<wchar_t>
  00034 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00037 83 c1 1c   add         ecx, 28                        ; 0000001cH
  0003a e8 00 00 00 00     call    ??0?$_Yarn@_W@std@@QAE@XZ ; std::_Yarn<wchar_t>::_Yarn<wchar_t>
  0003f 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00042 83 c1 24   add         ecx, 36                        ; 00000024H
  00045 e8 00 00 00 00     call    ??0?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::_Yarn<char>
  0004a 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0004d 83 c1 2c   add         ecx, 44                        ; 0000002cH
  00050 e8 00 00 00 00     call    ??0?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::_Yarn<char>

; 77   :              if (_Pch == 0)

  00055 83 7d 08 00        cmp   DWORD PTR __Pch$[ebp], 0
  00059 75 1b        jne         SHORT $LN2@Locinfo

; 78   :                  _THROW_NCEE(runtime_error, "bad locale name");

  0005b 68 00 00 00 00     push    OFFSET ??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@
  00060 8d 4d f0   lea         ecx, DWORD PTR $T1[ebp]
  00063 e8 00 00 00 00     call    ??0runtime_error@std@@QAE@PBD@Z ; std::runtime_error::runtime_error
  00068 68 00 00 00 00     push    OFFSET __TI2?AVruntime_error@std@@
  0006d 8d 45 f0   lea         eax, DWORD PTR $T1[ebp]
  00070 50                 push    eax
  00071 e8 00 00 00 00     call    __CxxThrowException@8
$LN2@Locinfo:

; 79   :              _Locinfo_ctor(this, _Pch);

  00076 8b 4d 08   mov         ecx, DWORD PTR __Pch$[ebp]
  00079 51                 push    ecx
  0007a 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  0007d 52                 push    edx
  0007e e8 00 00 00 00     call    ?_Locinfo_ctor@_Locinfo@std@@SAXPAV12@PBD@Z ; std::_Locinfo::_Locinfo_ctor
  00083 83 c4 08   add         esp, 8

; 80   :              }

  00086 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
$LN3@Locinfo:
  00089 8b e5        mov         esp, ebp
  0008b 5d                 pop     ebp
  0008c c2 04 00   ret         4
??0_Locinfo@std@@QAE@PBD@Z ENDP               ; std::_Locinfo::_Locinfo
_TEXT   ENDS
; Function compile flags: /Odtp
;       COMDAT ??_Gbad_cast@std@@UAEPAXI@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
___flags$ = 8                                     ; size = 4
??_Gbad_cast@std@@UAEPAXI@Z PROC                        ; std::bad_cast::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ??1bad_cast@std@@UAE@XZ
  0000f 8b 45 08   mov         eax, DWORD PTR ___flags$[ebp]
  00012 83 e0 01   and         eax, 1
  00015 74 0e        je  SHORT $LN2@scalar
  00017 6a 0c        push        12             ; 0000000cH
  00019 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001c 51                 push    ecx
  0001d e8 00 00 00 00     call    ??3@YAXPAXI@Z                ; operator delete
  00022 83 c4 08   add         esp, 8
$LN2@scalar:
  00025 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00028 8b e5        mov         esp, ebp
  0002a 5d                 pop     ebp
  0002b c2 04 00   ret         4
??_Gbad_cast@std@@UAEPAXI@Z ENDP                        ; std::bad_cast::`scalar deleting destructor'
_TEXT   ENDS
; Function compile flags: /Odtp
;       COMDAT ??0bad_cast@std@@QAE@ABV01@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
___that$ = 8                                            ; size = 4
??0bad_cast@std@@QAE@ABV01@@Z PROC                  ; std::bad_cast::bad_cast, COMDAT
; _this$ = ecx
  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 45 08   mov         eax, DWORD PTR ___that$[ebp]
  0000a 50                 push    eax
  0000b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000e e8 00 00 00 00     call    ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00013 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00016 c7 01 00 00 00
        00           mov     DWORD PTR [ecx], OFFSET ??_7bad_cast@std@@6B@
  0001c 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0001f 8b e5        mov         esp, ebp
  00021 5d                 pop     ebp
  00022 c2 04 00   ret         4
??0bad_cast@std@@QAE@ABV01@@Z ENDP                  ; std::bad_cast::bad_cast
_TEXT   ENDS
; Function compile flags: /Odtp
;       COMDAT ??1bad_cast@std@@UAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??1bad_cast@std@@UAE@XZ PROC                            ; std::bad_cast::~bad_cast, COMDAT
; _this$ = ecx
  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ??1exception@std@@UAE@XZ ; std::exception::~exception
  0000f 8b e5        mov         esp, ebp
  00011 5d                 pop     ebp
  00012 c3                 ret     0
??1bad_cast@std@@UAE@XZ ENDP                            ; std::bad_cast::~bad_cast
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_typeinfo.h
;       COMDAT ??0bad_cast@std@@QAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??0bad_cast@std@@QAE@XZ PROC                            ; std::bad_cast::bad_cast, COMDAT
; _this$ = ecx

; 125  :     {

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 124  :         : exception("bad cast", 1)

  00007 6a 01        push        1
  00009 68 00 00 00 00     push    OFFSET ??_C@_08EPJLHIJG@bad?5cast?$AA@
  0000e 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00011 e8 00 00 00 00     call    ??0exception@std@@QAE@QBDH@Z ; std::exception::exception

; 125  :     {

  00016 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00019 c7 00 00 00 00
        00           mov     DWORD PTR [eax], OFFSET ??_7bad_cast@std@@6B@

; 126  :     }

  0001f 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00022 8b e5        mov         esp, ebp
  00024 5d                 pop     ebp
  00025 c3                 ret     0
??0bad_cast@std@@QAE@XZ ENDP                            ; std::bad_cast::bad_cast
_TEXT   ENDS
; Function compile flags: /Odtp
;       COMDAT ??_Gruntime_error@std@@UAEPAXI@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
___flags$ = 8                                     ; size = 4
??_Gruntime_error@std@@UAEPAXI@Z PROC             ; std::runtime_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ??1runtime_error@std@@UAE@XZ
  0000f 8b 45 08   mov         eax, DWORD PTR ___flags$[ebp]
  00012 83 e0 01   and         eax, 1
  00015 74 0e        je  SHORT $LN2@scalar
  00017 6a 0c        push        12             ; 0000000cH
  00019 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001c 51                 push    ecx
  0001d e8 00 00 00 00     call    ??3@YAXPAXI@Z                ; operator delete
  00022 83 c4 08   add         esp, 8
$LN2@scalar:
  00025 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00028 8b e5        mov         esp, ebp
  0002a 5d                 pop     ebp
  0002b c2 04 00   ret         4
??_Gruntime_error@std@@UAEPAXI@Z ENDP             ; std::runtime_error::`scalar deleting destructor'
_TEXT   ENDS
; Function compile flags: /Odtp
;       COMDAT ??0runtime_error@std@@QAE@ABV01@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
___that$ = 8                                            ; size = 4
??0runtime_error@std@@QAE@ABV01@@Z PROC       ; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx
  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 45 08   mov         eax, DWORD PTR ___that$[ebp]
  0000a 50                 push    eax
  0000b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000e e8 00 00 00 00     call    ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00013 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00016 c7 01 00 00 00
        00           mov     DWORD PTR [ecx], OFFSET ??_7runtime_error@std@@6B@
  0001c 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0001f 8b e5        mov         esp, ebp
  00021 5d                 pop     ebp
  00022 c2 04 00   ret         4
??0runtime_error@std@@QAE@ABV01@@Z ENDP       ; std::runtime_error::runtime_error
_TEXT   ENDS
; Function compile flags: /Odtp
;       COMDAT ??1runtime_error@std@@UAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??1runtime_error@std@@UAE@XZ PROC                 ; std::runtime_error::~runtime_error, COMDAT
; _this$ = ecx
  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ??1exception@std@@UAE@XZ ; std::exception::~exception
  0000f 8b e5        mov         esp, ebp
  00011 5d                 pop     ebp
  00012 c3                 ret     0
??1runtime_error@std@@UAE@XZ ENDP                 ; std::runtime_error::~runtime_error
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stdexcept
;       COMDAT ??0runtime_error@std@@QAE@PBD@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Message$ = 8                                      ; size = 4
??0runtime_error@std@@QAE@PBD@Z PROC                    ; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx

; 168  :              {   // construct from message string

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 167  :              : _Mybase(_Message)

  00007 8b 45 08   mov         eax, DWORD PTR __Message$[ebp]
  0000a 50                 push    eax
  0000b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000e e8 00 00 00 00     call    ??0exception@std@@QAE@QBD@Z ; std::exception::exception

; 168  :              {   // construct from message string

  00013 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00016 c7 01 00 00 00
        00           mov     DWORD PTR [ecx], OFFSET ??_7runtime_error@std@@6B@

; 169  :              }

  0001c 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0001f 8b e5        mov         esp, ebp
  00021 5d                 pop     ebp
  00022 c2 04 00   ret         4
??0runtime_error@std@@QAE@PBD@Z ENDP                    ; std::runtime_error::runtime_error
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2277 :              {   // report an out_of_range error

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2278 :              _Xout_of_range("invalid string position");

  00007 68 00 00 00 00     push    OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  0000c e8 00 00 00 00     call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN2@Xran:

; 2279 :              }

  00011 8b e5        mov         esp, ebp
  00013 5d                 pop     ebp
  00014 c3                 ret     0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Off$ = 8                                          ; size = 4
?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset, COMDAT
; _this$ = ecx

; 2265 :              {   // checks whether _Off is in the bounds of [0, this->size()]

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2266 :              if (this->_Mysize() < _Off)

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  0000f 8b 00        mov         eax, DWORD PTR [eax]
  00011 3b 45 08   cmp         eax, DWORD PTR __Off$[ebp]
  00014 73 08        jae         SHORT $LN3@Check_offs

; 2267 :                  _Xran();

  00016 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00019 e8 00 00 00 00     call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN3@Check_offs:

; 2268 :              }

  0001e 8b e5        mov         esp, ebp
  00020 5d                 pop     ebp
  00021 c2 04 00   ret         4
?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2260 :              {   // report a length_error

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2261 :              _Xlength_error("string too long");

  00007 68 00 00 00 00     push    OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0000c e8 00 00 00 00     call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen:

; 2262 :              }

  00011 8b e5        mov         esp, ebp
  00013 5d                 pop     ebp
  00014 c3                 ret     0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT   SEGMENT
__Ptr$1 = -8                                            ; size = 4
_this$ = -4                                   ; size = 4
__Built$ = 8                                            ; size = 1
__Newsize$ = 12                               ; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2243 :              {   // initialize buffer, deallocating any storage

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2244 :              if (!_Built)

  00009 0f b6 45 08        movzx         eax, BYTE PTR __Built$[ebp]
  0000d 85 c0        test        eax, eax
  0000f 75 02        jne         SHORT $LN2@Tidy
  00011 eb 7b        jmp         SHORT $LN3@Tidy
$LN2@Tidy:

; 2245 :                  ;
; 2246 :              else if (this->_BUF_SIZE <= this->_Myres())

  00013 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00016 e8 00 00 00 00     call    ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
  0001b 83 38 10   cmp         DWORD PTR [eax], 16    ; 00000010H
  0001e 72 6e        jb  SHORT $LN3@Tidy

; 2247 :                  {       // copy any leftovers to small buffer and deallocate
; 2248 :                  pointer _Ptr = this->_Bx()._Ptr;

  00020 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00023 e8 00 00 00 00     call    ?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx
  00028 8b 08        mov         ecx, DWORD PTR [eax]
  0002a 89 4d f8   mov         DWORD PTR __Ptr$1[ebp], ecx

; 2249 :                  this->_Getal().destroy(&this->_Bx()._Ptr);

  0002d 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00030 e8 00 00 00 00     call    ?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx
  00035 50                 push    eax
  00036 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00039 e8 00 00 00 00     call    ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
  0003e 8b c8        mov         ecx, eax
  00040 e8 00 00 00 00     call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2250 :                  if (0 < _Newsize)

  00045 83 7d 0c 00        cmp   DWORD PTR __Newsize$[ebp], 0
  00049 76 22        jbe         SHORT $LN5@Tidy

; 2251 :                          _Traits::copy(this->_Bx()._Buf,

  0004b 8b 55 0c   mov         edx, DWORD PTR __Newsize$[ebp]
  0004e 52                 push    edx
  0004f 8b 45 f8   mov         eax, DWORD PTR __Ptr$1[ebp]
  00052 50                 push    eax
  00053 e8 00 00 00 00     call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>
  00058 83 c4 04   add         esp, 4
  0005b 50                 push    eax
  0005c 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0005f e8 00 00 00 00     call    ?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx
  00064 50                 push    eax
  00065 e8 00 00 00 00     call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
  0006a 83 c4 0c   add         esp, 12                        ; 0000000cH
$LN5@Tidy:

; 2252 :                                  _STD addressof(*_Ptr), _Newsize);
; 2253 :                  this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

  0006d 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00070 e8 00 00 00 00     call    ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
  00075 8b 08        mov         ecx, DWORD PTR [eax]
  00077 83 c1 01   add         ecx, 1
  0007a 51                 push    ecx
  0007b 8b 55 f8   mov         edx, DWORD PTR __Ptr$1[ebp]
  0007e 52                 push    edx
  0007f 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00082 e8 00 00 00 00     call    ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
  00087 8b c8        mov         ecx, eax
  00089 e8 00 00 00 00     call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2254 :                  }
; 2255 :              this->_Myres() = this->_BUF_SIZE - 1;

  0008e 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00091 e8 00 00 00 00     call    ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
  00096 c7 00 0f 00 00
        00           mov     DWORD PTR [eax], 15    ; 0000000fH

; 2256 :              _Eos(_Newsize);

  0009c 8b 45 0c   mov         eax, DWORD PTR __Newsize$[ebp]
  0009f 50                 push    eax
  000a0 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000a3 e8 00 00 00 00     call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2257 :              }

  000a8 8b e5        mov         esp, ebp
  000aa 5d                 pop     ebp
  000ab c2 08 00   ret         8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Ptr$ = 8                                          ; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2233 :              {   // test if _Ptr points inside string

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 56                 push    esi
  00005 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2234 :              if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2235 :                  || this->_Myptr() + this->_Mysize() <= _Ptr)

  00008 83 7d 08 00        cmp   DWORD PTR __Ptr$[ebp], 0
  0000c 74 26        je  SHORT $LN4@Inside
  0000e 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00011 e8 00 00 00 00     call    ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  00016 39 45 08   cmp         DWORD PTR __Ptr$[ebp], eax
  00019 72 19        jb  SHORT $LN4@Inside
  0001b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001e e8 00 00 00 00     call    ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  00023 8b f0        mov         esi, eax
  00025 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00028 e8 00 00 00 00     call    ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  0002d 03 30        add         esi, DWORD PTR [eax]
  0002f 3b 75 08   cmp         esi, DWORD PTR __Ptr$[ebp]
  00032 77 06        ja  SHORT $LN2@Inside
$LN4@Inside:

; 2236 :                  return (false); // don't ask

  00034 32 c0        xor         al, al
  00036 eb 04        jmp         SHORT $LN1@Inside

; 2237 :              else

  00038 eb 02        jmp         SHORT $LN1@Inside
$LN2@Inside:

; 2238 :                  return (true);

  0003a b0 01        mov         al, 1
$LN1@Inside:

; 2239 :              }

  0003c 5e                 pop     esi
  0003d 8b e5        mov         esp, ebp
  0003f 5d                 pop     ebp
  00040 c2 04 00   ret         4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT   SEGMENT
tv140 = -12                                   ; size = 4
tv133 = -8                                          ; size = 4
_this$ = -4                                   ; size = 4
__Newsize$ = 8                                      ; size = 4
__Trim$ = 12                                            ; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2219 :              {   // ensure buffer is big enough, trim to size if _Trim is true

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 0c   sub         esp, 12                        ; 0000000cH
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2220 :              if (max_size() < _Newsize)

  00009 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000c e8 00 00 00 00     call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00011 3b 45 08   cmp         eax, DWORD PTR __Newsize$[ebp]
  00014 73 08        jae         SHORT $LN2@Grow

; 2221 :                  _Xlen();        // result too long

  00016 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00019 e8 00 00 00 00     call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN2@Grow:

; 2222 :              if (this->_Myres() < _Newsize)

  0001e 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00021 e8 00 00 00 00     call    ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
  00026 8b 00        mov         eax, DWORD PTR [eax]
  00028 3b 45 08   cmp         eax, DWORD PTR __Newsize$[ebp]
  0002b 73 19        jae         SHORT $LN3@Grow

; 2223 :                  _Copy(_Newsize, this->_Mysize());       // reallocate to grow

  0002d 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00030 e8 00 00 00 00     call    ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  00035 8b 08        mov         ecx, DWORD PTR [eax]
  00037 51                 push    ecx
  00038 8b 55 08   mov         edx, DWORD PTR __Newsize$[ebp]
  0003b 52                 push    edx
  0003c 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0003f e8 00 00 00 00     call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00044 eb 52        jmp         SHORT $LN4@Grow
$LN3@Grow:

; 2224 :              else if (_Trim && _Newsize < this->_BUF_SIZE)

  00046 0f b6 45 0c        movzx         eax, BYTE PTR __Trim$[ebp]
  0004a 85 c0        test        eax, eax
  0004c 74 3a        je  SHORT $LN5@Grow
  0004e 83 7d 08 10        cmp   DWORD PTR __Newsize$[ebp], 16 ; 00000010H
  00052 73 34        jae         SHORT $LN5@Grow

; 2225 :                  _Tidy(true,     // copy and deallocate if trimming to small string

  00054 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00057 e8 00 00 00 00     call    ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  0005c 8b 4d 08   mov         ecx, DWORD PTR __Newsize$[ebp]
  0005f 3b 08        cmp         ecx, DWORD PTR [eax]
  00061 73 08        jae         SHORT $LN9@Grow
  00063 8b 55 08   mov         edx, DWORD PTR __Newsize$[ebp]
  00066 89 55 f8   mov         DWORD PTR tv133[ebp], edx
  00069 eb 0d        jmp         SHORT $LN10@Grow
$LN9@Grow:
  0006b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0006e e8 00 00 00 00     call    ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  00073 8b 00        mov         eax, DWORD PTR [eax]
  00075 89 45 f8   mov         DWORD PTR tv133[ebp], eax
$LN10@Grow:
  00078 8b 4d f8   mov         ecx, DWORD PTR tv133[ebp]
  0007b 51                 push    ecx
  0007c 6a 01        push        1
  0007e 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00081 e8 00 00 00 00     call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  00086 eb 10        jmp         SHORT $LN4@Grow
$LN5@Grow:

; 2226 :                          _Newsize < this->_Mysize() ? _Newsize : this->_Mysize());
; 2227 :              else if (_Newsize == 0)

  00088 83 7d 08 00        cmp   DWORD PTR __Newsize$[ebp], 0
  0008c 75 0a        jne         SHORT $LN4@Grow

; 2228 :                  _Eos(0);        // new size is zero, just null terminate

  0008e 6a 00        push        0
  00090 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00093 e8 00 00 00 00     call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2229 :              return (0 < _Newsize);      // return true only if more work to do

  00098 83 7d 08 00        cmp   DWORD PTR __Newsize$[ebp], 0
  0009c 76 09        jbe         SHORT $LN11@Grow
  0009e c7 45 f4 01 00
        00 00          mov         DWORD PTR tv140[ebp], 1
  000a5 eb 07        jmp         SHORT $LN12@Grow
$LN11@Grow:
  000a7 c7 45 f4 00 00
        00 00          mov         DWORD PTR tv140[ebp], 0
$LN12@Grow:
  000ae 8a 45 f4   mov         al, BYTE PTR tv140[ebp]
$LN8@Grow:

; 2230 :              }

  000b1 8b e5        mov         esp, ebp
  000b3 5d                 pop     ebp
  000b4 c2 08 00   ret         8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT   SEGMENT
_this$ = -8                                   ; size = 4
$T1 = -1                                                ; size = 1
__Newsize$ = 8                                      ; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2213 :              {   // set new length and null terminator

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d f8   mov         DWORD PTR _this$[ebp], ecx

; 2214 :              _Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  00009 c6 45 ff 00        mov   BYTE PTR $T1[ebp], 0
  0000d 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00010 e8 00 00 00 00     call    ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  00015 8b 4d 08   mov         ecx, DWORD PTR __Newsize$[ebp]
  00018 89 08        mov         DWORD PTR [eax], ecx
  0001a 8d 55 ff   lea         edx, DWORD PTR $T1[ebp]
  0001d 52                 push    edx
  0001e 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00021 e8 00 00 00 00     call    ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  00026 03 45 08   add         eax, DWORD PTR __Newsize$[ebp]
  00029 50                 push    eax
  0002a e8 00 00 00 00     call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
  0002f 83 c4 08   add         esp, 8

; 2215 :              }

  00032 8b e5        mov         esp, ebp
  00034 5d                 pop     ebp
  00035 c2 04 00   ret         4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT   SEGMENT
__Ptr$ = -28                                            ; size = 4
__Newres$ = -24                               ; size = 4
_this$ = -20                                            ; size = 4
__$EHRec$ = -16                               ; size = 16
__Newsize$ = 8                                      ; size = 4
__Oldlen$ = 12                                      ; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2178 :              {   // copy _Oldlen elements to newly allocated buffer

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 6a ff        push        -1
  00005 68 00 00 00 00     push    __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
  0000a 64 a1 00 00 00
        00           mov     eax, DWORD PTR fs:0
  00010 50                 push    eax
  00011 51                 push    ecx
  00012 83 ec 0c   sub         esp, 12                        ; 0000000cH
  00015 53                 push    ebx
  00016 56                 push    esi
  00017 57                 push    edi
  00018 a1 00 00 00 00     mov     eax, DWORD PTR ___security_cookie
  0001d 33 c5        xor         eax, ebp
  0001f 50                 push    eax
  00020 8d 45 f4   lea         eax, DWORD PTR __$EHRec$[ebp+4]
  00023 64 a3 00 00 00
        00           mov     DWORD PTR fs:0, eax
  00029 89 65 f0   mov         DWORD PTR __$EHRec$[ebp], esp
  0002c 89 4d ec   mov         DWORD PTR _this$[ebp], ecx

; 2179 :              size_type _Newres = _Newsize | this->_ALLOC_MASK;

  0002f 8b 45 08   mov         eax, DWORD PTR __Newsize$[ebp]
  00032 83 c8 0f   or  eax, 15              ; 0000000fH
  00035 89 45 e8   mov         DWORD PTR __Newres$[ebp], eax

; 2180 :              if (max_size() < _Newres)

  00038 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  0003b e8 00 00 00 00     call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00040 3b 45 e8   cmp         eax, DWORD PTR __Newres$[ebp]
  00043 73 08        jae         SHORT $LN2@Copy

; 2181 :                  _Newres = _Newsize;     // undo roundup if too big

  00045 8b 4d 08   mov         ecx, DWORD PTR __Newsize$[ebp]
  00048 89 4d e8   mov         DWORD PTR __Newres$[ebp], ecx
  0004b eb 6c        jmp         SHORT $LN3@Copy
$LN2@Copy:

; 2182 :              else if (this->_Myres() / 2 <= _Newres / 3)

  0004d 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  00050 e8 00 00 00 00     call    ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
  00055 8b 08        mov         ecx, DWORD PTR [eax]
  00057 d1 e9        shr         ecx, 1
  00059 8b 45 e8   mov         eax, DWORD PTR __Newres$[ebp]
  0005c 33 d2        xor         edx, edx
  0005e be 03 00 00 00     mov     esi, 3
  00063 f7 f6        div         esi
  00065 3b c8        cmp         ecx, eax
  00067 77 02        ja  SHORT $LN4@Copy
  00069 eb 4e        jmp         SHORT $LN3@Copy
$LN4@Copy:

; 2183 :                  ;
; 2184 :              else if (this->_Myres() <= max_size() - this->_Myres() / 2)

  0006b 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  0006e e8 00 00 00 00     call    ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
  00073 8b f0        mov         esi, eax
  00075 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  00078 e8 00 00 00 00     call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  0007d 8b f8        mov         edi, eax
  0007f 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  00082 e8 00 00 00 00     call    ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
  00087 8b 10        mov         edx, DWORD PTR [eax]
  00089 d1 ea        shr         edx, 1
  0008b 2b fa        sub         edi, edx
  0008d 39 3e        cmp         DWORD PTR [esi], edi
  0008f 77 1d        ja  SHORT $LN6@Copy

; 2185 :                  _Newres = this->_Myres()

  00091 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  00094 e8 00 00 00 00     call    ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
  00099 8b f0        mov         esi, eax
  0009b 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  0009e e8 00 00 00 00     call    ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
  000a3 8b 00        mov         eax, DWORD PTR [eax]
  000a5 d1 e8        shr         eax, 1
  000a7 03 06        add         eax, DWORD PTR [esi]
  000a9 89 45 e8   mov         DWORD PTR __Newres$[ebp], eax

; 2186 :                          + this->_Myres() / 2;   // grow exponentially if possible
; 2187 :              else

  000ac eb 0b        jmp         SHORT $LN3@Copy
$LN6@Copy:

; 2188 :                  _Newres = max_size();   // settle for max_size()

  000ae 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  000b1 e8 00 00 00 00     call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  000b6 89 45 e8   mov         DWORD PTR __Newres$[ebp], eax
$LN3@Copy:

; 2189 :
; 2190 :              _Elem *_Ptr;
; 2191 :              _TRY_BEGIN

  000b9 c7 45 fc 00 00
        00 00          mov         DWORD PTR __$EHRec$[ebp+12], 0

; 2192 :                  _Ptr = this->_Getal().allocate(_Newres + 1);

  000c0 8b 4d e8   mov         ecx, DWORD PTR __Newres$[ebp]
  000c3 83 c1 01   add         ecx, 1
  000c6 51                 push    ecx
  000c7 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  000ca e8 00 00 00 00     call    ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
  000cf 8b c8        mov         ecx, eax
  000d1 e8 00 00 00 00     call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
  000d6 89 45 e4   mov         DWORD PTR __Ptr$[ebp], eax
  000d9 eb 59        jmp         SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2193 :              _CATCH_ALL

  000db 89 65 f0   mov         DWORD PTR __$EHRec$[ebp], esp

; 2194 :                  _Newres = _Newsize;     // allocation failed, undo roundup and retry

  000de 8b 55 08   mov         edx, DWORD PTR __Newsize$[ebp]
  000e1 89 55 e8   mov         DWORD PTR __Newres$[ebp], edx

; 2195 :                  _TRY_BEGIN

  000e4 c6 45 fc 02        mov   BYTE PTR __$EHRec$[ebp+12], 2

; 2196 :                          _Ptr = this->_Getal().allocate(_Newres + 1);

  000e8 8b 45 e8   mov         eax, DWORD PTR __Newres$[ebp]
  000eb 83 c0 01   add         eax, 1
  000ee 50                 push    eax
  000ef 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  000f2 e8 00 00 00 00     call    ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
  000f7 8b c8        mov         ecx, eax
  000f9 e8 00 00 00 00     call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
  000fe 89 45 e4   mov         DWORD PTR __Ptr$[ebp], eax
  00101 eb 1b        jmp         SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2197 :                  _CATCH_ALL
; 2198 :                  _Tidy(true);    // failed again, discard storage and reraise

  00103 6a 00        push        0
  00105 6a 01        push        1
  00107 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  0010a e8 00 00 00 00     call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2199 :                  _RERAISE;

  0010f 6a 00        push        0
  00111 6a 00        push        0
  00113 e8 00 00 00 00     call    __CxxThrowException@8

; 2200 :                  _CATCH_END

  00118 b8 00 00 00 00     mov     eax, $LN17@Copy
  0011d c3                 ret     0
$LN14@Copy:
  0011e c7 45 fc 01 00
        00 00          mov         DWORD PTR __$EHRec$[ebp+12], 1
  00125 eb 07        jmp         SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
  00127 c7 45 fc 01 00
        00 00          mov         DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2201 :              _CATCH_END

  0012e b8 00 00 00 00     mov     eax, $LN19@Copy
  00133 c3                 ret     0
$LN12@Copy:
  00134 c7 45 fc ff ff
        ff ff          mov         DWORD PTR __$EHRec$[ebp+12], -1
  0013b eb 07        jmp         SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
  0013d c7 45 fc ff ff
        ff ff          mov         DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2202 :
; 2203 :              if (0 < _Oldlen)

  00144 83 7d 0c 00        cmp   DWORD PTR __Oldlen$[ebp], 0
  00148 76 19        jbe         SHORT $LN10@Copy

; 2204 :                  _Traits::copy(_Ptr, this->_Myptr(),

  0014a 8b 4d 0c   mov         ecx, DWORD PTR __Oldlen$[ebp]
  0014d 51                 push    ecx
  0014e 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  00151 e8 00 00 00 00     call    ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  00156 50                 push    eax
  00157 8b 55 e4   mov         edx, DWORD PTR __Ptr$[ebp]
  0015a 52                 push    edx
  0015b e8 00 00 00 00     call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
  00160 83 c4 0c   add         esp, 12                        ; 0000000cH
$LN10@Copy:

; 2205 :                          _Oldlen);       // copy existing elements
; 2206 :              _Tidy(true);

  00163 6a 00        push        0
  00165 6a 01        push        1
  00167 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  0016a e8 00 00 00 00     call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2207 :              this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);

  0016f 8d 45 e4   lea         eax, DWORD PTR __Ptr$[ebp]
  00172 50                 push    eax
  00173 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  00176 e8 00 00 00 00     call    ?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx
  0017b 50                 push    eax
  0017c 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  0017f e8 00 00 00 00     call    ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
  00184 8b c8        mov         ecx, eax
  00186 e8 00 00 00 00     call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2208 :              this->_Myres() = _Newres;

  0018b 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  0018e e8 00 00 00 00     call    ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
  00193 8b 4d e8   mov         ecx, DWORD PTR __Newres$[ebp]
  00196 89 08        mov         DWORD PTR [eax], ecx

; 2209 :              _Eos(_Oldlen);

  00198 8b 55 0c   mov         edx, DWORD PTR __Oldlen$[ebp]
  0019b 52                 push    edx
  0019c 8b 4d ec   mov         ecx, DWORD PTR _this$[ebp]
  0019f e8 00 00 00 00     call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2210 :              }

  001a4 8b 4d f4   mov         ecx, DWORD PTR __$EHRec$[ebp+4]
  001a7 64 89 0d 00 00
        00 00          mov         DWORD PTR fs:0, ecx
  001ae 59                 pop     ecx
  001af 5f                 pop     edi
  001b0 5e                 pop     esi
  001b1 5b                 pop     ebx
  001b2 8b e5        mov         esp, ebp
  001b4 5d                 pop     ebp
  001b5 c2 08 00   ret         8
_TEXT   ENDS
;       COMDAT text$x
text$x  SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
  00000 8b 54 24 08        mov   edx, DWORD PTR [esp+8]
  00004 8d 42 0c   lea         eax, DWORD PTR [edx+12]
  00007 8b 4a e0   mov         ecx, DWORD PTR [edx-32]
  0000a 33 c8        xor         ecx, eax
  0000c e8 00 00 00 00     call    @__security_check_cookie@4
  00011 b8 00 00 00 00     mov     eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
  00016 e9 00 00 00 00     jmp     ___CxxFrameHandler3
text$x  ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Off$ = 8                                          ; size = 4
__Count$ = 12                                     ; size = 4
__Ch$ = 16                                          ; size = 1
?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign, COMDAT
; _this$ = ecx

; 2170 :              {   // assign _Count copies of _Ch beginning at _Off

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2171 :              if (_Count == 1)

  00007 83 7d 0c 01        cmp   DWORD PTR __Count$[ebp], 1
  0000b 75 1a        jne         SHORT $LN2@Chassign

; 2172 :                  _Traits::assign(*(this->_Myptr() + _Off), _Ch);

  0000d 8d 45 10   lea         eax, DWORD PTR __Ch$[ebp]
  00010 50                 push    eax
  00011 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00014 e8 00 00 00 00     call    ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  00019 03 45 08   add         eax, DWORD PTR __Off$[ebp]
  0001c 50                 push    eax
  0001d e8 00 00 00 00     call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
  00022 83 c4 08   add         esp, 8

; 2173 :              else

  00025 eb 1d        jmp         SHORT $LN1@Chassign
$LN2@Chassign:

; 2174 :                  _Traits::assign(this->_Myptr() + _Off, _Count, _Ch);

  00027 0f b6 4d 10        movzx         ecx, BYTE PTR __Ch$[ebp]
  0002b 51                 push    ecx
  0002c 8b 55 0c   mov         edx, DWORD PTR __Count$[ebp]
  0002f 52                 push    edx
  00030 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00033 e8 00 00 00 00     call    ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  00038 03 45 08   add         eax, DWORD PTR __Off$[ebp]
  0003b 50                 push    eax
  0003c e8 00 00 00 00     call    ?assign@?$char_traits@D@std@@SAPADPADID@Z ; std::char_traits<char>::assign
  00041 83 c4 0c   add         esp, 12                        ; 0000000cH
$LN1@Chassign:

; 2175 :              }

  00044 8b e5        mov         esp, ebp
  00046 5d                 pop     ebp
  00047 c2 0c 00   ret         12           ; 0000000cH
?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Right$ = 8                                            ; size = 4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare, COMDAT
; _this$ = ecx

; 2117 :              {   // compare [0, _Mysize()) with _Right

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 2118 :              return (_Traits_compare(this->_Myptr(), this->_Mysize(),

  00007 8b 4d 08   mov         ecx, DWORD PTR __Right$[ebp]
  0000a e8 00 00 00 00     call    ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  0000f 8b 00        mov         eax, DWORD PTR [eax]
  00011 50                 push    eax
  00012 8b 4d 08   mov         ecx, DWORD PTR __Right$[ebp]
  00015 e8 00 00 00 00     call    ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  0001a 50                 push    eax
  0001b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001e e8 00 00 00 00     call    ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  00023 8b 08        mov         ecx, DWORD PTR [eax]
  00025 51                 push    ecx
  00026 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00029 e8 00 00 00 00     call    ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  0002e 50                 push    eax
  0002f e8 00 00 00 00     call    ?_Traits_compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAHQBDI0I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Traits_compare
  00034 83 c4 10   add         esp, 16                        ; 00000010H

; 2119 :                  _Right._Myptr(), _Right._Mysize()));
; 2120 :              }

  00037 8b e5        mov         esp, ebp
  00039 5d                 pop     ebp
  0003a c2 04 00   ret         4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z
_TEXT   SEGMENT
_this$ = -8                                   ; size = 4
__Max_effective_size$ = -4                          ; size = 4
__Off$ = 8                                          ; size = 4
__Size$ = 12                                            ; size = 4
?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Clamp_suffix_size, COMDAT
; _this$ = ecx

; 2108 :              {   // trims _Size to the longest it can be assuming a string starting at _Off

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d f8   mov         DWORD PTR _this$[ebp], ecx

; 2109 :              const size_type _Max_effective_size = this->_Mysize() - _Off;

  00009 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  0000c e8 00 00 00 00     call    ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  00011 8b 00        mov         eax, DWORD PTR [eax]
  00013 2b 45 08   sub         eax, DWORD PTR __Off$[ebp]
  00016 89 45 fc   mov         DWORD PTR __Max_effective_size$[ebp], eax

; 2110 :              if (_Size <= _Max_effective_size)

  00019 8b 4d 0c   mov         ecx, DWORD PTR __Size$[ebp]
  0001c 3b 4d fc   cmp         ecx, DWORD PTR __Max_effective_size$[ebp]
  0001f 77 07        ja  SHORT $LN2@Clamp_suff

; 2111 :                  return (_Size);

  00021 8b 45 0c   mov         eax, DWORD PTR __Size$[ebp]
  00024 eb 05        jmp         SHORT $LN1@Clamp_suff

; 2112 :              else

  00026 eb 03        jmp         SHORT $LN1@Clamp_suff
$LN2@Clamp_suff:

; 2113 :                  return (_Max_effective_size);

  00028 8b 45 fc   mov         eax, DWORD PTR __Max_effective_size$[ebp]
$LN1@Clamp_suff:

; 2114 :              }

  0002b 8b e5        mov         esp, ebp
  0002d 5d                 pop     ebp
  0002e c2 08 00   ret         8
?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Clamp_suffix_size
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ?_Traits_compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAHQBDI0I@Z
_TEXT   SEGMENT
__Min_size$ = -12                                 ; size = 4
__Ans$ = -8                                   ; size = 4
tv65 = -4                                         ; size = 4
__Left$ = 8                                   ; size = 4
__Left_size$ = 12                                 ; size = 4
__Right$ = 16                                     ; size = 4
__Right_size$ = 20                                  ; size = 4
?_Traits_compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAHQBDI0I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Traits_compare, COMDAT

; 2091 :              {   // compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) using _Traits

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 0c   sub         esp, 12                        ; 0000000cH

; 2092 :              const size_type _Min_size = _Left_size < _Right_size ? _Left_size : _Right_size;

  00006 8b 45 0c   mov         eax, DWORD PTR __Left_size$[ebp]
  00009 3b 45 14   cmp         eax, DWORD PTR __Right_size$[ebp]
  0000c 73 08        jae         SHORT $LN6@Traits_com
  0000e 8b 4d 0c   mov         ecx, DWORD PTR __Left_size$[ebp]
  00011 89 4d fc   mov         DWORD PTR tv65[ebp], ecx
  00014 eb 06        jmp         SHORT $LN7@Traits_com
$LN6@Traits_com:
  00016 8b 55 14   mov         edx, DWORD PTR __Right_size$[ebp]
  00019 89 55 fc   mov         DWORD PTR tv65[ebp], edx
$LN7@Traits_com:
  0001c 8b 45 fc   mov         eax, DWORD PTR tv65[ebp]
  0001f 89 45 f4   mov         DWORD PTR __Min_size$[ebp], eax

; 2093 :              const int _Ans = _Traits::compare(_Left, _Right, _Min_size);

  00022 8b 4d f4   mov         ecx, DWORD PTR __Min_size$[ebp]
  00025 51                 push    ecx
  00026 8b 55 10   mov         edx, DWORD PTR __Right$[ebp]
  00029 52                 push    edx
  0002a 8b 45 08   mov         eax, DWORD PTR __Left$[ebp]
  0002d 50                 push    eax
  0002e e8 00 00 00 00     call    ?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
  00033 83 c4 0c   add         esp, 12                        ; 0000000cH
  00036 89 45 f8   mov         DWORD PTR __Ans$[ebp], eax

; 2094 :
; 2095 :              if (_Ans != 0)

  00039 83 7d f8 00        cmp   DWORD PTR __Ans$[ebp], 0
  0003d 74 05        je  SHORT $LN2@Traits_com

; 2096 :                  return (_Ans);

  0003f 8b 45 f8   mov         eax, DWORD PTR __Ans$[ebp]
  00042 eb 1e        jmp         SHORT $LN1@Traits_com
$LN2@Traits_com:

; 2097 :
; 2098 :              if (_Left_size < _Right_size)

  00044 8b 4d 0c   mov         ecx, DWORD PTR __Left_size$[ebp]
  00047 3b 4d 14   cmp         ecx, DWORD PTR __Right_size$[ebp]
  0004a 73 05        jae         SHORT $LN3@Traits_com

; 2099 :                  return (-1);

  0004c 83 c8 ff   or  eax, -1
  0004f eb 11        jmp         SHORT $LN1@Traits_com
$LN3@Traits_com:

; 2100 :
; 2101 :              if (_Left_size > _Right_size)

  00051 8b 55 0c   mov         edx, DWORD PTR __Left_size$[ebp]
  00054 3b 55 14   cmp         edx, DWORD PTR __Right_size$[ebp]
  00057 76 07        jbe         SHORT $LN4@Traits_com

; 2102 :                  return (1);

  00059 b8 01 00 00 00     mov     eax, 1
  0005e eb 02        jmp         SHORT $LN1@Traits_com
$LN4@Traits_com:

; 2103 :
; 2104 :              return (0);

  00060 33 c0        xor         eax, eax
$LN1@Traits_com:

; 2105 :              }

  00062 8b e5        mov         esp, ebp
  00064 5d                 pop     ebp
  00065 c3                 ret     0
?_Traits_compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAHQBDI0I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Traits_compare
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Newsize$ = 8                                      ; size = 4
__Ch$ = 12                                          ; size = 1
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize, COMDAT
; _this$ = ecx

; 1757 :              {   // determine new length, padding with _Ch elements as needed

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1758 :              if (_Newsize <= this->_Mysize())

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  0000f 8b 4d 08   mov         ecx, DWORD PTR __Newsize$[ebp]
  00012 3b 08        cmp         ecx, DWORD PTR [eax]
  00014 77 0e        ja  SHORT $LN2@resize

; 1759 :                  _Eos(_Newsize);

  00016 8b 55 08   mov         edx, DWORD PTR __Newsize$[ebp]
  00019 52                 push    edx
  0001a 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001d e8 00 00 00 00     call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1760 :              else

  00022 eb 1b        jmp         SHORT $LN1@resize
$LN2@resize:

; 1761 :                  append(_Newsize - this->_Mysize(), _Ch);

  00024 0f b6 45 0c        movzx         eax, BYTE PTR __Ch$[ebp]
  00028 50                 push    eax
  00029 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0002c e8 00 00 00 00     call    ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  00031 8b 4d 08   mov         ecx, DWORD PTR __Newsize$[ebp]
  00034 2b 08        sub         ecx, DWORD PTR [eax]
  00036 51                 push    ecx
  00037 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0003a e8 00 00 00 00     call    ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN1@resize:

; 1762 :              }

  0003f 8b e5        mov         esp, ebp
  00041 5d                 pop     ebp
  00042 c2 08 00   ret         8
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Newsize$ = 8                                      ; size = 4
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize, COMDAT
; _this$ = ecx

; 1752 :              {   // determine new length, padding with null elements as needed

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1753 :              resize(_Newsize, _Elem());

  00007 6a 00        push        0
  00009 8b 45 08   mov         eax, DWORD PTR __Newsize$[ebp]
  0000c 50                 push    eax
  0000d 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00010 e8 00 00 00 00     call    ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize

; 1754 :              }

  00015 8b e5        mov         esp, ebp
  00017 5d                 pop     ebp
  00018 c2 04 00   ret         4
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT   SEGMENT
_this$ = -16                                            ; size = 4
tv75 = -12                                          ; size = 4
__Num$ = -8                                   ; size = 4
$T1 = -1                                                ; size = 1
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1746 :              {   // return maximum possible length of sequence

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 10   sub         esp, 16                        ; 00000010H
  00006 89 4d f0   mov         DWORD PTR _this$[ebp], ecx

; 1747 :              const size_type _Num = this->_Getal().max_size();

  00009 0f b6 45 ff        movzx         eax, BYTE PTR $T1[ebp]
  0000d 50                 push    eax
  0000e 8b 4d f0   mov         ecx, DWORD PTR _this$[ebp]
  00011 e8 00 00 00 00     call    ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
  00016 8b c8        mov         ecx, eax
  00018 e8 00 00 00 00     call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<char> >::max_size
  0001d 89 45 f8   mov         DWORD PTR __Num$[ebp], eax

; 1748 :              return (_Num <= 1 ? 1 : _Num - 1);

  00020 83 7d f8 01        cmp   DWORD PTR __Num$[ebp], 1
  00024 77 09        ja  SHORT $LN3@max_size
  00026 c7 45 f4 01 00
        00 00          mov         DWORD PTR tv75[ebp], 1
  0002d eb 09        jmp         SHORT $LN4@max_size
$LN3@max_size:
  0002f 8b 4d f8   mov         ecx, DWORD PTR __Num$[ebp]
  00032 83 e9 01   sub         ecx, 1
  00035 89 4d f4   mov         DWORD PTR tv75[ebp], ecx
$LN4@max_size:
  00038 8b 45 f4   mov         eax, DWORD PTR tv75[ebp]

; 1749 :              }

  0003b 8b e5        mov         esp, ebp
  0003d 5d                 pop     ebp
  0003e c3                 ret     0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1741 :              {   // return length of sequence

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1742 :              return (this->_Mysize());

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  0000f 8b 00        mov         eax, DWORD PTR [eax]

; 1743 :              }

  00011 8b e5        mov         esp, ebp
  00013 5d                 pop     ebp
  00014 c3                 ret     0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length, COMDAT
; _this$ = ecx

; 1736 :              {   // return length of sequence

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1737 :              return (this->_Mysize());

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  0000f 8b 00        mov         eax, DWORD PTR [eax]

; 1738 :              }

  00011 8b e5        mov         esp, ebp
  00013 5d                 pop     ebp
  00014 c3                 ret     0
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 1726 :              {   // return pointer to null-terminated nonmutable array

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1727 :              return (this->_Myptr());

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr

; 1728 :              }

  0000f 8b e5        mov         esp, ebp
  00011 5d                 pop     ebp
  00012 c3                 ret     0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Off$ = 8                                          ; size = 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT
; _this$ = ecx

; 1670 :              {   // subscript mutable sequence

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1671 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1672 :              if (this->_Mysize() < _Off) // sic
; 1673 :                  _DEBUG_ERROR("string subscript out of range");
; 1674 :
; 1675 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1676 :              _SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());        // sic
; 1677 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1678 :
; 1679 :              return (this->_Myptr()[_Off]);

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  0000f 03 45 08   add         eax, DWORD PTR __Off$[ebp]

; 1680 :              }

  00012 8b e5        mov         esp, ebp
  00014 5d                 pop     ebp
  00015 c2 04 00   ret         4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
___$ReturnUdt$ = 8                                  ; size = 4
?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end, COMDAT
; _this$ = ecx

; 1599 :              {   // return iterator for end of mutable sequence

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 56                 push    esi
  00005 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1600 :              return (iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));

  00008 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000b e8 00 00 00 00     call    ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
  00010 50                 push    eax
  00011 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00014 e8 00 00 00 00     call    ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  00019 8b f0        mov         esi, eax
  0001b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001e e8 00 00 00 00     call    ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  00023 03 30        add         esi, DWORD PTR [eax]
  00025 56                 push    esi
  00026 8b 4d 08   mov         ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00029 e8 00 00 00 00     call    ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >
  0002e 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1601 :              }

  00031 5e                 pop     esi
  00032 8b e5        mov         esp, ebp
  00034 5d                 pop     ebp
  00035 c2 04 00   ret         4
?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
___$ReturnUdt$ = 8                                  ; size = 4
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin, COMDAT
; _this$ = ecx

; 1589 :              {   // return iterator for beginning of mutable sequence

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1590 :              return (iterator(this->_Myptr(), &this->_Get_data()));

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
  0000f 50                 push    eax
  00010 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00013 e8 00 00 00 00     call    ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  00018 50                 push    eax
  00019 8b 4d 08   mov         ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c e8 00 00 00 00     call    ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >
  00021 8b 45 08   mov         eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1591 :              }

  00024 8b e5        mov         esp, ebp
  00026 5d                 pop     ebp
  00027 c2 04 00   ret         4
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z
_TEXT   SEGMENT
$T1 = -12                                         ; size = 4
$T2 = -8                                                ; size = 4
_this$ = -4                                   ; size = 4
__First$ = 8                                            ; size = 4
__Last$ = 12                                            ; size = 4
__First2$ = 16                                      ; size = 4
__Last2$ = 20                                     ; size = 4
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace, COMDAT
; _this$ = ecx

; 1579 :              {   // replace [_First, _Last) with [_First2, _Last2), const_iterators

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 0c   sub         esp, 12                        ; 0000000cH
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1580 :              if (_First2 == _Last2)

  00009 8d 45 14   lea         eax, DWORD PTR __Last2$[ebp]
  0000c 50                 push    eax
  0000d 8d 4d 10   lea         ecx, DWORD PTR __First2$[ebp]
  00010 e8 00 00 00 00     call    ??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE_NABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator==
  00015 0f b6 c8   movzx       ecx, al
  00018 85 c9        test        ecx, ecx
  0001a 74 2d        je  SHORT $LN2@replace

; 1581 :                  erase(_First - begin(), _Last - _First);

  0001c 8d 55 08   lea         edx, DWORD PTR __First$[ebp]
  0001f 52                 push    edx
  00020 8d 4d 0c   lea         ecx, DWORD PTR __Last$[ebp]
  00023 e8 00 00 00 00     call    ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator-
  00028 50                 push    eax
  00029 8d 45 f8   lea         eax, DWORD PTR $T2[ebp]
  0002c 50                 push    eax
  0002d 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00030 e8 00 00 00 00     call    ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
  00035 50                 push    eax
  00036 8d 4d 08   lea         ecx, DWORD PTR __First$[ebp]
  00039 e8 00 00 00 00     call    ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator-
  0003e 50                 push    eax
  0003f 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00042 e8 00 00 00 00     call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 1582 :              else

  00047 eb 41        jmp         SHORT $LN3@replace
$LN2@replace:

; 1583 :                  replace(_First - begin(), _Last - _First,

  00049 8d 4d 10   lea         ecx, DWORD PTR __First2$[ebp]
  0004c 51                 push    ecx
  0004d 8d 4d 14   lea         ecx, DWORD PTR __Last2$[ebp]
  00050 e8 00 00 00 00     call    ??G?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator-
  00055 50                 push    eax
  00056 8d 4d 10   lea         ecx, DWORD PTR __First2$[ebp]
  00059 e8 00 00 00 00     call    ??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
  0005e 50                 push    eax
  0005f 8d 55 08   lea         edx, DWORD PTR __First$[ebp]
  00062 52                 push    edx
  00063 8d 4d 0c   lea         ecx, DWORD PTR __Last$[ebp]
  00066 e8 00 00 00 00     call    ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator-
  0006b 50                 push    eax
  0006c 8d 45 f4   lea         eax, DWORD PTR $T1[ebp]
  0006f 50                 push    eax
  00070 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00073 e8 00 00 00 00     call    ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
  00078 50                 push    eax
  00079 8d 4d 08   lea         ecx, DWORD PTR __First$[ebp]
  0007c e8 00 00 00 00     call    ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator-
  00081 50                 push    eax
  00082 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00085 e8 00 00 00 00     call    ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
$LN3@replace:

; 1584 :                          &*_First2, _Last2 - _First2);
; 1585 :              return (*this);

  0008a 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]

; 1586 :              }

  0008d 8b e5        mov         esp, ebp
  0008f 5d                 pop     ebp
  00090 c2 10 00   ret         16           ; 00000010H
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIPBDI@Z
_TEXT   SEGMENT
__Num$ = -12                                            ; size = 4
__Nm$ = -8                                          ; size = 4
_this$ = -4                                   ; size = 4
__Off$ = 8                                          ; size = 4
__N0$ = 12                                          ; size = 4
__Ptr$ = 16                                   ; size = 4
__Count$ = 20                                     ; size = 4
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIPBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace, COMDAT
; _this$ = ecx

; 1448 :              {   // replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 0c   sub         esp, 12                        ; 0000000cH
  00006 56                 push    esi
  00007 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1449 :              _DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1450 :              if (_Inside(_Ptr))

  0000a 8b 45 10   mov         eax, DWORD PTR __Ptr$[ebp]
  0000d 50                 push    eax
  0000e 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00011 e8 00 00 00 00     call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
  00016 0f b6 c8   movzx       ecx, al
  00019 85 c9        test        ecx, ecx
  0001b 74 2b        je  SHORT $LN2@replace

; 1451 :                  return (replace(_Off, _N0, *this,

  0001d 8b 55 14   mov         edx, DWORD PTR __Count$[ebp]
  00020 52                 push    edx
  00021 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00024 e8 00 00 00 00     call    ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  00029 8b 4d 10   mov         ecx, DWORD PTR __Ptr$[ebp]
  0002c 2b c8        sub         ecx, eax
  0002e 51                 push    ecx
  0002f 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  00032 52                 push    edx
  00033 8b 45 0c   mov         eax, DWORD PTR __N0$[ebp]
  00036 50                 push    eax
  00037 8b 4d 08   mov         ecx, DWORD PTR __Off$[ebp]
  0003a 51                 push    ecx
  0003b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0003e e8 00 00 00 00     call    ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
  00043 e9 14 01 00 00     jmp     $LN8@replace
$LN2@replace:

; 1452 :                          _Ptr - this->_Myptr(),
; 1453 :                          _Count));       // substring, replace carefully
; 1454 :              _Check_offset(_Off);

  00048 8b 55 08   mov         edx, DWORD PTR __Off$[ebp]
  0004b 52                 push    edx
  0004c 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0004f e8 00 00 00 00     call    ?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset

; 1455 :              _N0 = _Clamp_suffix_size(_Off, _N0);

  00054 8b 45 0c   mov         eax, DWORD PTR __N0$[ebp]
  00057 50                 push    eax
  00058 8b 4d 08   mov         ecx, DWORD PTR __Off$[ebp]
  0005b 51                 push    ecx
  0005c 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0005f e8 00 00 00 00     call    ?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Clamp_suffix_size
  00064 89 45 0c   mov         DWORD PTR __N0$[ebp], eax

; 1456 :              if (npos - _Count <= this->_Mysize() - _N0)

  00067 83 ce ff   or  esi, -1
  0006a 2b 75 14   sub         esi, DWORD PTR __Count$[ebp]
  0006d 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00070 e8 00 00 00 00     call    ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  00075 8b 10        mov         edx, DWORD PTR [eax]
  00077 2b 55 0c   sub         edx, DWORD PTR __N0$[ebp]
  0007a 3b f2        cmp         esi, edx
  0007c 77 08        ja  SHORT $LN3@replace

; 1457 :                  _Xlen();        // result too long

  0007e 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00081 e8 00 00 00 00     call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN3@replace:

; 1458 :              size_type _Nm = this->_Mysize() - _N0 - _Off;

  00086 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00089 e8 00 00 00 00     call    ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  0008e 8b 00        mov         eax, DWORD PTR [eax]
  00090 2b 45 0c   sub         eax, DWORD PTR __N0$[ebp]
  00093 2b 45 08   sub         eax, DWORD PTR __Off$[ebp]
  00096 89 45 f8   mov         DWORD PTR __Nm$[ebp], eax

; 1459 :
; 1460 :              if (_Count < _N0)

  00099 8b 4d 14   mov         ecx, DWORD PTR __Count$[ebp]
  0009c 3b 4d 0c   cmp         ecx, DWORD PTR __N0$[ebp]
  0009f 73 2a        jae         SHORT $LN4@replace

; 1461 :                  _Traits::move(this->_Myptr() + _Off + _Count,

  000a1 8b 55 f8   mov         edx, DWORD PTR __Nm$[ebp]
  000a4 52                 push    edx
  000a5 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000a8 e8 00 00 00 00     call    ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  000ad 03 45 08   add         eax, DWORD PTR __Off$[ebp]
  000b0 03 45 0c   add         eax, DWORD PTR __N0$[ebp]
  000b3 50                 push    eax
  000b4 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000b7 e8 00 00 00 00     call    ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  000bc 03 45 08   add         eax, DWORD PTR __Off$[ebp]
  000bf 03 45 14   add         eax, DWORD PTR __Count$[ebp]
  000c2 50                 push    eax
  000c3 e8 00 00 00 00     call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
  000c8 83 c4 0c   add         esp, 12                        ; 0000000cH
$LN4@replace:

; 1462 :                          this->_Myptr() + _Off + _N0,
; 1463 :                          _Nm);   // smaller hole, move tail up
; 1464 :              const size_type _Num = this->_Mysize() + _Count - _N0;

  000cb 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000ce e8 00 00 00 00     call    ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  000d3 8b 00        mov         eax, DWORD PTR [eax]
  000d5 03 45 14   add         eax, DWORD PTR __Count$[ebp]
  000d8 2b 45 0c   sub         eax, DWORD PTR __N0$[ebp]
  000db 89 45 f4   mov         DWORD PTR __Num$[ebp], eax

; 1465 :              if ((0 < _Count || 0 < _N0)
; 1466 :                  && _Grow(_Num))

  000de 83 7d 14 00        cmp   DWORD PTR __Count$[ebp], 0
  000e2 77 06        ja  SHORT $LN6@replace
  000e4 83 7d 0c 00        cmp   DWORD PTR __N0$[ebp], 0
  000e8 76 6f        jbe         SHORT $LN5@replace
$LN6@replace:
  000ea 6a 00        push        0
  000ec 8b 4d f4   mov         ecx, DWORD PTR __Num$[ebp]
  000ef 51                 push    ecx
  000f0 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000f3 e8 00 00 00 00     call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
  000f8 0f b6 d0   movzx       edx, al
  000fb 85 d2        test        edx, edx
  000fd 74 5a        je  SHORT $LN5@replace

; 1467 :                  {       // make room and rearrange
; 1468 :                  if (_N0 < _Count)

  000ff 8b 45 0c   mov         eax, DWORD PTR __N0$[ebp]
  00102 3b 45 14   cmp         eax, DWORD PTR __Count$[ebp]
  00105 73 2a        jae         SHORT $LN7@replace

; 1469 :                          _Traits::move(this->_Myptr() + _Off + _Count,

  00107 8b 4d f8   mov         ecx, DWORD PTR __Nm$[ebp]
  0010a 51                 push    ecx
  0010b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0010e e8 00 00 00 00     call    ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  00113 03 45 08   add         eax, DWORD PTR __Off$[ebp]
  00116 03 45 0c   add         eax, DWORD PTR __N0$[ebp]
  00119 50                 push    eax
  0011a 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0011d e8 00 00 00 00     call    ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  00122 03 45 08   add         eax, DWORD PTR __Off$[ebp]
  00125 03 45 14   add         eax, DWORD PTR __Count$[ebp]
  00128 50                 push    eax
  00129 e8 00 00 00 00     call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
  0012e 83 c4 0c   add         esp, 12                        ; 0000000cH
$LN7@replace:

; 1470 :                                  this->_Myptr() + _Off + _N0, _Nm);      // move tail down
; 1471 :                  _Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);     // fill hole

  00131 8b 55 14   mov         edx, DWORD PTR __Count$[ebp]
  00134 52                 push    edx
  00135 8b 45 10   mov         eax, DWORD PTR __Ptr$[ebp]
  00138 50                 push    eax
  00139 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0013c e8 00 00 00 00     call    ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  00141 03 45 08   add         eax, DWORD PTR __Off$[ebp]
  00144 50                 push    eax
  00145 e8 00 00 00 00     call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
  0014a 83 c4 0c   add         esp, 12                        ; 0000000cH

; 1472 :                  _Eos(_Num);

  0014d 8b 4d f4   mov         ecx, DWORD PTR __Num$[ebp]
  00150 51                 push    ecx
  00151 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00154 e8 00 00 00 00     call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN5@replace:

; 1473 :                  }
; 1474 :              return (*this);

  00159 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
$LN8@replace:

; 1475 :              }

  0015c 5e                 pop     esi
  0015d 8b e5        mov         esp, ebp
  0015f 5d                 pop     ebp
  00160 c2 10 00   ret         16           ; 00000010H
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIPBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIABV12@II@Z
_TEXT   SEGMENT
__Newsize$ = -12                                        ; size = 4
__Nm$ = -8                                          ; size = 4
_this$ = -4                                   ; size = 4
__Off$ = 8                                          ; size = 4
__N0$ = 12                                          ; size = 4
__Right$ = 16                                     ; size = 4
__Roff$ = 20                                            ; size = 4
__Count$ = 24                                     ; size = 4
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace, COMDAT
; _this$ = ecx

; 1384 :              {   // replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 0c   sub         esp, 12                        ; 0000000cH
  00006 56                 push    esi
  00007 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1385 :              _Check_offset(_Off);

  0000a 8b 45 08   mov         eax, DWORD PTR __Off$[ebp]
  0000d 50                 push    eax
  0000e 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00011 e8 00 00 00 00     call    ?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset

; 1386 :              _Right._Check_offset(_Roff);

  00016 8b 4d 14   mov         ecx, DWORD PTR __Roff$[ebp]
  00019 51                 push    ecx
  0001a 8b 4d 10   mov         ecx, DWORD PTR __Right$[ebp]
  0001d e8 00 00 00 00     call    ?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset

; 1387 :              _N0 = _Clamp_suffix_size(_Off, _N0);

  00022 8b 55 0c   mov         edx, DWORD PTR __N0$[ebp]
  00025 52                 push    edx
  00026 8b 45 08   mov         eax, DWORD PTR __Off$[ebp]
  00029 50                 push    eax
  0002a 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0002d e8 00 00 00 00     call    ?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Clamp_suffix_size
  00032 89 45 0c   mov         DWORD PTR __N0$[ebp], eax

; 1388 :              _Count = _Right._Clamp_suffix_size(_Roff, _Count);

  00035 8b 4d 18   mov         ecx, DWORD PTR __Count$[ebp]
  00038 51                 push    ecx
  00039 8b 55 14   mov         edx, DWORD PTR __Roff$[ebp]
  0003c 52                 push    edx
  0003d 8b 4d 10   mov         ecx, DWORD PTR __Right$[ebp]
  00040 e8 00 00 00 00     call    ?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Clamp_suffix_size
  00045 89 45 18   mov         DWORD PTR __Count$[ebp], eax

; 1389 :              if (npos - _Count <= this->_Mysize() - _N0)

  00048 83 ce ff   or  esi, -1
  0004b 2b 75 18   sub         esi, DWORD PTR __Count$[ebp]
  0004e 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00051 e8 00 00 00 00     call    ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  00056 8b 00        mov         eax, DWORD PTR [eax]
  00058 2b 45 0c   sub         eax, DWORD PTR __N0$[ebp]
  0005b 3b f0        cmp         esi, eax
  0005d 77 08        ja  SHORT $LN2@replace

; 1390 :                  _Xlen();        // result too long

  0005f 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00062 e8 00 00 00 00     call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN2@replace:

; 1391 :
; 1392 :              const size_type _Nm = this->_Mysize() - _N0 - _Off; // length of kept tail

  00067 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0006a e8 00 00 00 00     call    ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  0006f 8b 08        mov         ecx, DWORD PTR [eax]
  00071 2b 4d 0c   sub         ecx, DWORD PTR __N0$[ebp]
  00074 2b 4d 08   sub         ecx, DWORD PTR __Off$[ebp]
  00077 89 4d f8   mov         DWORD PTR __Nm$[ebp], ecx

; 1393 :              const size_type _Newsize = this->_Mysize() + _Count - _N0;

  0007a 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0007d e8 00 00 00 00     call    ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  00082 8b 10        mov         edx, DWORD PTR [eax]
  00084 03 55 18   add         edx, DWORD PTR __Count$[ebp]
  00087 2b 55 0c   sub         edx, DWORD PTR __N0$[ebp]
  0008a 89 55 f4   mov         DWORD PTR __Newsize$[ebp], edx

; 1394 :              if (this->_Mysize() < _Newsize)

  0008d 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00090 e8 00 00 00 00     call    ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  00095 8b 00        mov         eax, DWORD PTR [eax]
  00097 3b 45 f4   cmp         eax, DWORD PTR __Newsize$[ebp]
  0009a 73 0e        jae         SHORT $LN3@replace

; 1395 :                  _Grow(_Newsize);

  0009c 6a 00        push        0
  0009e 8b 4d f4   mov         ecx, DWORD PTR __Newsize$[ebp]
  000a1 51                 push    ecx
  000a2 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000a5 e8 00 00 00 00     call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
$LN3@replace:

; 1396 :
; 1397 :              if (_Count == _N0)

  000aa 8b 55 18   mov         edx, DWORD PTR __Count$[ebp]
  000ad 3b 55 0c   cmp         edx, DWORD PTR __N0$[ebp]
  000b0 75 29        jne         SHORT $LN4@replace

; 1398 :                  {       // only one movement required, so _Traits::move handles any overlap
; 1399 :                  _Traits::move(this->_Myptr() + _Off,

  000b2 8b 45 18   mov         eax, DWORD PTR __Count$[ebp]
  000b5 50                 push    eax
  000b6 8b 4d 10   mov         ecx, DWORD PTR __Right$[ebp]
  000b9 e8 00 00 00 00     call    ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  000be 03 45 14   add         eax, DWORD PTR __Roff$[ebp]
  000c1 50                 push    eax
  000c2 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000c5 e8 00 00 00 00     call    ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  000ca 03 45 08   add         eax, DWORD PTR __Off$[ebp]
  000cd 50                 push    eax
  000ce e8 00 00 00 00     call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
  000d3 83 c4 0c   add         esp, 12                        ; 0000000cH
  000d6 e9 ef 01 00 00     jmp     $LN5@replace
$LN4@replace:

; 1400 :                          _Right._Myptr() + _Roff, _Count);       // fill hole
; 1401 :                  }
; 1402 :              else if (this != &_Right)

  000db 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000de 3b 4d 10   cmp         ecx, DWORD PTR __Right$[ebp]
  000e1 74 53        je  SHORT $LN6@replace

; 1403 :                  {       // no overlap, just move down and copy in new stuff
; 1404 :                  _Traits::move(this->_Myptr() + _Off + _Count,

  000e3 8b 55 f8   mov         edx, DWORD PTR __Nm$[ebp]
  000e6 52                 push    edx
  000e7 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000ea e8 00 00 00 00     call    ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  000ef 03 45 08   add         eax, DWORD PTR __Off$[ebp]
  000f2 03 45 0c   add         eax, DWORD PTR __N0$[ebp]
  000f5 50                 push    eax
  000f6 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000f9 e8 00 00 00 00     call    ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  000fe 03 45 08   add         eax, DWORD PTR __Off$[ebp]
  00101 03 45 18   add         eax, DWORD PTR __Count$[ebp]
  00104 50                 push    eax
  00105 e8 00 00 00 00     call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
  0010a 83 c4 0c   add         esp, 12                        ; 0000000cH

; 1405 :                          this->_Myptr() + _Off + _N0, _Nm);      // empty hole
; 1406 :                  _Traits::copy(this->_Myptr() + _Off,

  0010d 8b 45 18   mov         eax, DWORD PTR __Count$[ebp]
  00110 50                 push    eax
  00111 8b 4d 10   mov         ecx, DWORD PTR __Right$[ebp]
  00114 e8 00 00 00 00     call    ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  00119 03 45 14   add         eax, DWORD PTR __Roff$[ebp]
  0011c 50                 push    eax
  0011d 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00120 e8 00 00 00 00     call    ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  00125 03 45 08   add         eax, DWORD PTR __Off$[ebp]
  00128 50                 push    eax
  00129 e8 00 00 00 00     call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
  0012e 83 c4 0c   add         esp, 12                        ; 0000000cH
  00131 e9 94 01 00 00     jmp     $LN5@replace
$LN6@replace:

; 1407 :                          _Right._Myptr() + _Roff, _Count);       // fill hole
; 1408 :                  }
; 1409 :              else if (_Count < _N0)

  00136 8b 4d 18   mov         ecx, DWORD PTR __Count$[ebp]
  00139 3b 4d 0c   cmp         ecx, DWORD PTR __N0$[ebp]
  0013c 73 53        jae         SHORT $LN8@replace

; 1410 :                  {       // hole doesn't get larger, just copy in substring
; 1411 :                  _Traits::move(this->_Myptr() + _Off,

  0013e 8b 55 18   mov         edx, DWORD PTR __Count$[ebp]
  00141 52                 push    edx
  00142 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00145 e8 00 00 00 00     call    ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  0014a 03 45 14   add         eax, DWORD PTR __Roff$[ebp]
  0014d 50                 push    eax
  0014e 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00151 e8 00 00 00 00     call    ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  00156 03 45 08   add         eax, DWORD PTR __Off$[ebp]
  00159 50                 push    eax
  0015a e8 00 00 00 00     call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
  0015f 83 c4 0c   add         esp, 12                        ; 0000000cH

; 1412 :                          this->_Myptr() + _Roff, _Count);        // fill hole
; 1413 :                  _Traits::move(this->_Myptr() + _Off + _Count,

  00162 8b 45 f8   mov         eax, DWORD PTR __Nm$[ebp]
  00165 50                 push    eax
  00166 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00169 e8 00 00 00 00     call    ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  0016e 03 45 08   add         eax, DWORD PTR __Off$[ebp]
  00171 03 45 0c   add         eax, DWORD PTR __N0$[ebp]
  00174 50                 push    eax
  00175 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00178 e8 00 00 00 00     call    ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  0017d 03 45 08   add         eax, DWORD PTR __Off$[ebp]
  00180 03 45 18   add         eax, DWORD PTR __Count$[ebp]
  00183 50                 push    eax
  00184 e8 00 00 00 00     call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
  00189 83 c4 0c   add         esp, 12                        ; 0000000cH
  0018c e9 39 01 00 00     jmp     $LN5@replace
$LN8@replace:

; 1414 :                          this->_Myptr() + _Off + _N0, _Nm);      // move tail down
; 1415 :                  }
; 1416 :              else if (_Roff <= _Off)

  00191 8b 4d 14   mov         ecx, DWORD PTR __Roff$[ebp]
  00194 3b 4d 08   cmp         ecx, DWORD PTR __Off$[ebp]
  00197 77 53        ja  SHORT $LN10@replace

; 1417 :                  {       // hole gets larger, substring begins before hole
; 1418 :                  _Traits::move(this->_Myptr() + _Off + _Count,

  00199 8b 55 f8   mov         edx, DWORD PTR __Nm$[ebp]
  0019c 52                 push    edx
  0019d 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  001a0 e8 00 00 00 00     call    ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  001a5 03 45 08   add         eax, DWORD PTR __Off$[ebp]
  001a8 03 45 0c   add         eax, DWORD PTR __N0$[ebp]
  001ab 50                 push    eax
  001ac 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  001af e8 00 00 00 00     call    ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  001b4 03 45 08   add         eax, DWORD PTR __Off$[ebp]
  001b7 03 45 18   add         eax, DWORD PTR __Count$[ebp]
  001ba 50                 push    eax
  001bb e8 00 00 00 00     call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
  001c0 83 c4 0c   add         esp, 12                        ; 0000000cH

; 1419 :                          this->_Myptr() + _Off + _N0, _Nm);      // move tail down
; 1420 :                  _Traits::move(this->_Myptr() + _Off,

  001c3 8b 45 18   mov         eax, DWORD PTR __Count$[ebp]
  001c6 50                 push    eax
  001c7 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  001ca e8 00 00 00 00     call    ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  001cf 03 45 14   add         eax, DWORD PTR __Roff$[ebp]
  001d2 50                 push    eax
  001d3 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  001d6 e8 00 00 00 00     call    ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  001db 03 45 08   add         eax, DWORD PTR __Off$[ebp]
  001de 50                 push    eax
  001df e8 00 00 00 00     call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
  001e4 83 c4 0c   add         esp, 12                        ; 0000000cH
  001e7 e9 de 00 00 00     jmp     $LN5@replace
$LN10@replace:

; 1421 :                          this->_Myptr() + _Roff, _Count);        // fill hole
; 1422 :                  }
; 1423 :              else if (_Off + _N0 <= _Roff)

  001ec 8b 4d 08   mov         ecx, DWORD PTR __Off$[ebp]
  001ef 03 4d 0c   add         ecx, DWORD PTR __N0$[ebp]
  001f2 3b 4d 14   cmp         ecx, DWORD PTR __Roff$[ebp]
  001f5 77 58        ja  SHORT $LN12@replace

; 1424 :                  {       // hole gets larger, substring begins after hole
; 1425 :                  _Traits::move(this->_Myptr() + _Off + _Count,

  001f7 8b 55 f8   mov         edx, DWORD PTR __Nm$[ebp]
  001fa 52                 push    edx
  001fb 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  001fe e8 00 00 00 00     call    ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  00203 03 45 08   add         eax, DWORD PTR __Off$[ebp]
  00206 03 45 0c   add         eax, DWORD PTR __N0$[ebp]
  00209 50                 push    eax
  0020a 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0020d e8 00 00 00 00     call    ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  00212 03 45 08   add         eax, DWORD PTR __Off$[ebp]
  00215 03 45 18   add         eax, DWORD PTR __Count$[ebp]
  00218 50                 push    eax
  00219 e8 00 00 00 00     call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
  0021e 83 c4 0c   add         esp, 12                        ; 0000000cH

; 1426 :                          this->_Myptr() + _Off + _N0, _Nm);      // move tail down
; 1427 :                  _Traits::move(this->_Myptr() + _Off,

  00221 8b 45 18   mov         eax, DWORD PTR __Count$[ebp]
  00224 50                 push    eax
  00225 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00228 e8 00 00 00 00     call    ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  0022d 8b 4d 14   mov         ecx, DWORD PTR __Roff$[ebp]
  00230 03 4d 18   add         ecx, DWORD PTR __Count$[ebp]
  00233 2b 4d 0c   sub         ecx, DWORD PTR __N0$[ebp]
  00236 03 c1        add         eax, ecx
  00238 50                 push    eax
  00239 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0023c e8 00 00 00 00     call    ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  00241 03 45 08   add         eax, DWORD PTR __Off$[ebp]
  00244 50                 push    eax
  00245 e8 00 00 00 00     call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
  0024a 83 c4 0c   add         esp, 12                        ; 0000000cH

; 1428 :                          this->_Myptr() + (_Roff + _Count - _N0),
; 1429 :                          _Count);        // fill hole
; 1430 :                  }
; 1431 :              else

  0024d eb 7b        jmp         SHORT $LN5@replace
$LN12@replace:

; 1432 :                  {       // hole gets larger, substring begins in hole
; 1433 :                  _Traits::move(this->_Myptr() + _Off,

  0024f 8b 55 0c   mov         edx, DWORD PTR __N0$[ebp]
  00252 52                 push    edx
  00253 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00256 e8 00 00 00 00     call    ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  0025b 03 45 14   add         eax, DWORD PTR __Roff$[ebp]
  0025e 50                 push    eax
  0025f 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00262 e8 00 00 00 00     call    ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  00267 03 45 08   add         eax, DWORD PTR __Off$[ebp]
  0026a 50                 push    eax
  0026b e8 00 00 00 00     call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
  00270 83 c4 0c   add         esp, 12                        ; 0000000cH

; 1434 :                          this->_Myptr() + _Roff, _N0);   // fill old hole
; 1435 :                  _Traits::move(this->_Myptr() + _Off + _Count,

  00273 8b 45 f8   mov         eax, DWORD PTR __Nm$[ebp]
  00276 50                 push    eax
  00277 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0027a e8 00 00 00 00     call    ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  0027f 03 45 08   add         eax, DWORD PTR __Off$[ebp]
  00282 03 45 0c   add         eax, DWORD PTR __N0$[ebp]
  00285 50                 push    eax
  00286 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00289 e8 00 00 00 00     call    ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  0028e 03 45 08   add         eax, DWORD PTR __Off$[ebp]
  00291 03 45 18   add         eax, DWORD PTR __Count$[ebp]
  00294 50                 push    eax
  00295 e8 00 00 00 00     call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
  0029a 83 c4 0c   add         esp, 12                        ; 0000000cH

; 1436 :                          this->_Myptr() + _Off + _N0, _Nm);      // move tail down
; 1437 :                  _Traits::move(this->_Myptr() + _Off + _N0,

  0029d 8b 4d 18   mov         ecx, DWORD PTR __Count$[ebp]
  002a0 2b 4d 0c   sub         ecx, DWORD PTR __N0$[ebp]
  002a3 51                 push    ecx
  002a4 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  002a7 e8 00 00 00 00     call    ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  002ac 03 45 14   add         eax, DWORD PTR __Roff$[ebp]
  002af 03 45 18   add         eax, DWORD PTR __Count$[ebp]
  002b2 50                 push    eax
  002b3 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  002b6 e8 00 00 00 00     call    ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  002bb 03 45 08   add         eax, DWORD PTR __Off$[ebp]
  002be 03 45 0c   add         eax, DWORD PTR __N0$[ebp]
  002c1 50                 push    eax
  002c2 e8 00 00 00 00     call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
  002c7 83 c4 0c   add         esp, 12                        ; 0000000cH
$LN5@replace:

; 1438 :                          this->_Myptr() + _Roff + _Count,
; 1439 :                          _Count - _N0);  // fill rest of new hole
; 1440 :                  }
; 1441 :
; 1442 :              _Eos(_Newsize);

  002ca 8b 55 f4   mov         edx, DWORD PTR __Newsize$[ebp]
  002cd 52                 push    edx
  002ce 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  002d1 e8 00 00 00 00     call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1443 :              return (*this);

  002d6 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
$LN14@replace:

; 1444 :              }

  002d9 5e                 pop     esi
  002da 8b e5        mov         esp, ebp
  002dc 5d                 pop     ebp
  002dd c2 14 00   ret         20           ; 00000014H
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT   SEGMENT
__Newsize$1 = -12                                 ; size = 4
__Ptr$2 = -8                                            ; size = 4
_this$ = -4                                   ; size = 4
__Off$ = 8                                          ; size = 4
__Count$ = 12                                     ; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1342 :              {   // erase elements [_Off, _Off + _Count)

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 0c   sub         esp, 12                        ; 0000000cH
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1343 :              _Check_offset(_Off);

  00009 8b 45 08   mov         eax, DWORD PTR __Off$[ebp]
  0000c 50                 push    eax
  0000d 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00010 e8 00 00 00 00     call    ?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset

; 1344 :              if (this->_Mysize() - _Off <= _Count)

  00015 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00018 e8 00 00 00 00     call    ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  0001d 8b 08        mov         ecx, DWORD PTR [eax]
  0001f 2b 4d 08   sub         ecx, DWORD PTR __Off$[ebp]
  00022 3b 4d 0c   cmp         ecx, DWORD PTR __Count$[ebp]
  00025 77 0e        ja  SHORT $LN2@erase

; 1345 :                  _Eos(_Off);     // erase elements [_Off, ...)

  00027 8b 55 08   mov         edx, DWORD PTR __Off$[ebp]
  0002a 52                 push    edx
  0002b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0002e e8 00 00 00 00     call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
  00033 eb 4a        jmp         SHORT $LN3@erase
$LN2@erase:

; 1346 :              else if (0 < _Count)

  00035 83 7d 0c 00        cmp   DWORD PTR __Count$[ebp], 0
  00039 76 44        jbe         SHORT $LN3@erase

; 1347 :                  {       // move elements down
; 1348 :                  value_type *_Ptr = this->_Myptr() + _Off;

  0003b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0003e e8 00 00 00 00     call    ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  00043 03 45 08   add         eax, DWORD PTR __Off$[ebp]
  00046 89 45 f8   mov         DWORD PTR __Ptr$2[ebp], eax

; 1349 :                  size_type _Newsize = this->_Mysize() - _Count;

  00049 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0004c e8 00 00 00 00     call    ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  00051 8b 00        mov         eax, DWORD PTR [eax]
  00053 2b 45 0c   sub         eax, DWORD PTR __Count$[ebp]
  00056 89 45 f4   mov         DWORD PTR __Newsize$1[ebp], eax

; 1350 :                  _Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

  00059 8b 4d f4   mov         ecx, DWORD PTR __Newsize$1[ebp]
  0005c 2b 4d 08   sub         ecx, DWORD PTR __Off$[ebp]
  0005f 51                 push    ecx
  00060 8b 55 f8   mov         edx, DWORD PTR __Ptr$2[ebp]
  00063 03 55 0c   add         edx, DWORD PTR __Count$[ebp]
  00066 52                 push    edx
  00067 8b 45 f8   mov         eax, DWORD PTR __Ptr$2[ebp]
  0006a 50                 push    eax
  0006b e8 00 00 00 00     call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
  00070 83 c4 0c   add         esp, 12                        ; 0000000cH

; 1351 :                  _Eos(_Newsize);

  00073 8b 4d f4   mov         ecx, DWORD PTR __Newsize$1[ebp]
  00076 51                 push    ecx
  00077 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0007a e8 00 00 00 00     call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN3@erase:

; 1352 :                  }
; 1353 :              return (*this);

  0007f 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]

; 1354 :              }

  00082 8b e5        mov         esp, ebp
  00084 5d                 pop     ebp
  00085 c2 08 00   ret         8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Off$ = 8                                          ; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1335 :              {   // erase elements [_Off, ...)

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1336 :              _Check_offset(_Off);

  00007 8b 45 08   mov         eax, DWORD PTR __Off$[ebp]
  0000a 50                 push    eax
  0000b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000e e8 00 00 00 00     call    ?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset

; 1337 :              _Eos(_Off);

  00013 8b 4d 08   mov         ecx, DWORD PTR __Off$[ebp]
  00016 51                 push    ecx
  00017 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001a e8 00 00 00 00     call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1338 :              return (*this);

  0001f 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]

; 1339 :              }

  00022 8b e5        mov         esp, ebp
  00024 5d                 pop     ebp
  00025 c2 04 00   ret         4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Ptr$ = 8                                          ; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1175 :              {   // assign [_Ptr, <null>)

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1176 :              _DEBUG_POINTER(_Ptr);
; 1177 :              return (assign(_Ptr, _Traits::length(_Ptr)));

  00007 8b 45 08   mov         eax, DWORD PTR __Ptr$[ebp]
  0000a 50                 push    eax
  0000b e8 00 00 00 00     call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length
  00010 83 c4 04   add         esp, 4
  00013 50                 push    eax
  00014 8b 4d 08   mov         ecx, DWORD PTR __Ptr$[ebp]
  00017 51                 push    ecx
  00018 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001b e8 00 00 00 00     call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1178 :              }

  00020 8b e5        mov         esp, ebp
  00022 5d                 pop     ebp
  00023 c2 04 00   ret         4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Ptr$ = 8                                          ; size = 4
__Count$ = 12                                     ; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1160 :              {   // assign [_Ptr, _Ptr + _Count)

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1161 :              _DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1162 :              if (_Inside(_Ptr))

  00007 8b 45 08   mov         eax, DWORD PTR __Ptr$[ebp]
  0000a 50                 push    eax
  0000b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000e e8 00 00 00 00     call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
  00013 0f b6 c8   movzx       ecx, al
  00016 85 c9        test        ecx, ecx
  00018 74 20        je  SHORT $LN2@assign

; 1163 :                  return (assign(*this,

  0001a 8b 55 0c   mov         edx, DWORD PTR __Count$[ebp]
  0001d 52                 push    edx
  0001e 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00021 e8 00 00 00 00     call    ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  00026 8b 4d 08   mov         ecx, DWORD PTR __Ptr$[ebp]
  00029 2b c8        sub         ecx, eax
  0002b 51                 push    ecx
  0002c 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  0002f 52                 push    edx
  00030 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00033 e8 00 00 00 00     call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00038 eb 3d        jmp         SHORT $LN1@assign
$LN2@assign:

; 1164 :                          _Ptr - this->_Myptr(), _Count));        // substring
; 1165 :
; 1166 :              if (_Grow(_Count))

  0003a 6a 00        push        0
  0003c 8b 45 0c   mov         eax, DWORD PTR __Count$[ebp]
  0003f 50                 push    eax
  00040 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00043 e8 00 00 00 00     call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
  00048 0f b6 c8   movzx       ecx, al
  0004b 85 c9        test        ecx, ecx
  0004d 74 25        je  SHORT $LN3@assign

; 1167 :                  {       // make room and assign new stuff
; 1168 :                  _Traits::copy(this->_Myptr(), _Ptr, _Count);

  0004f 8b 55 0c   mov         edx, DWORD PTR __Count$[ebp]
  00052 52                 push    edx
  00053 8b 45 08   mov         eax, DWORD PTR __Ptr$[ebp]
  00056 50                 push    eax
  00057 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0005a e8 00 00 00 00     call    ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  0005f 50                 push    eax
  00060 e8 00 00 00 00     call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
  00065 83 c4 0c   add         esp, 12                        ; 0000000cH

; 1169 :                  _Eos(_Count);

  00068 8b 4d 0c   mov         ecx, DWORD PTR __Count$[ebp]
  0006b 51                 push    ecx
  0006c 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0006f e8 00 00 00 00     call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN3@assign:

; 1170 :                  }
; 1171 :              return (*this);

  00074 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
$LN1@assign:

; 1172 :              }

  00077 8b e5        mov         esp, ebp
  00079 5d                 pop     ebp
  0007a c2 08 00   ret         8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Right$ = 8                                            ; size = 4
__Roff$ = 12                                            ; size = 4
__Count$ = 16                                     ; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1144 :              {   // assign _Right [_Roff, _Roff + _Count)

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1145 :              _Right._Check_offset(_Roff);

  00007 8b 45 0c   mov         eax, DWORD PTR __Roff$[ebp]
  0000a 50                 push    eax
  0000b 8b 4d 08   mov         ecx, DWORD PTR __Right$[ebp]
  0000e e8 00 00 00 00     call    ?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset

; 1146 :              _Count = _Right._Clamp_suffix_size(_Roff, _Count);

  00013 8b 4d 10   mov         ecx, DWORD PTR __Count$[ebp]
  00016 51                 push    ecx
  00017 8b 55 0c   mov         edx, DWORD PTR __Roff$[ebp]
  0001a 52                 push    edx
  0001b 8b 4d 08   mov         ecx, DWORD PTR __Right$[ebp]
  0001e e8 00 00 00 00     call    ?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Clamp_suffix_size
  00023 89 45 10   mov         DWORD PTR __Count$[ebp], eax

; 1147 :
; 1148 :              if (this == &_Right)

  00026 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00029 3b 45 08   cmp         eax, DWORD PTR __Right$[ebp]
  0002c 75 1f        jne         SHORT $LN2@assign

; 1149 :                  erase((size_type)(_Roff + _Count)), erase(0, _Roff);    // substring

  0002e 8b 4d 0c   mov         ecx, DWORD PTR __Roff$[ebp]
  00031 03 4d 10   add         ecx, DWORD PTR __Count$[ebp]
  00034 51                 push    ecx
  00035 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00038 e8 00 00 00 00     call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  0003d 8b 55 0c   mov         edx, DWORD PTR __Roff$[ebp]
  00040 52                 push    edx
  00041 6a 00        push        0
  00043 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00046 e8 00 00 00 00     call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  0004b eb 42        jmp         SHORT $LN3@assign
$LN2@assign:

; 1150 :              else if (_Grow(_Count))

  0004d 6a 00        push        0
  0004f 8b 45 10   mov         eax, DWORD PTR __Count$[ebp]
  00052 50                 push    eax
  00053 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00056 e8 00 00 00 00     call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
  0005b 0f b6 c8   movzx       ecx, al
  0005e 85 c9        test        ecx, ecx
  00060 74 2d        je  SHORT $LN3@assign

; 1151 :                  {       // make room and assign new stuff
; 1152 :                  _Traits::copy(this->_Myptr(),

  00062 8b 55 10   mov         edx, DWORD PTR __Count$[ebp]
  00065 52                 push    edx
  00066 8b 4d 08   mov         ecx, DWORD PTR __Right$[ebp]
  00069 e8 00 00 00 00     call    ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  0006e 03 45 0c   add         eax, DWORD PTR __Roff$[ebp]
  00071 50                 push    eax
  00072 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00075 e8 00 00 00 00     call    ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  0007a 50                 push    eax
  0007b e8 00 00 00 00     call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
  00080 83 c4 0c   add         esp, 12                        ; 0000000cH

; 1153 :                          _Right._Myptr() + _Roff, _Count);
; 1154 :                  _Eos(_Count);

  00083 8b 45 10   mov         eax, DWORD PTR __Count$[ebp]
  00086 50                 push    eax
  00087 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0008a e8 00 00 00 00     call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN3@assign:

; 1155 :                  }
; 1156 :              return (*this);

  0008f 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]

; 1157 :              }

  00092 8b e5        mov         esp, ebp
  00094 5d                 pop     ebp
  00095 c2 0c 00   ret         12           ; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT   SEGMENT
__Num$ = -8                                   ; size = 4
_this$ = -4                                   ; size = 4
__Count$ = 8                                            ; size = 4
__Ch$ = 12                                          ; size = 1
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1106 :              {   // append _Count * _Ch

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1107 :              if (npos - this->_Mysize() <= _Count)

  00009 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000c e8 00 00 00 00     call    ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  00011 8b 0d 00 00 00
        00           mov     ecx, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
  00017 2b 08        sub         ecx, DWORD PTR [eax]
  00019 3b 4d 08   cmp         ecx, DWORD PTR __Count$[ebp]
  0001c 77 08        ja  SHORT $LN2@append

; 1108 :                  _Xlen();        // result too long

  0001e 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00021 e8 00 00 00 00     call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN2@append:

; 1109 :
; 1110 :              const size_type _Num = this->_Mysize() + _Count;

  00026 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00029 e8 00 00 00 00     call    ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  0002e 8b 10        mov         edx, DWORD PTR [eax]
  00030 03 55 08   add         edx, DWORD PTR __Count$[ebp]
  00033 89 55 f8   mov         DWORD PTR __Num$[ebp], edx

; 1111 :              if (0 < _Count && _Grow(_Num))

  00036 83 7d 08 00        cmp   DWORD PTR __Count$[ebp], 0
  0003a 76 3d        jbe         SHORT $LN3@append
  0003c 6a 00        push        0
  0003e 8b 45 f8   mov         eax, DWORD PTR __Num$[ebp]
  00041 50                 push    eax
  00042 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00045 e8 00 00 00 00     call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
  0004a 0f b6 c8   movzx       ecx, al
  0004d 85 c9        test        ecx, ecx
  0004f 74 28        je  SHORT $LN3@append

; 1112 :                  {       // make room and append new stuff using assign
; 1113 :                  _Chassign(this->_Mysize(), _Count, _Ch);

  00051 0f b6 55 0c        movzx         edx, BYTE PTR __Ch$[ebp]
  00055 52                 push    edx
  00056 8b 45 08   mov         eax, DWORD PTR __Count$[ebp]
  00059 50                 push    eax
  0005a 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0005d e8 00 00 00 00     call    ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  00062 8b 08        mov         ecx, DWORD PTR [eax]
  00064 51                 push    ecx
  00065 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00068 e8 00 00 00 00     call    ?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign

; 1114 :                  _Eos(_Num);

  0006d 8b 55 f8   mov         edx, DWORD PTR __Num$[ebp]
  00070 52                 push    edx
  00071 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00074 e8 00 00 00 00     call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN3@append:

; 1115 :                  }
; 1116 :              return (*this);

  00079 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
$LN4@append:

; 1117 :              }

  0007c 8b e5        mov         esp, ebp
  0007e 5d                 pop     ebp
  0007f c2 08 00   ret         8
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 1011 :              {   // destroy the string

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 1012 :              _Tidy(true);

  00007 6a 00        push        0
  00009 6a 01        push        1
  0000b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000e e8 00 00 00 00     call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 1013 :              }

  00013 8b e5        mov         esp, ebp
  00015 5d                 pop     ebp
  00016 c3                 ret     0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Right$ = 8                                            ; size = 4
?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv, COMDAT
; _this$ = ecx

; 956  :              {   // assign by moving _Right

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 56                 push    esi
  00005 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 957  :              if (_Right._Myres() < this->_BUF_SIZE)

  00008 8b 4d 08   mov         ecx, DWORD PTR __Right$[ebp]
  0000b e8 00 00 00 00     call    ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
  00010 83 38 10   cmp         DWORD PTR [eax], 16    ; 00000010H
  00013 73 2a        jae         SHORT $LN2@Assign_rv

; 958  :                  _Traits::move(this->_Bx()._Buf, _Right._Bx()._Buf,

  00015 8b 4d 08   mov         ecx, DWORD PTR __Right$[ebp]
  00018 e8 00 00 00 00     call    ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  0001d 8b 00        mov         eax, DWORD PTR [eax]
  0001f 83 c0 01   add         eax, 1
  00022 50                 push    eax
  00023 8b 4d 08   mov         ecx, DWORD PTR __Right$[ebp]
  00026 e8 00 00 00 00     call    ?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx
  0002b 50                 push    eax
  0002c 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0002f e8 00 00 00 00     call    ?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx
  00034 50                 push    eax
  00035 e8 00 00 00 00     call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
  0003a 83 c4 0c   add         esp, 12                        ; 0000000cH

; 959  :                          _Right._Mysize() + 1);
; 960  :              else

  0003d eb 2f        jmp         SHORT $LN3@Assign_rv
$LN2@Assign_rv:

; 961  :                  {       // copy pointer
; 962  :                  this->_Getal().construct(&this->_Bx()._Ptr, _Right._Bx()._Ptr);

  0003f 8b 4d 08   mov         ecx, DWORD PTR __Right$[ebp]
  00042 e8 00 00 00 00     call    ?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx
  00047 50                 push    eax
  00048 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0004b e8 00 00 00 00     call    ?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx
  00050 50                 push    eax
  00051 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00054 e8 00 00 00 00     call    ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
  00059 8b c8        mov         ecx, eax
  0005b e8 00 00 00 00     call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 963  :                  _Right._Bx()._Ptr = pointer();

  00060 8b 4d 08   mov         ecx, DWORD PTR __Right$[ebp]
  00063 e8 00 00 00 00     call    ?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx
  00068 c7 00 00 00 00
        00           mov     DWORD PTR [eax], 0
$LN3@Assign_rv:

; 964  :                  }
; 965  :              this->_Mysize() = _Right._Mysize();

  0006e 8b 4d 08   mov         ecx, DWORD PTR __Right$[ebp]
  00071 e8 00 00 00 00     call    ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  00076 8b f0        mov         esi, eax
  00078 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0007b e8 00 00 00 00     call    ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  00080 8b 0e        mov         ecx, DWORD PTR [esi]
  00082 89 08        mov         DWORD PTR [eax], ecx

; 966  :              this->_Myres() = _Right._Myres();

  00084 8b 4d 08   mov         ecx, DWORD PTR __Right$[ebp]
  00087 e8 00 00 00 00     call    ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
  0008c 8b f0        mov         esi, eax
  0008e 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00091 e8 00 00 00 00     call    ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
  00096 8b 16        mov         edx, DWORD PTR [esi]
  00098 89 10        mov         DWORD PTR [eax], edx

; 967  :              _Right._Tidy();

  0009a 6a 00        push        0
  0009c 6a 00        push        0
  0009e 8b 4d 08   mov         ecx, DWORD PTR __Right$[ebp]
  000a1 e8 00 00 00 00     call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 968  :              }

  000a6 5e                 pop     esi
  000a7 8b e5        mov         esp, ebp
  000a9 5d                 pop     ebp
  000aa c2 04 00   ret         4
?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z
_TEXT   SEGMENT
$T1 = -12                                         ; size = 4
$T2 = -8                                                ; size = 4
_this$ = -4                                   ; size = 4
__Right$ = 8                                            ; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 923  :              {   // assign by moving _Right

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 0c   sub         esp, 12                        ; 0000000cH
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 924  :              if (this != &_Right)

  00009 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000c 3b 45 08   cmp         eax, DWORD PTR __Right$[ebp]
  0000f 0f 84 a5 00 00
        00           je      $LN2@operator

; 925  :                  {       // different, assign it
; 926  :                  _Tidy(true);

  00015 6a 00        push        0
  00017 6a 01        push        1
  00019 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001c e8 00 00 00 00     call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 927  :
; 928  :                  if (_Alty::propagate_on_container_move_assignment::value
; 929  :                          && this->_Getal() != _Right._Getal())

  00021 b9 01 00 00 00     mov     ecx, 1
  00026 85 c9        test        ecx, ecx
  00028 74 32        je  SHORT $LN3@operator
  0002a 8b 4d 08   mov         ecx, DWORD PTR __Right$[ebp]
  0002d e8 00 00 00 00     call    ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
  00032 50                 push    eax
  00033 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00036 e8 00 00 00 00     call    ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
  0003b 50                 push    eax
  0003c e8 00 00 00 00     call    ??$?9V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ; std::operator!=<std::allocator<char>,std::allocator<char> >
  00041 83 c4 08   add         esp, 8
  00044 0f b6 d0   movzx       edx, al
  00047 85 d2        test        edx, edx
  00049 74 11        je  SHORT $LN3@operator

; 930  :                          this->_Move_alloc(_Right._Getal());

  0004b 8b 4d 08   mov         ecx, DWORD PTR __Right$[ebp]
  0004e e8 00 00 00 00     call    ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
  00053 50                 push    eax
  00054 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00057 e8 00 00 00 00     call    ?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Move_alloc
$LN3@operator:

; 931  :
; 932  :                  if (this->_Getal() != _Right._Getal())

  0005c 8b 4d 08   mov         ecx, DWORD PTR __Right$[ebp]
  0005f e8 00 00 00 00     call    ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
  00064 50                 push    eax
  00065 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00068 e8 00 00 00 00     call    ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
  0006d 50                 push    eax
  0006e e8 00 00 00 00     call    ??$?9V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ; std::operator!=<std::allocator<char>,std::allocator<char> >
  00073 83 c4 08   add         esp, 8
  00076 0f b6 c0   movzx       eax, al
  00079 85 c0        test        eax, eax
  0007b 74 28        je  SHORT $LN4@operator

; 933  :                          assign(_Right.begin(), _Right.end());

  0007d 8d 4d f8   lea         ecx, DWORD PTR $T2[ebp]
  00080 51                 push    ecx
  00081 8b 4d 08   mov         ecx, DWORD PTR __Right$[ebp]
  00084 e8 00 00 00 00     call    ?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end
  00089 8b 10        mov         edx, DWORD PTR [eax]
  0008b 52                 push    edx
  0008c 8d 45 f4   lea         eax, DWORD PTR $T1[ebp]
  0008f 50                 push    eax
  00090 8b 4d 08   mov         ecx, DWORD PTR __Right$[ebp]
  00093 e8 00 00 00 00     call    ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
  00098 8b 08        mov         ecx, DWORD PTR [eax]
  0009a 51                 push    ecx
  0009b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0009e e8 00 00 00 00     call    ??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > >

; 934  :                  else

  000a3 eb 15        jmp         SHORT $LN2@operator
$LN4@operator:

; 935  :                          _Assign_rv(_STD forward<_Myt>(_Right));

  000a5 8b 55 08   mov         edx, DWORD PTR __Right$[ebp]
  000a8 52                 push    edx
  000a9 e8 00 00 00 00     call    ??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  000ae 83 c4 04   add         esp, 4
  000b1 50                 push    eax
  000b2 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  000b5 e8 00 00 00 00     call    ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
$LN2@operator:

; 936  :                  }
; 937  :              return (*this);

  000ba 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]

; 938  :              }

  000bd 8b e5        mov         esp, ebp
  000bf 5d                 pop     ebp
  000c0 c2 04 00   ret         4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Right$ = 8                                            ; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 906  :              {   // construct by moving _Right

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 905  :              : _Mybase(_STD move(_Right._Getal()))

  00007 8b 4d 08   mov         ecx, DWORD PTR __Right$[ebp]
  0000a e8 00 00 00 00     call    ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
  0000f 50                 push    eax
  00010 e8 00 00 00 00     call    ??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ; std::move<std::_Wrap_alloc<std::allocator<char> > &>
  00015 83 c4 04   add         esp, 4
  00018 50                 push    eax
  00019 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001c e8 00 00 00 00     call    ??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::_Wrap_alloc<std::allocator<char> >,void>

; 907  :              _Tidy();

  00021 6a 00        push        0
  00023 6a 00        push        0
  00025 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00028 e8 00 00 00 00     call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 908  :              _Assign_rv(_STD forward<_Myt>(_Right));

  0002d 8b 45 08   mov         eax, DWORD PTR __Right$[ebp]
  00030 50                 push    eax
  00031 e8 00 00 00 00     call    ??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  00036 83 c4 04   add         esp, 4
  00039 50                 push    eax
  0003a 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0003d e8 00 00 00 00     call    ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv

; 909  :              }

  00042 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00045 8b e5        mov         esp, ebp
  00047 5d                 pop     ebp
  00048 c2 04 00   ret         4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Ptr$ = 8                                          ; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 830  :              {   // construct from [_Ptr, <null>)

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 829  :              : _Mybase()

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >

; 831  :              _Tidy();

  0000f 6a 00        push        0
  00011 6a 00        push        0
  00013 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00016 e8 00 00 00 00     call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 832  :              assign(_Ptr);

  0001b 8b 45 08   mov         eax, DWORD PTR __Ptr$[ebp]
  0001e 50                 push    eax
  0001f 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00022 e8 00 00 00 00     call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 833  :              }

  00027 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0002a 8b e5        mov         esp, ebp
  0002c 5d                 pop     ebp
  0002d c2 04 00   ret         4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 788  :              {   // construct empty string

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 787  :              : _Mybase()

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >

; 789  :              _Tidy();

  0000f 6a 00        push        0
  00011 6a 00        push        0
  00013 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00016 e8 00 00 00 00     call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 790  :              }

  0001b 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0001e 8b e5        mov         esp, ebp
  00020 5d                 pop     ebp
  00021 c3                 ret     0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 318  :              {   // return const reference to second

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 319  :              return (_Myval2);

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]

; 320  :              }

  0000a 8b e5        mov         esp, ebp
  0000c 5d                 pop     ebp
  0000d c3                 ret     0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 313  :              {   // return reference to second

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 314  :              return (_Myval2);

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]

; 315  :              }

  0000a 8b e5        mov         esp, ebp
  0000c 5d                 pop     ebp
  0000d c3                 ret     0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 298  :              {   // return const reference to first

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 299  :              return (*this);

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]

; 300  :              }

  0000a 8b e5        mov         esp, ebp
  0000c 5d                 pop     ebp
  0000d c3                 ret     0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 293  :              {   // return reference to first

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 294  :              return (*this);

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]

; 295  :              }

  0000a 8b e5        mov         esp, ebp
  0000c 5d                 pop     ebp
  0000d c3                 ret     0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres, COMDAT
; _this$ = ecx

; 727  :              {   // return reference to _Myres

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 728  :              return (_Get_data()._Myres);

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
  0000f 83 c0 14   add         eax, 20                        ; 00000014H

; 729  :              }

  00012 8b e5        mov         esp, ebp
  00014 5d                 pop     ebp
  00015 c3                 ret     0
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize, COMDAT
; _this$ = ecx

; 722  :              {   // return const reference to _Mysize

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 723  :              return (_Get_data()._Mysize);

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
  0000f 83 c0 10   add         eax, 16                        ; 00000010H

; 724  :              }

  00012 8b e5        mov         esp, ebp
  00014 5d                 pop     ebp
  00015 c3                 ret     0
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize, COMDAT
; _this$ = ecx

; 717  :              {   // return reference to _Mysize

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 718  :              return (_Get_data()._Mysize);

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
  0000f 83 c0 10   add         eax, 16                        ; 00000010H

; 719  :              }

  00012 8b e5        mov         esp, ebp
  00014 5d                 pop     ebp
  00015 c3                 ret     0
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx, COMDAT
; _this$ = ecx

; 707  :              {   // return reference to _Bx

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 708  :              return (_Get_data()._Bx);

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data

; 709  :              }

  0000f 8b e5        mov         esp, ebp
  00011 5d                 pop     ebp
  00012 c3                 ret     0
?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 700  :              {   // return const reference to _String_val

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 701  :              return (_Mypair._Get_second());

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second

; 702  :              }

  0000f 8b e5        mov         esp, ebp
  00011 5d                 pop     ebp
  00012 c3                 ret     0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 695  :              {   // return reference to _String_val

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 696  :              return (_Mypair._Get_second());

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second

; 697  :              }

  0000f 8b e5        mov         esp, ebp
  00011 5d                 pop     ebp
  00012 c3                 ret     0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 690  :              {   // return const reference to allocator

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 691  :              return (_Mypair._Get_first());

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 692  :              }

  0000f 8b e5        mov         esp, ebp
  00011 5d                 pop     ebp
  00012 c3                 ret     0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 685  :              {   // return reference to allocator

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 686  :              return (_Mypair._Get_first());

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 687  :              }

  0000f 8b e5        mov         esp, ebp
  00011 5d                 pop     ebp
  00012 c3                 ret     0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Al$ = 8                                         ; size = 4
?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Move_alloc, COMDAT
; _this$ = ecx

; 589  :              {   // replace old allocator

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 590  :              _Pocma(_Getal(), _Al);

  00007 8b 45 08   mov         eax, DWORD PTR __Al$[ebp]
  0000a 50                 push    eax
  0000b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000e e8 00 00 00 00     call    ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
  00013 50                 push    eax
  00014 e8 00 00 00 00     call    ??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ; std::_Pocma<std::_Wrap_alloc<std::allocator<char> > >
  00019 83 c4 08   add         esp, 8

; 591  :              }

  0001c 8b e5        mov         esp, ebp
  0001e 5d                 pop     ebp
  0001f c2 04 00   ret         4
?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Move_alloc
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT   SEGMENT
_this$ = -8                                   ; size = 4
$T1 = -1                                                ; size = 1
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 572  :              {   // default construct allocator

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d f8   mov         DWORD PTR _this$[ebp], ecx

; 571  :              : _Mypair(_Zero_then_variadic_args_t())

  00009 0f b6 45 ff        movzx         eax, BYTE PTR $T1[ebp]
  0000d 50                 push    eax
  0000e 8b 4d f8   mov         ecx, DWORD PTR _this$[ebp]
  00011 e8 00 00 00 00     call    ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><>

; 573  :              }

  00016 8b 45 f8   mov         eax, DWORD PTR _this$[ebp]
  00019 8b e5        mov         esp, ebp
  0001b 5d                 pop     ebp
  0001c c3                 ret     0
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr, COMDAT
; _this$ = ecx

; 565  :              {   // determine current pointer to buffer for nonmutable string

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 566  :              return (_Get_data()._Myptr());

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
  0000f 8b c8        mov         ecx, eax
  00011 e8 00 00 00 00     call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr

; 567  :              }

  00016 8b e5        mov         esp, ebp
  00018 5d                 pop     ebp
  00019 c3                 ret     0
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr, COMDAT
; _this$ = ecx

; 560  :              {   // determine current pointer to buffer for mutable string

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 561  :              return (_Get_data()._Myptr());

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
  0000f 8b c8        mov         ecx, eax
  00011 e8 00 00 00 00     call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr

; 562  :              }

  00016 8b e5        mov         esp, ebp
  00018 5d                 pop     ebp
  00019 c3                 ret     0
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT   SEGMENT
tv72 = -8                                         ; size = 4
_this$ = -4                                   ; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 511  :              {   // determine current pointer to buffer for nonmutable string

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 512  :              return (this->_BUF_SIZE <= this->_Myres

  00009 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000c 83 78 14 10        cmp   DWORD PTR [eax+20], 16     ; 00000010H
  00010 72 13        jb  SHORT $LN3@Myptr
  00012 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00015 8b 11        mov         edx, DWORD PTR [ecx]
  00017 52                 push    edx
  00018 e8 00 00 00 00     call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>
  0001d 83 c4 04   add         esp, 4
  00020 89 45 f8   mov         DWORD PTR tv72[ebp], eax
  00023 eb 06        jmp         SHORT $LN4@Myptr
$LN3@Myptr:
  00025 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00028 89 45 f8   mov         DWORD PTR tv72[ebp], eax
$LN4@Myptr:
  0002b 8b 45 f8   mov         eax, DWORD PTR tv72[ebp]

; 513  :                  ? _STD addressof(*this->_Bx._Ptr)
; 514  :                  : this->_Bx._Buf);
; 515  :              }

  0002e 8b e5        mov         esp, ebp
  00030 5d                 pop     ebp
  00031 c3                 ret     0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT   SEGMENT
tv72 = -8                                         ; size = 4
_this$ = -4                                   ; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 504  :              {   // determine current pointer to buffer for mutable string

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 505  :              return (this->_BUF_SIZE <= this->_Myres

  00009 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000c 83 78 14 10        cmp   DWORD PTR [eax+20], 16     ; 00000010H
  00010 72 13        jb  SHORT $LN3@Myptr
  00012 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00015 8b 11        mov         edx, DWORD PTR [ecx]
  00017 52                 push    edx
  00018 e8 00 00 00 00     call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>
  0001d 83 c4 04   add         esp, 4
  00020 89 45 f8   mov         DWORD PTR tv72[ebp], eax
  00023 eb 06        jmp         SHORT $LN4@Myptr
$LN3@Myptr:
  00025 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00028 89 45 f8   mov         DWORD PTR tv72[ebp], eax
$LN4@Myptr:
  0002b 8b 45 f8   mov         eax, DWORD PTR tv72[ebp]

; 506  :                  ? _STD addressof(*this->_Bx._Ptr)
; 507  :                  : this->_Bx._Buf);
; 508  :              }

  0002e 8b e5        mov         esp, ebp
  00030 5d                 pop     ebp
  00031 c3                 ret     0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;       COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 486  :        _String_val()

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 487  :              {   // initialize values
; 488  :              _Mysize = 0;

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a c7 40 10 00 00
        00 00          mov         DWORD PTR [eax+16], 0

; 489  :              _Myres = 0;

  00011 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00014 c7 41 14 00 00
        00 00          mov         DWORD PTR [ecx+20], 0

; 490  :              }

  0001b 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0001e 8b e5        mov         esp, ebp
  00020 5d                 pop     ebp
  00021 c3                 ret     0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;       COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
___formal$ = 8                                      ; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 905  :              {   // get maximum size

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 906  :              return (_Mytraits::max_size(*this));

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a 50                 push    eax
  0000b e8 00 00 00 00     call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
  00010 83 c4 04   add         esp, 4

; 907  :              }

  00013 8b e5        mov         esp, ebp
  00015 5d                 pop     ebp
  00016 c2 04 00   ret         4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;       COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Ptr$ = 8                                          ; size = 4
__Count$ = 12                                     ; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 884  :              {   // deallocate object at _Ptr, ignore size

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 885  :              _Mybase::deallocate(_Ptr, _Count);

  00007 8b 45 0c   mov         eax, DWORD PTR __Count$[ebp]
  0000a 50                 push    eax
  0000b 8b 4d 08   mov         ecx, DWORD PTR __Ptr$[ebp]
  0000e 51                 push    ecx
  0000f 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00012 e8 00 00 00 00     call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 886  :              }

  00017 8b e5        mov         esp, ebp
  00019 5d                 pop     ebp
  0001a c2 08 00   ret         8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;       COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Count$ = 8                                            ; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 873  :              {   // allocate array of _Count elements

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 874  :              return (_Mybase::allocate(_Count));

  00007 8b 45 08   mov         eax, DWORD PTR __Count$[ebp]
  0000a 50                 push    eax
  0000b 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000e e8 00 00 00 00     call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate

; 875  :              }

  00013 8b e5        mov         esp, ebp
  00015 5d                 pop     ebp
  00016 c2 04 00   ret         4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;       COMDAT ??4?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEAAU01@$$QAU01@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Right$ = 8                                            ; size = 4
??4?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEAAU01@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 860  :              {   // assign by moving

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 861  :              _Mybase::operator=(_STD move(_Right));

  00007 8b 45 08   mov         eax, DWORD PTR __Right$[ebp]
  0000a 50                 push    eax
  0000b e8 00 00 00 00     call    ??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ; std::move<std::_Wrap_alloc<std::allocator<char> > &>
  00010 83 c4 04   add         esp, 4

; 862  :              return (*this);

  00013 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]

; 863  :              }

  00016 8b e5        mov         esp, ebp
  00018 5d                 pop     ebp
  00019 c2 04 00   ret         4
??4?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEAAU01@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::operator=
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;       COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Right$ = 8                                            ; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 844  :              {   // construct by moving

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 843  :              : _Mybase(_STD move(_Right))

  00007 8b 45 08   mov         eax, DWORD PTR __Right$[ebp]
  0000a 50                 push    eax
  0000b e8 00 00 00 00     call    ??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ; std::move<std::_Wrap_alloc<std::allocator<char> > &>
  00010 83 c4 04   add         esp, 4
  00013 50                 push    eax
  00014 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00017 e8 00 00 00 00     call    ??0?$allocator@D@std@@QAE@ABV01@@Z ; std::allocator<char>::allocator<char>

; 845  :              }

  0001c 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0001f 8b e5        mov         esp, ebp
  00021 5d                 pop     ebp
  00022 c2 04 00   ret         4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;       COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC  ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 834  :              {   // construct default allocator (do nothing)

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 833  :              : _Mybase()

  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>

; 835  :              }

  0000f 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00012 8b e5        mov         esp, ebp
  00014 5d                 pop     ebp
  00015 c3                 ret     0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP  ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;       COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT   SEGMENT
__Al$ = 8                                         ; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 766  :              {   // get maximum size

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 767  :              return (_Al.max_size());

  00003 8b 4d 08   mov         ecx, DWORD PTR __Al$[ebp]
  00006 e8 00 00 00 00     call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size

; 768  :              }

  0000b 5d                 pop     ebp
  0000c c3                 ret     0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;       COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC                ; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 648  :              {   // estimate maximum array size

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 649  :              return ((size_t)(-1) / sizeof (_Ty));

  00007 83 c8 ff   or  eax, -1

; 650  :              }

  0000a 8b e5        mov         esp, ebp
  0000c 5d                 pop     ebp
  0000d c3                 ret     0
?max_size@?$allocator@D@std@@QBEIXZ ENDP                ; std::allocator<char>::max_size
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;       COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Count$ = 8                                            ; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC       ; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 624  :              {   // allocate array of _Count elements

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 625  :              return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

  00007 6a 01        push        1
  00009 6a 01        push        1
  0000b 8b 45 08   mov         eax, DWORD PTR __Count$[ebp]
  0000e 50                 push    eax
  0000f e8 00 00 00 00     call    ?_Allocate@std@@YAPAXII_N@Z ; std::_Allocate
  00014 83 c4 0c   add         esp, 12                        ; 0000000cH

; 626  :              }

  00017 8b e5        mov         esp, ebp
  00019 5d                 pop     ebp
  0001a c2 04 00   ret         4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP       ; std::allocator<char>::allocate
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;       COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Ptr$ = 8                                          ; size = 4
__Count$ = 12                                     ; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC      ; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 619  :              {   // deallocate object at _Ptr

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 620  :              _Deallocate(_Ptr, _Count, sizeof (_Ty));

  00007 6a 01        push        1
  00009 8b 45 0c   mov         eax, DWORD PTR __Count$[ebp]
  0000c 50                 push    eax
  0000d 8b 4d 08   mov         ecx, DWORD PTR __Ptr$[ebp]
  00010 51                 push    ecx
  00011 e8 00 00 00 00     call    ?_Deallocate@std@@YAXPAXII@Z ; std::_Deallocate
  00016 83 c4 0c   add         esp, 12                        ; 0000000cH

; 621  :              }

  00019 8b e5        mov         esp, ebp
  0001b 5d                 pop     ebp
  0001c c2 08 00   ret         8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP      ; std::allocator<char>::deallocate
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;       COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
___formal$ = 8                                      ; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC       ; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 603  :        allocator(const allocator<_Ty>&) _THROW0()

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 604  :              {   // construct by copying (do nothing)
; 605  :              }

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a 8b e5        mov         esp, ebp
  0000c 5d                 pop     ebp
  0000d c2 04 00   ret         4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP       ; std::allocator<char>::allocator<char>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;       COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??0?$allocator@D@std@@QAE@XZ PROC                 ; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 599  :        allocator() _THROW0()

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 600  :              {   // construct default allocator (do nothing)
; 601  :              }

  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a 8b e5        mov         esp, ebp
  0000c 5d                 pop     ebp
  0000d c3                 ret     0
??0?$allocator@D@std@@QAE@XZ ENDP                 ; std::allocator<char>::allocator<char>
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xatomic0.h
;       COMDAT ?_Init_atomic_counter@std@@YAXAAKK@Z
_TEXT   SEGMENT
__Counter$ = 8                                      ; size = 4
__Value$ = 12                                     ; size = 4
?_Init_atomic_counter@std@@YAXAAKK@Z PROC             ; std::_Init_atomic_counter, COMDAT

; 62   :        {     // non-atomically initialize counter

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 63   :        _Counter = _Value;

  00003 8b 45 08   mov         eax, DWORD PTR __Counter$[ebp]
  00006 8b 4d 0c   mov         ecx, DWORD PTR __Value$[ebp]
  00009 89 08        mov         DWORD PTR [eax], ecx

; 64   :        }

  0000b 5d                 pop     ebp
  0000c c3                 ret     0
?_Init_atomic_counter@std@@YAXAAKK@Z ENDP             ; std::_Init_atomic_counter
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;       COMDAT ?_Deallocate@std@@YAXPAXII@Z
_TEXT   SEGMENT
__Ptr_ptr$1 = -16                                 ; size = 4
__User_size$ = -12                                  ; size = 4
__Ptr_container$2 = -8                              ; size = 4
__Ptr_user$3 = -4                                 ; size = 4
__Ptr$ = 8                                          ; size = 4
__Count$ = 12                                     ; size = 4
__Sz$ = 16                                          ; size = 4
?_Deallocate@std@@YAXPAXII@Z PROC                 ; std::_Deallocate, COMDAT

; 92   :        {     // deallocate storage for _Count elements of size _Sz

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 10   sub         esp, 16                        ; 00000010H

; 93   :  #if defined(_M_IX86) || defined(_M_X64)
; 94   :        _SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00006 83 c8 ff   or  eax, -1
  00009 33 d2        xor         edx, edx
  0000b f7 75 10   div         DWORD PTR __Sz$[ebp]
  0000e 39 45 0c   cmp         DWORD PTR __Count$[ebp], eax
  00011 76 05        jbe         SHORT $LN2@Deallocate
  00013 e8 00 00 00 00     call    __invalid_parameter_noinfo_noreturn
$LN2@Deallocate:

; 95   :        const size_t _User_size = _Count * _Sz;

  00018 8b 45 0c   mov         eax, DWORD PTR __Count$[ebp]
  0001b 0f af 45 10        imul  eax, DWORD PTR __Sz$[ebp]
  0001f 89 45 f4   mov         DWORD PTR __User_size$[ebp], eax

; 96   :        if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  00022 81 7d f4 00 10
        00 00          cmp         DWORD PTR __User_size$[ebp], 4096 ; 00001000H
  00029 72 57        jb  SHORT $LN3@Deallocate

; 97   :              {   // deallocate large block
; 98   :              const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);

  0002b 8b 4d 08   mov         ecx, DWORD PTR __Ptr$[ebp]
  0002e 89 4d fc   mov         DWORD PTR __Ptr_user$3[ebp], ecx

; 99   :              _SCL_SECURE_ALWAYS_VALIDATE(

  00031 8b 55 fc   mov         edx, DWORD PTR __Ptr_user$3[ebp]
  00034 83 e2 1f   and         edx, 31                        ; 0000001fH
  00037 74 05        je  SHORT $LN4@Deallocate
  00039 e8 00 00 00 00     call    __invalid_parameter_noinfo_noreturn
$LN4@Deallocate:

; 100  :                  (_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  :              const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);

  0003e 8b 45 fc   mov         eax, DWORD PTR __Ptr_user$3[ebp]
  00041 83 e8 04   sub         eax, 4
  00044 89 45 f0   mov         DWORD PTR __Ptr_ptr$1[ebp], eax

; 102  :              const uintptr_t _Ptr_container =
; 103  :                  *reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00047 8b 4d f0   mov         ecx, DWORD PTR __Ptr_ptr$1[ebp]
  0004a 8b 11        mov         edx, DWORD PTR [ecx]
  0004c 89 55 f8   mov         DWORD PTR __Ptr_container$2[ebp], edx

; 104  :
; 105  :  #ifdef _DEBUG
; 106  :              // If the following asserts, it likely means that we are performing
; 107  :              // an aligned delete on memory coming from an unaligned allocation.
; 108  :              _SCL_SECURE_ALWAYS_VALIDATE(
; 109  :                  reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  :                          _BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  :
; 113  :              // Extra paranoia on aligned allocation/deallocation
; 114  :              _SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  0004f 8b 45 f8   mov         eax, DWORD PTR __Ptr_container$2[ebp]
  00052 3b 45 fc   cmp         eax, DWORD PTR __Ptr_user$3[ebp]
  00055 72 05        jb  SHORT $LN5@Deallocate
  00057 e8 00 00 00 00     call    __invalid_parameter_noinfo_noreturn
$LN5@Deallocate:

; 115  :
; 116  :  #ifdef _DEBUG
; 117  :              _SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  :                  <= _Ptr_user - _Ptr_container);
; 119  :
; 120  :  #else /* _DEBUG */
; 121  :              _SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  0005c 8b 4d fc   mov         ecx, DWORD PTR __Ptr_user$3[ebp]
  0005f 2b 4d f8   sub         ecx, DWORD PTR __Ptr_container$2[ebp]
  00062 83 f9 04   cmp         ecx, 4
  00065 73 05        jae         SHORT $LN6@Deallocate
  00067 e8 00 00 00 00     call    __invalid_parameter_noinfo_noreturn
$LN6@Deallocate:

; 122  :                  <= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  :
; 125  :              _SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  0006c 8b 55 fc   mov         edx, DWORD PTR __Ptr_user$3[ebp]
  0006f 2b 55 f8   sub         edx, DWORD PTR __Ptr_container$2[ebp]
  00072 83 fa 23   cmp         edx, 35                        ; 00000023H
  00075 76 05        jbe         SHORT $LN7@Deallocate
  00077 e8 00 00 00 00     call    __invalid_parameter_noinfo_noreturn
$LN7@Deallocate:

; 126  :                  <= _NON_USER_SIZE);
; 127  :
; 128  :              _Ptr = reinterpret_cast<void *>(_Ptr_container);

  0007c 8b 45 f8   mov         eax, DWORD PTR __Ptr_container$2[ebp]
  0007f 89 45 08   mov         DWORD PTR __Ptr$[ebp], eax
$LN3@Deallocate:

; 129  :              }
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  :
; 132  :        ::operator delete(_Ptr);

  00082 8b 4d 08   mov         ecx, DWORD PTR __Ptr$[ebp]
  00085 51                 push    ecx
  00086 e8 00 00 00 00     call    ??3@YAXPAX@Z   ; operator delete
  0008b 83 c4 04   add         esp, 4
$LN8@Deallocate:

; 133  :        }

  0008e 8b e5        mov         esp, ebp
  00090 5d                 pop     ebp
  00091 c3                 ret     0
?_Deallocate@std@@YAXPAXII@Z ENDP                 ; std::_Deallocate
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;       COMDAT ?_Allocate@std@@YAPAXII_N@Z
_TEXT   SEGMENT
__Block_size$1 = -16                                    ; size = 4
__Ptr_container$2 = -12                       ; size = 4
__User_size$ = -8                                 ; size = 4
__Ptr$ = -4                                   ; size = 4
__Count$ = 8                                            ; size = 4
__Sz$ = 12                                          ; size = 4
__Try_aligned_allocation$ = 16                      ; size = 1
?_Allocate@std@@YAPAXII_N@Z PROC                        ; std::_Allocate, COMDAT

; 48   :        {     // allocate storage for _Count elements of size _Sz

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 10   sub         esp, 16                        ; 00000010H

; 49   :        void *_Ptr = 0;

  00006 c7 45 fc 00 00
        00 00          mov         DWORD PTR __Ptr$[ebp], 0

; 50   :
; 51   :        if (_Count == 0)

  0000d 83 7d 08 00        cmp   DWORD PTR __Count$[ebp], 0
  00011 75 08        jne         SHORT $LN2@Allocate

; 52   :              return (_Ptr);

  00013 8b 45 fc   mov         eax, DWORD PTR __Ptr$[ebp]
  00016 e9 99 00 00 00     jmp     $LN9@Allocate
$LN2@Allocate:

; 53   :
; 54   :        // check overflow of multiply
; 55   :        if ((size_t)(-1) / _Sz < _Count)

  0001b 83 c8 ff   or  eax, -1
  0001e 33 d2        xor         edx, edx
  00020 f7 75 0c   div         DWORD PTR __Sz$[ebp]
  00023 3b 45 08   cmp         eax, DWORD PTR __Count$[ebp]
  00026 73 05        jae         SHORT $LN3@Allocate

; 56   :              _Xbad_alloc();      // report no memory

  00028 e8 00 00 00 00     call    ?_Xbad_alloc@std@@YAXXZ      ; std::_Xbad_alloc
$LN3@Allocate:

; 57   :        const size_t _User_size = _Count * _Sz;

  0002d 8b 45 08   mov         eax, DWORD PTR __Count$[ebp]
  00030 0f af 45 0c        imul  eax, DWORD PTR __Sz$[ebp]
  00034 89 45 f8   mov         DWORD PTR __User_size$[ebp], eax

; 58   :
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   :        if (_Try_aligned_allocation
; 61   :              && _BIG_ALLOCATION_THRESHOLD <= _User_size)

  00037 0f b6 4d 10        movzx         ecx, BYTE PTR __Try_aligned_allocation$[ebp]
  0003b 85 c9        test        ecx, ecx
  0003d 74 58        je  SHORT $LN4@Allocate
  0003f 81 7d f8 00 10
        00 00          cmp         DWORD PTR __User_size$[ebp], 4096 ; 00001000H
  00046 72 4f        jb  SHORT $LN4@Allocate

; 62   :              {   // allocate large block
; 63   :              static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   :                  "Big allocations should at least match vector register size");
; 65   :              const size_t _Block_size = _NON_USER_SIZE + _User_size;

  00048 8b 55 f8   mov         edx, DWORD PTR __User_size$[ebp]
  0004b 83 c2 23   add         edx, 35                        ; 00000023H
  0004e 89 55 f0   mov         DWORD PTR __Block_size$1[ebp], edx

; 66   :              if (_Block_size <= _User_size)

  00051 8b 45 f0   mov         eax, DWORD PTR __Block_size$1[ebp]
  00054 3b 45 f8   cmp         eax, DWORD PTR __User_size$[ebp]
  00057 77 05        ja  SHORT $LN6@Allocate

; 67   :                  _Xbad_alloc();  // report no memory

  00059 e8 00 00 00 00     call    ?_Xbad_alloc@std@@YAXXZ      ; std::_Xbad_alloc
$LN6@Allocate:

; 68   :              const uintptr_t _Ptr_container =
; 69   :                  reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  0005e 8b 4d f0   mov         ecx, DWORD PTR __Block_size$1[ebp]
  00061 51                 push    ecx
  00062 e8 00 00 00 00     call    ??2@YAPAXI@Z   ; operator new
  00067 83 c4 04   add         esp, 4
  0006a 89 45 f4   mov         DWORD PTR __Ptr_container$2[ebp], eax

; 70   :              _SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  0006d 83 7d f4 00        cmp   DWORD PTR __Ptr_container$2[ebp], 0
  00071 75 05        jne         SHORT $LN7@Allocate
  00073 e8 00 00 00 00     call    __invalid_parameter_noinfo_noreturn
$LN7@Allocate:

; 71   :              _Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  00078 8b 55 f4   mov         edx, DWORD PTR __Ptr_container$2[ebp]
  0007b 83 c2 23   add         edx, 35                        ; 00000023H
  0007e 83 e2 e0   and         edx, -32             ; ffffffe0H
  00081 89 55 fc   mov         DWORD PTR __Ptr$[ebp], edx

; 72   :                  & ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   :              static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00084 b8 04 00 00 00     mov     eax, 4
  00089 6b c8 ff   imul        ecx, eax, -1
  0008c 8b 55 fc   mov         edx, DWORD PTR __Ptr$[ebp]
  0008f 8b 45 f4   mov         eax, DWORD PTR __Ptr_container$2[ebp]
  00092 89 04 0a   mov         DWORD PTR [edx+ecx], eax

; 74   :
; 75   :  #ifdef _DEBUG
; 76   :              static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 77   :  #endif /* _DEBUG */
; 78   :              }
; 79   :        else

  00095 eb 1a        jmp         SHORT $LN5@Allocate
$LN4@Allocate:

; 80   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 81   :
; 82   :              {   // allocate normal block
; 83   :              _Ptr = ::operator new(_User_size);

  00097 8b 4d f8   mov         ecx, DWORD PTR __User_size$[ebp]
  0009a 51                 push    ecx
  0009b e8 00 00 00 00     call    ??2@YAPAXI@Z   ; operator new
  000a0 83 c4 04   add         esp, 4
  000a3 89 45 fc   mov         DWORD PTR __Ptr$[ebp], eax

; 84   :              _SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  000a6 83 7d fc 00        cmp   DWORD PTR __Ptr$[ebp], 0
  000aa 75 05        jne         SHORT $LN5@Allocate
  000ac e8 00 00 00 00     call    __invalid_parameter_noinfo_noreturn
$LN5@Allocate:

; 85   :              }
; 86   :        return (_Ptr);

  000b1 8b 45 fc   mov         eax, DWORD PTR __Ptr$[ebp]
$LN9@Allocate:

; 87   :        }

  000b4 8b e5        mov         esp, ebp
  000b6 5d                 pop     ebp
  000b7 c3                 ret     0
?_Allocate@std@@YAPAXII_N@Z ENDP                        ; std::_Allocate
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ?_Getcont@_Iterator_base0@std@@QBEPBU_Container_base0@2@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Getcont@_Iterator_base0@std@@QBEPBU_Container_base0@2@XZ PROC ; std::_Iterator_base0::_Getcont, COMDAT
; _this$ = ecx

; 58   :              {   // get owning container

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 59   :              return (0);

  00007 33 c0        xor         eax, eax

; 60   :              }

  00009 8b e5        mov         esp, ebp
  0000b 5d                 pop     ebp
  0000c c3                 ret     0
?_Getcont@_Iterator_base0@std@@QBEPBU_Container_base0@2@XZ ENDP ; std::_Iterator_base0::_Getcont
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
___formal$ = 8                                      ; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC       ; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 54   :              {   // adopt this iterator by parent

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 55   :              }

  00007 8b e5        mov         esp, ebp
  00009 5d                 pop     ebp
  0000a c2 04 00   ret         4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP       ; std::_Iterator_base0::_Adopt
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;       COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC      ; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 43   :              {   // orphan all iterators

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 44   :              }

  00007 8b e5        mov         esp, ebp
  00009 5d                 pop     ebp
  0000a c3                 ret     0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP      ; std::_Container_base0::_Orphan_all
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;       COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT   SEGMENT
__Left$ = 8                                   ; size = 4
__Right$ = 12                                     ; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC         ; std::char_traits<char>::assign, COMDAT

; 564  :              {   // assign an element

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 565  :              _Left = _Right;

  00003 8b 45 08   mov         eax, DWORD PTR __Left$[ebp]
  00006 8b 4d 0c   mov         ecx, DWORD PTR __Right$[ebp]
  00009 8a 11        mov         dl, BYTE PTR [ecx]
  0000b 88 10        mov         BYTE PTR [eax], dl

; 566  :              }

  0000d 5d                 pop     ebp
  0000e c3                 ret     0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP         ; std::char_traits<char>::assign
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;       COMDAT ?assign@?$char_traits@D@std@@SAPADPADID@Z
_TEXT   SEGMENT
__First$ = 8                                            ; size = 4
__Count$ = 12                                     ; size = 4
__Ch$ = 16                                          ; size = 1
?assign@?$char_traits@D@std@@SAPADPADID@Z PROC      ; std::char_traits<char>::assign, COMDAT

; 559  :              {   // assign _Count * _Ch to [_First, ...)

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 560  :              return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  00003 8b 45 0c   mov         eax, DWORD PTR __Count$[ebp]
  00006 50                 push    eax
  00007 0f be 4d 10        movsx         ecx, BYTE PTR __Ch$[ebp]
  0000b 51                 push    ecx
  0000c 8b 55 08   mov         edx, DWORD PTR __First$[ebp]
  0000f 52                 push    edx
  00010 e8 00 00 00 00     call    _memset
  00015 83 c4 0c   add         esp, 12                        ; 0000000cH

; 561  :              }

  00018 5d                 pop     ebp
  00019 c3                 ret     0
?assign@?$char_traits@D@std@@SAPADPADID@Z ENDP      ; std::char_traits<char>::assign
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;       COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT   SEGMENT
tv69 = -4                                         ; size = 4
__First1$ = 8                                     ; size = 4
__First2$ = 12                                      ; size = 4
__Count$ = 16                                     ; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC      ; std::char_traits<char>::move, COMDAT

; 552  :              {   // copy [_First2, _First2 + _Count) to [_First1, ...)

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx

; 553  :              return (_Count == 0 ? _First1

  00004 83 7d 10 00        cmp   DWORD PTR __Count$[ebp], 0
  00008 75 08        jne         SHORT $LN3@move
  0000a 8b 45 08   mov         eax, DWORD PTR __First1$[ebp]
  0000d 89 45 fc   mov         DWORD PTR tv69[ebp], eax
  00010 eb 17        jmp         SHORT $LN4@move
$LN3@move:
  00012 8b 4d 10   mov         ecx, DWORD PTR __Count$[ebp]
  00015 51                 push    ecx
  00016 8b 55 0c   mov         edx, DWORD PTR __First2$[ebp]
  00019 52                 push    edx
  0001a 8b 45 08   mov         eax, DWORD PTR __First1$[ebp]
  0001d 50                 push    eax
  0001e e8 00 00 00 00     call    _memmove
  00023 83 c4 0c   add         esp, 12                        ; 0000000cH
  00026 89 45 fc   mov         DWORD PTR tv69[ebp], eax
$LN4@move:
  00029 8b 45 fc   mov         eax, DWORD PTR tv69[ebp]

; 554  :                  : (_Elem *)_CSTD memmove(_First1, _First2, _Count));
; 555  :              }

  0002c 8b e5        mov         esp, ebp
  0002e 5d                 pop     ebp
  0002f c3                 ret     0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP      ; std::char_traits<char>::move
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;       COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT   SEGMENT
tv69 = -4                                         ; size = 4
__First1$ = 8                                     ; size = 4
__First2$ = 12                                      ; size = 4
__Count$ = 16                                     ; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC      ; std::char_traits<char>::copy, COMDAT

; 529  :              {   // copy [_First2, _First2 + _Count) to [_First1, ...)

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx

; 530  :              return (_Count == 0 ? _First1

  00004 83 7d 10 00        cmp   DWORD PTR __Count$[ebp], 0
  00008 75 08        jne         SHORT $LN3@copy
  0000a 8b 45 08   mov         eax, DWORD PTR __First1$[ebp]
  0000d 89 45 fc   mov         DWORD PTR tv69[ebp], eax
  00010 eb 17        jmp         SHORT $LN4@copy
$LN3@copy:
  00012 8b 4d 10   mov         ecx, DWORD PTR __Count$[ebp]
  00015 51                 push    ecx
  00016 8b 55 0c   mov         edx, DWORD PTR __First2$[ebp]
  00019 52                 push    edx
  0001a 8b 45 08   mov         eax, DWORD PTR __First1$[ebp]
  0001d 50                 push    eax
  0001e e8 00 00 00 00     call    _memcpy
  00023 83 c4 0c   add         esp, 12                        ; 0000000cH
  00026 89 45 fc   mov         DWORD PTR tv69[ebp], eax
$LN4@copy:
  00029 8b 45 fc   mov         eax, DWORD PTR tv69[ebp]

; 531  :                  : (_Elem *)_CSTD memcpy(_First1, _First2, _Count));
; 532  :              }

  0002c 8b e5        mov         esp, ebp
  0002e 5d                 pop     ebp
  0002f c3                 ret     0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP      ; std::char_traits<char>::copy
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;       COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT   SEGMENT
tv68 = -4                                         ; size = 4
__First$ = 8                                            ; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC          ; std::char_traits<char>::length, COMDAT

; 522  :              {   // find length of null-terminated string

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx

; 523  :              return (*_First == 0 ? 0

  00004 8b 45 08   mov         eax, DWORD PTR __First$[ebp]
  00007 0f be 08   movsx       ecx, BYTE PTR [eax]
  0000a 85 c9        test        ecx, ecx
  0000c 75 09        jne         SHORT $LN3@length
  0000e c7 45 fc 00 00
        00 00          mov         DWORD PTR tv68[ebp], 0
  00015 eb 0f        jmp         SHORT $LN4@length
$LN3@length:
  00017 8b 55 08   mov         edx, DWORD PTR __First$[ebp]
  0001a 52                 push    edx
  0001b e8 00 00 00 00     call    _strlen
  00020 83 c4 04   add         esp, 4
  00023 89 45 fc   mov         DWORD PTR tv68[ebp], eax
$LN4@length:
  00026 8b 45 fc   mov         eax, DWORD PTR tv68[ebp]

; 524  :                  : _CSTD strlen(_First));
; 525  :              }

  00029 8b e5        mov         esp, ebp
  0002b 5d                 pop     ebp
  0002c c3                 ret     0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP          ; std::char_traits<char>::length
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;       COMDAT ?compare@?$char_traits@D@std@@SAHPBD0I@Z
_TEXT   SEGMENT
tv69 = -4                                         ; size = 4
__First1$ = 8                                     ; size = 4
__First2$ = 12                                      ; size = 4
__Count$ = 16                                     ; size = 4
?compare@?$char_traits@D@std@@SAHPBD0I@Z PROC         ; std::char_traits<char>::compare, COMDAT

; 516  :              {   // compare [_First1, _First1 + _Count) with [_First2, ...)

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx

; 517  :              return (_Count == 0 ? 0

  00004 83 7d 10 00        cmp   DWORD PTR __Count$[ebp], 0
  00008 75 09        jne         SHORT $LN3@compare
  0000a c7 45 fc 00 00
        00 00          mov         DWORD PTR tv69[ebp], 0
  00011 eb 17        jmp         SHORT $LN4@compare
$LN3@compare:
  00013 8b 45 10   mov         eax, DWORD PTR __Count$[ebp]
  00016 50                 push    eax
  00017 8b 4d 0c   mov         ecx, DWORD PTR __First2$[ebp]
  0001a 51                 push    ecx
  0001b 8b 55 08   mov         edx, DWORD PTR __First1$[ebp]
  0001e 52                 push    edx
  0001f e8 00 00 00 00     call    _memcmp
  00024 83 c4 0c   add         esp, 12                        ; 0000000cH
  00027 89 45 fc   mov         DWORD PTR tv69[ebp], eax
$LN4@compare:
  0002a 8b 45 fc   mov         eax, DWORD PTR tv69[ebp]

; 518  :                  : _CSTD memcmp(_First1, _First2, _Count));
; 519  :              }

  0002d 8b e5        mov         esp, ebp
  0002f 5d                 pop     ebp
  00030 c3                 ret     0
?compare@?$char_traits@D@std@@SAHPBD0I@Z ENDP         ; std::char_traits<char>::compare
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_new.h
;       COMDAT ??2@YAPAXIPAX@Z
_TEXT   SEGMENT
__Size$ = 8                                   ; size = 4
__Where$ = 12                                     ; size = 4
??2@YAPAXIPAX@Z PROC                                    ; operator new, COMDAT

; 87   :     {

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 88   :         (void)_Size;
; 89   :         return _Where;

  00003 8b 45 0c   mov         eax, DWORD PTR __Where$[ebp]

; 90   :     }

  00006 5d                 pop     ebp
  00007 c3                 ret     0
??2@YAPAXIPAX@Z ENDP                                    ; operator new
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\limits
;       COMDAT ?max@?$numeric_limits@E@std@@SAEXZ
_TEXT   SEGMENT
?max@?$numeric_limits@E@std@@SAEXZ PROC       ; std::numeric_limits<unsigned char>::max, COMDAT

; 448  :              {   // return maximum value

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 449  :              return (UCHAR_MAX);

  00003 0c ff        or  al, 255              ; 000000ffH

; 450  :              }

  00005 5d                 pop     ebp
  00006 c3                 ret     0
?max@?$numeric_limits@E@std@@SAEXZ ENDP       ; std::numeric_limits<unsigned char>::max
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\limits
;       COMDAT ?max@?$numeric_limits@D@std@@SADXZ
_TEXT   SEGMENT
?max@?$numeric_limits@D@std@@SADXZ PROC       ; std::numeric_limits<char>::max, COMDAT

; 216  :              {   // return maximum value

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp

; 217  :              return (CHAR_MAX);

  00003 b0 7f        mov         al, 127                        ; 0000007fH

; 218  :              }

  00005 5d                 pop     ebp
  00006 c3                 ret     0
?max@?$numeric_limits@D@std@@SADXZ ENDP       ; std::numeric_limits<char>::max
_TEXT   ENDS
; Function compile flags: /Odtp
;       COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
___flags$ = 8                                     ; size = 4
??_Gexception@std@@UAEPAXI@Z PROC                 ; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0000a e8 00 00 00 00     call    ??1exception@std@@UAE@XZ ; std::exception::~exception
  0000f 8b 45 08   mov         eax, DWORD PTR ___flags$[ebp]
  00012 83 e0 01   and         eax, 1
  00015 74 0e        je  SHORT $LN2@scalar
  00017 6a 0c        push        12             ; 0000000cH
  00019 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0001c 51                 push    ecx
  0001d e8 00 00 00 00     call    ??3@YAXPAXI@Z                ; operator delete
  00022 83 c4 08   add         esp, 8
$LN2@scalar:
  00025 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00028 8b e5        mov         esp, ebp
  0002a 5d                 pop     ebp
  0002b c2 04 00   ret         4
??_Gexception@std@@UAEPAXI@Z ENDP                 ; std::exception::`scalar deleting destructor'
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
;       COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT   SEGMENT
tv69 = -8                                         ; size = 4
_this$ = -4                                   ; size = 4
?what@exception@std@@UBEPBDXZ PROC                  ; std::exception::what, COMDAT
; _this$ = ecx

; 88   :     {

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 08   sub         esp, 8
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx

; 89   :         return _Data._What ? _Data._What : "Unknown exception";

  00009 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000c 83 78 04 00        cmp   DWORD PTR [eax+4], 0
  00010 74 0b        je  SHORT $LN3@what
  00012 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00015 8b 51 04   mov         edx, DWORD PTR [ecx+4]
  00018 89 55 f8   mov         DWORD PTR tv69[ebp], edx
  0001b eb 07        jmp         SHORT $LN4@what
$LN3@what:
  0001d c7 45 f8 00 00
        00 00          mov         DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception?$AA@
$LN4@what:
  00024 8b 45 f8   mov         eax, DWORD PTR tv69[ebp]

; 90   :     }

  00027 8b e5        mov         esp, ebp
  00029 5d                 pop     ebp
  0002a c3                 ret     0
?what@exception@std@@UBEPBDXZ ENDP                  ; std::exception::what
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
;       COMDAT ??1exception@std@@UAE@XZ
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
??1exception@std@@UAE@XZ PROC                     ; std::exception::~exception, COMDAT
; _this$ = ecx

; 83   :     {

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a c7 00 00 00 00
        00           mov     DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 84   :         __std_exception_destroy(&_Data);

  00010 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  00013 83 c1 04   add         ecx, 4
  00016 51                 push    ecx
  00017 e8 00 00 00 00     call    ___std_exception_destroy
  0001c 83 c4 04   add         esp, 4

; 85   :     }

  0001f 8b e5        mov         esp, ebp
  00021 5d                 pop     ebp
  00022 c3                 ret     0
??1exception@std@@UAE@XZ ENDP                     ; std::exception::~exception
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
;       COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Other$ = 8                                            ; size = 4
??0exception@std@@QAE@ABV01@@Z PROC           ; std::exception::exception, COMDAT
; _this$ = ecx

; 66   :     {

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a c7 00 00 00 00
        00           mov     DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00010 33 c9        xor         ecx, ecx
  00012 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  00015 83 c2 04   add         edx, 4
  00018 89 0a        mov         DWORD PTR [edx], ecx
  0001a 89 4a 04   mov         DWORD PTR [edx+4], ecx

; 67   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00020 83 c0 04   add         eax, 4
  00023 50                 push    eax
  00024 8b 4d 08   mov         ecx, DWORD PTR __Other$[ebp]
  00027 83 c1 04   add         ecx, 4
  0002a 51                 push    ecx
  0002b e8 00 00 00 00     call    ___std_exception_copy
  00030 83 c4 08   add         esp, 8

; 68   :     }

  00033 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00036 8b e5        mov         esp, ebp
  00038 5d                 pop     ebp
  00039 c2 04 00   ret         4
??0exception@std@@QAE@ABV01@@Z ENDP           ; std::exception::exception
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
;       COMDAT ??0exception@std@@QAE@QBDH@Z
_TEXT   SEGMENT
_this$ = -4                                   ; size = 4
__Message$ = 8                                      ; size = 4
___formal$ = 12                               ; size = 4
??0exception@std@@QAE@QBDH@Z PROC                 ; std::exception::exception, COMDAT
; _this$ = ecx

; 60   :     {

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 51                 push    ecx
  00004 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00007 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000a c7 00 00 00 00
        00           mov     DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 59   :         : _Data()

  00010 33 c9        xor         ecx, ecx
  00012 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  00015 83 c2 04   add         edx, 4
  00018 89 0a        mov         DWORD PTR [edx], ecx
  0001a 89 4a 04   mov         DWORD PTR [edx+4], ecx

; 61   :         _Data._What = _Message;

  0001d 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00020 8b 4d 08   mov         ecx, DWORD PTR __Message$[ebp]
  00023 89 48 04   mov         DWORD PTR [eax+4], ecx

; 62   :     }

  00026 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  00029 8b e5        mov         esp, ebp
  0002b 5d                 pop     ebp
  0002c c2 08 00   ret         8
??0exception@std@@QAE@QBDH@Z ENDP                 ; std::exception::exception
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
;       COMDAT ??0exception@std@@QAE@QBD@Z
_TEXT   SEGMENT
__InitData$ = -12                                 ; size = 8
_this$ = -4                                   ; size = 4
__Message$ = 8                                      ; size = 4
??0exception@std@@QAE@QBD@Z PROC                        ; std::exception::exception, COMDAT
; _this$ = ecx

; 53   :     {

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 0c   sub         esp, 12                        ; 0000000cH
  00006 89 4d fc   mov         DWORD PTR _this$[ebp], ecx
  00009 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0000c c7 00 00 00 00
        00           mov     DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 52   :         : _Data()

  00012 33 c9        xor         ecx, ecx
  00014 8b 55 fc   mov         edx, DWORD PTR _this$[ebp]
  00017 83 c2 04   add         edx, 4
  0001a 89 0a        mov         DWORD PTR [edx], ecx
  0001c 89 4a 04   mov         DWORD PTR [edx+4], ecx

; 54   :         __std_exception_data _InitData = { _Message, true };

  0001f 8b 45 08   mov         eax, DWORD PTR __Message$[ebp]
  00022 89 45 f4   mov         DWORD PTR __InitData$[ebp], eax
  00025 c6 45 f8 01        mov   BYTE PTR __InitData$[ebp+4], 1

; 55   :         __std_exception_copy(&_InitData, &_Data);

  00029 8b 4d fc   mov         ecx, DWORD PTR _this$[ebp]
  0002c 83 c1 04   add         ecx, 4
  0002f 51                 push    ecx
  00030 8d 55 f4   lea         edx, DWORD PTR __InitData$[ebp]
  00033 52                 push    edx
  00034 e8 00 00 00 00     call    ___std_exception_copy
  00039 83 c4 08   add         esp, 8

; 56   :     }

  0003c 8b 45 fc   mov         eax, DWORD PTR _this$[ebp]
  0003f 8b e5        mov         esp, ebp
  00041 5d                 pop     ebp
  00042 c2 04 00   ret         4
??0exception@std@@QAE@QBD@Z ENDP                        ; std::exception::exception
_TEXT   ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;       COMDAT ?_Hash_seq@std@@YAIPBEI@Z
_TEXT   SEGMENT
__FNV_prime$ = -16                                  ; size = 4
__FNV_offset_basis$ = -12                         ; size = 4
__Next$1 = -8                                     ; size = 4
__Val$ = -4                                   ; size = 4
__First$ = 8                                            ; size = 4
__Count$ = 12                                     ; size = 4
?_Hash_seq@std@@YAIPBEI@Z PROC                      ; std::_Hash_seq, COMDAT

; 336  :        {     // FNV-1a hash function for bytes in [_First, _First + _Count)

  00000 55                 push    ebp
  00001 8b ec        mov         ebp, esp
  00003 83 ec 10   sub         esp, 16                        ; 00000010H

; 337  :  #if defined(_WIN64)
; 338  :        static_assert(sizeof(size_t) == 8, "This code is for 64-bit size_t.");
; 339  :        const size_t _FNV_offset_basis = 14695981039346656037ULL;
; 340  :        const size_t _FNV_prime = 1099511628211ULL;
; 341  :
; 342  :  #else /* defined(_WIN64) */
; 343  :        static_assert(sizeof(size_t) == 4, "This code is for 32-bit size_t.");
; 344  :        const size_t _FNV_offset_basis = 2166136261U;

  00006 c7 45 f4 c5 9d
        1c 81          mov         DWORD PTR __FNV_offset_basis$[ebp], -2128831035 ; 811c9dc5H

; 345  :        const size_t _FNV_prime = 16777619U;

  0000d c7 45 f0 93 01
        00 01          mov         DWORD PTR __FNV_prime$[ebp], 16777619 ; 01000193H

; 346  :  #endif /* defined(_WIN64) */
; 347  :
; 348  :        size_t _Val = _FNV_offset_basis;

  00014 c7 45 fc c5 9d
        1c 81          mov         DWORD PTR __Val$[ebp], -2128831035 ; 811c9dc5H

; 349  :        for (size_t _Next = 0; _Next < _Count; ++_Next)

  0001b c7 45 f8 00 00
        00 00          mov         DWORD PTR __Next$1[ebp], 0
  00022 eb 09        jmp         SHORT $LN4@Hash_seq
$LN2@Hash_seq:
  00024 8b 45 f8   mov         eax, DWORD PTR __Next$1[ebp]
  00027 83 c0 01   add         eax, 1
  0002a 89 45 f8   mov         DWORD PTR __Next$1[ebp], eax
$LN4@Hash_seq:
  0002d 8b 4d f8   mov         ecx, DWORD PTR __Next$1[ebp]
  00030 3b 4d 0c   cmp         ecx, DWORD PTR __Count$[ebp]
  00033 73 1b        jae         SHORT $LN3@Hash_seq

; 350  :              {   // fold in another byte
; 351  :              _Val ^= (size_t)_First[_Next];

  00035 8b 55 08   mov         edx, DWORD PTR __First$[ebp]
  00038 03 55 f8   add         edx, DWORD PTR __Next$1[ebp]
  0003b 0f b6 02   movzx       eax, BYTE PTR [edx]
  0003e 33 45 fc   xor         eax, DWORD PTR __Val$[ebp]
  00041 89 45 fc   mov         DWORD PTR __Val$[ebp], eax

; 352  :              _Val *= _FNV_prime;

  00044 69 4d fc 93 01
        00 01          imul        ecx, DWORD PTR __Val$[ebp], 16777619
  0004b 89 4d fc   mov         DWORD PTR __Val$[ebp], ecx

; 353  :              }

  0004e eb d4        jmp         SHORT $LN2@Hash_seq
$LN3@Hash_seq:

; 354  :        return (_Val);

  00050 8b 45 fc   mov         eax, DWORD PTR __Val$[ebp]

; 355  :        }

  00053 8b e5        mov         esp, ebp
  00055 5d                 pop     ebp
  00056 c3                 ret     0
?_Hash_seq@std@@YAIPBEI@Z ENDP                      ; std::_Hash_seq
_TEXT   ENDS
END
